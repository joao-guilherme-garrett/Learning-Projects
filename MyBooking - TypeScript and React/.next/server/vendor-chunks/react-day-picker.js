"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-day-picker";
exports.ids = ["vendor-chunks/react-day-picker"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-day-picker/dist/index.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-day-picker/dist/index.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button),\n/* harmony export */   Caption: () => (/* binding */ Caption),\n/* harmony export */   CaptionDropdowns: () => (/* binding */ CaptionDropdowns),\n/* harmony export */   CaptionLabel: () => (/* binding */ CaptionLabel),\n/* harmony export */   CaptionNavigation: () => (/* binding */ CaptionNavigation),\n/* harmony export */   Day: () => (/* binding */ Day),\n/* harmony export */   DayContent: () => (/* binding */ DayContent),\n/* harmony export */   DayPicker: () => (/* binding */ DayPicker),\n/* harmony export */   DayPickerContext: () => (/* binding */ DayPickerContext),\n/* harmony export */   DayPickerProvider: () => (/* binding */ DayPickerProvider),\n/* harmony export */   Dropdown: () => (/* binding */ Dropdown),\n/* harmony export */   FocusContext: () => (/* binding */ FocusContext),\n/* harmony export */   FocusProvider: () => (/* binding */ FocusProvider),\n/* harmony export */   Footer: () => (/* binding */ Footer),\n/* harmony export */   Head: () => (/* binding */ Head),\n/* harmony export */   HeadRow: () => (/* binding */ HeadRow),\n/* harmony export */   IconDropdown: () => (/* binding */ IconDropdown),\n/* harmony export */   IconLeft: () => (/* binding */ IconLeft),\n/* harmony export */   IconRight: () => (/* binding */ IconRight),\n/* harmony export */   InternalModifier: () => (/* binding */ InternalModifier),\n/* harmony export */   Months: () => (/* binding */ Months),\n/* harmony export */   NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   NavigationProvider: () => (/* binding */ NavigationProvider),\n/* harmony export */   RootProvider: () => (/* binding */ RootProvider),\n/* harmony export */   Row: () => (/* binding */ Row),\n/* harmony export */   SelectMultipleContext: () => (/* binding */ SelectMultipleContext),\n/* harmony export */   SelectMultipleProvider: () => (/* binding */ SelectMultipleProvider),\n/* harmony export */   SelectMultipleProviderInternal: () => (/* binding */ SelectMultipleProviderInternal),\n/* harmony export */   SelectRangeContext: () => (/* binding */ SelectRangeContext),\n/* harmony export */   SelectRangeProvider: () => (/* binding */ SelectRangeProvider),\n/* harmony export */   SelectRangeProviderInternal: () => (/* binding */ SelectRangeProviderInternal),\n/* harmony export */   SelectSingleContext: () => (/* binding */ SelectSingleContext),\n/* harmony export */   SelectSingleProvider: () => (/* binding */ SelectSingleProvider),\n/* harmony export */   SelectSingleProviderInternal: () => (/* binding */ SelectSingleProviderInternal),\n/* harmony export */   WeekNumber: () => (/* binding */ WeekNumber),\n/* harmony export */   addToRange: () => (/* binding */ addToRange),\n/* harmony export */   isDateAfterType: () => (/* binding */ isDateAfterType),\n/* harmony export */   isDateBeforeType: () => (/* binding */ isDateBeforeType),\n/* harmony export */   isDateInterval: () => (/* binding */ isDateInterval),\n/* harmony export */   isDateRange: () => (/* binding */ isDateRange),\n/* harmony export */   isDayOfWeekType: () => (/* binding */ isDayOfWeekType),\n/* harmony export */   isDayPickerDefault: () => (/* binding */ isDayPickerDefault),\n/* harmony export */   isDayPickerMultiple: () => (/* binding */ isDayPickerMultiple),\n/* harmony export */   isDayPickerRange: () => (/* binding */ isDayPickerRange),\n/* harmony export */   isDayPickerSingle: () => (/* binding */ isDayPickerSingle),\n/* harmony export */   isMatch: () => (/* binding */ isMatch),\n/* harmony export */   useActiveModifiers: () => (/* binding */ useActiveModifiers),\n/* harmony export */   useDayPicker: () => (/* binding */ useDayPicker),\n/* harmony export */   useDayRender: () => (/* binding */ useDayRender),\n/* harmony export */   useFocusContext: () => (/* binding */ useFocusContext),\n/* harmony export */   useInput: () => (/* binding */ useInput),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useSelectMultiple: () => (/* binding */ useSelectMultiple),\n/* harmony export */   useSelectRange: () => (/* binding */ useSelectRange),\n/* harmony export */   useSelectSingle: () => (/* binding */ useSelectSingle)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var date_fns_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns/format */ \"(ssr)/./node_modules/date-fns/esm/format/index.js\");\n/* harmony import */ var date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns/startOfMonth */ \"(ssr)/./node_modules/date-fns/esm/startOfMonth/index.js\");\n/* harmony import */ var date_fns_endOfMonth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! date-fns/endOfMonth */ \"(ssr)/./node_modules/date-fns/esm/endOfMonth/index.js\");\n/* harmony import */ var date_fns_startOfDay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns/startOfDay */ \"(ssr)/./node_modules/date-fns/esm/startOfDay/index.js\");\n/* harmony import */ var date_fns_isSameYear__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns/isSameYear */ \"(ssr)/./node_modules/date-fns/esm/isSameYear/index.js\");\n/* harmony import */ var date_fns_setMonth__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! date-fns/setMonth */ \"(ssr)/./node_modules/date-fns/esm/setMonth/index.js\");\n/* harmony import */ var date_fns_setYear__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! date-fns/setYear */ \"(ssr)/./node_modules/date-fns/esm/setYear/index.js\");\n/* harmony import */ var date_fns_startOfYear__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! date-fns/startOfYear */ \"(ssr)/./node_modules/date-fns/esm/startOfYear/index.js\");\n/* harmony import */ var date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! date-fns/differenceInCalendarMonths */ \"(ssr)/./node_modules/date-fns/esm/differenceInCalendarMonths/index.js\");\n/* harmony import */ var date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! date-fns/addMonths */ \"(ssr)/./node_modules/date-fns/esm/addMonths/index.js\");\n/* harmony import */ var date_fns_isSameMonth__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! date-fns/isSameMonth */ \"(ssr)/./node_modules/date-fns/esm/isSameMonth/index.js\");\n/* harmony import */ var date_fns_isBefore__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! date-fns/isBefore */ \"(ssr)/./node_modules/date-fns/esm/isBefore/index.js\");\n/* harmony import */ var date_fns_startOfISOWeek__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! date-fns/startOfISOWeek */ \"(ssr)/./node_modules/date-fns/esm/startOfISOWeek/index.js\");\n/* harmony import */ var date_fns_startOfWeek__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! date-fns/startOfWeek */ \"(ssr)/./node_modules/date-fns/esm/startOfWeek/index.js\");\n/* harmony import */ var date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! date-fns/addDays */ \"(ssr)/./node_modules/date-fns/esm/addDays/index.js\");\n/* harmony import */ var date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! date-fns/isSameDay */ \"(ssr)/./node_modules/date-fns/esm/isSameDay/index.js\");\n/* harmony import */ var date_fns_isAfter__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! date-fns/isAfter */ \"(ssr)/./node_modules/date-fns/esm/isAfter/index.js\");\n/* harmony import */ var date_fns_subDays__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! date-fns/subDays */ \"(ssr)/./node_modules/date-fns/esm/subDays/index.js\");\n/* harmony import */ var date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! date-fns/differenceInCalendarDays */ \"(ssr)/./node_modules/date-fns/esm/differenceInCalendarDays/index.js\");\n/* harmony import */ var date_fns_isDate__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! date-fns/isDate */ \"(ssr)/./node_modules/date-fns/esm/isDate/index.js\");\n/* harmony import */ var date_fns_max__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! date-fns/max */ \"(ssr)/./node_modules/date-fns/esm/max/index.js\");\n/* harmony import */ var date_fns_min__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! date-fns/min */ \"(ssr)/./node_modules/date-fns/esm/min/index.js\");\n/* harmony import */ var date_fns_addWeeks__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! date-fns/addWeeks */ \"(ssr)/./node_modules/date-fns/esm/addWeeks/index.js\");\n/* harmony import */ var date_fns_addYears__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! date-fns/addYears */ \"(ssr)/./node_modules/date-fns/esm/addYears/index.js\");\n/* harmony import */ var date_fns_endOfISOWeek__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! date-fns/endOfISOWeek */ \"(ssr)/./node_modules/date-fns/esm/endOfISOWeek/index.js\");\n/* harmony import */ var date_fns_endOfWeek__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! date-fns/endOfWeek */ \"(ssr)/./node_modules/date-fns/esm/endOfWeek/index.js\");\n/* harmony import */ var date_fns_getUnixTime__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! date-fns/getUnixTime */ \"(ssr)/./node_modules/date-fns/esm/getUnixTime/index.js\");\n/* harmony import */ var date_fns_getISOWeek__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! date-fns/getISOWeek */ \"(ssr)/./node_modules/date-fns/esm/getISOWeek/index.js\");\n/* harmony import */ var date_fns_getWeek__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! date-fns/getWeek */ \"(ssr)/./node_modules/date-fns/esm/getWeek/index.js\");\n/* harmony import */ var date_fns_getWeeksInMonth__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! date-fns/getWeeksInMonth */ \"(ssr)/./node_modules/date-fns/esm/getWeeksInMonth/index.js\");\n/* harmony import */ var date_fns_parse__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! date-fns/parse */ \"(ssr)/./node_modules/date-fns/esm/parse/index.js\");\n/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! date-fns/locale */ \"(ssr)/./node_modules/date-fns/esm/locale/en-US/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar jsxRuntime = {\n    exports: {}\n};\nvar reactJsxRuntime_production_min = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredReactJsxRuntime_production_min;\nfunction requireReactJsxRuntime_production_min() {\n    if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;\n    hasRequiredReactJsxRuntime_production_min = 1;\n    var f = (react__WEBPACK_IMPORTED_MODULE_0___default()), k = Symbol.for(\"react.element\"), l = Symbol.for(\"react.fragment\"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = {\n        key: !0,\n        ref: !0,\n        __self: !0,\n        __source: !0\n    };\n    function q(c, a, g) {\n        var b, d = {}, e = null, h = null;\n        void 0 !== g && (e = \"\" + g);\n        void 0 !== a.key && (e = \"\" + a.key);\n        void 0 !== a.ref && (h = a.ref);\n        for(b in a)m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);\n        if (c && c.defaultProps) for(b in a = c.defaultProps, a)void 0 === d[b] && (d[b] = a[b]);\n        return {\n            $$typeof: k,\n            type: c,\n            key: e,\n            ref: h,\n            props: d,\n            _owner: n.current\n        };\n    }\n    reactJsxRuntime_production_min.Fragment = l;\n    reactJsxRuntime_production_min.jsx = q;\n    reactJsxRuntime_production_min.jsxs = q;\n    return reactJsxRuntime_production_min;\n}\nvar reactJsxRuntime_development = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredReactJsxRuntime_development;\nfunction requireReactJsxRuntime_development() {\n    if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;\n    hasRequiredReactJsxRuntime_development = 1;\n    if (true) {\n        (function() {\n            var React = (react__WEBPACK_IMPORTED_MODULE_0___default());\n            // ATTENTION\n            // When adding new symbols to this file,\n            // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n            // The Symbol used to tag the ReactElement-like types.\n            var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n            var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n            var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n            var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n            var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n            var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n            var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n            var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n            var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n            var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n            var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n            var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n            var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n            var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n            var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n            function getIteratorFn(maybeIterable) {\n                if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                    return null;\n                }\n                var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n                if (typeof maybeIterator === \"function\") {\n                    return maybeIterator;\n                }\n                return null;\n            }\n            var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n            function error(format) {\n                {\n                    {\n                        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                            args[_key2 - 1] = arguments[_key2];\n                        }\n                        printWarning(\"error\", format, args);\n                    }\n                }\n            }\n            function printWarning(level, format, args) {\n                // When changing this logic, you might want to also\n                // update consoleWithStackDev.www.js as well.\n                {\n                    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                    var stack = ReactDebugCurrentFrame.getStackAddendum();\n                    if (stack !== \"\") {\n                        format += \"%s\";\n                        args = args.concat([\n                            stack\n                        ]);\n                    } // eslint-disable-next-line react-internal/safe-string-coercion\n                    var argsWithFormat = args.map(function(item) {\n                        return String(item);\n                    }); // Careful: RN currently depends on this prefix\n                    argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                    // breaks IE9: https://github.com/facebook/react/issues/13610\n                    // eslint-disable-next-line react-internal/no-production-logging\n                    Function.prototype.apply.call(console[level], console, argsWithFormat);\n                }\n            }\n            // -----------------------------------------------------------------------------\n            var enableScopeAPI = false; // Experimental Create Event Handle API.\n            var enableCacheElement = false;\n            var enableTransitionTracing = false; // No known bugs, but needs performance testing\n            var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n            // stuff. Intended to enable React core members to more easily debug scheduling\n            // issues in DEV builds.\n            var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n            var REACT_MODULE_REFERENCE;\n            {\n                REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n            }\n            function isValidElementType(type) {\n                if (typeof type === \"string\" || typeof type === \"function\") {\n                    return true;\n                } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n                if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                    return true;\n                }\n                if (typeof type === \"object\" && type !== null) {\n                    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                    // types supported by any Flight configuration anywhere since\n                    // we don't know which Flight build this will end up being used\n                    // with.\n                    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function getWrappedName(outerType, innerType, wrapperName) {\n                var displayName = outerType.displayName;\n                if (displayName) {\n                    return displayName;\n                }\n                var functionName = innerType.displayName || innerType.name || \"\";\n                return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n            } // Keep in sync with react-reconciler/getComponentNameFromFiber\n            function getContextName(type) {\n                return type.displayName || \"Context\";\n            } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n            function getComponentNameFromType(type) {\n                if (type == null) {\n                    // Host root, text node or just invalid type.\n                    return null;\n                }\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                if (typeof type === \"function\") {\n                    return type.displayName || type.name || null;\n                }\n                if (typeof type === \"string\") {\n                    return type;\n                }\n                switch(type){\n                    case REACT_FRAGMENT_TYPE:\n                        return \"Fragment\";\n                    case REACT_PORTAL_TYPE:\n                        return \"Portal\";\n                    case REACT_PROFILER_TYPE:\n                        return \"Profiler\";\n                    case REACT_STRICT_MODE_TYPE:\n                        return \"StrictMode\";\n                    case REACT_SUSPENSE_TYPE:\n                        return \"Suspense\";\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return \"SuspenseList\";\n                }\n                if (typeof type === \"object\") {\n                    switch(type.$$typeof){\n                        case REACT_CONTEXT_TYPE:\n                            var context = type;\n                            return getContextName(context) + \".Consumer\";\n                        case REACT_PROVIDER_TYPE:\n                            var provider = type;\n                            return getContextName(provider._context) + \".Provider\";\n                        case REACT_FORWARD_REF_TYPE:\n                            return getWrappedName(type, type.render, \"ForwardRef\");\n                        case REACT_MEMO_TYPE:\n                            var outerName = type.displayName || null;\n                            if (outerName !== null) {\n                                return outerName;\n                            }\n                            return getComponentNameFromType(type.type) || \"Memo\";\n                        case REACT_LAZY_TYPE:\n                            {\n                                var lazyComponent = type;\n                                var payload = lazyComponent._payload;\n                                var init = lazyComponent._init;\n                                try {\n                                    return getComponentNameFromType(init(payload));\n                                } catch (x) {\n                                    return null;\n                                }\n                            }\n                    }\n                }\n                return null;\n            }\n            var assign = Object.assign;\n            // Helpers to patch console.logs to avoid logging during side-effect free\n            // replaying on render function. This currently only patches the object\n            // lazily which won't cover if the log function was extracted eagerly.\n            // We could also eagerly patch the method.\n            var disabledDepth = 0;\n            var prevLog;\n            var prevInfo;\n            var prevWarn;\n            var prevError;\n            var prevGroup;\n            var prevGroupCollapsed;\n            var prevGroupEnd;\n            function disabledLog() {}\n            disabledLog.__reactDisabledLog = true;\n            function disableLogs() {\n                {\n                    if (disabledDepth === 0) {\n                        /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                        prevInfo = console.info;\n                        prevWarn = console.warn;\n                        prevError = console.error;\n                        prevGroup = console.group;\n                        prevGroupCollapsed = console.groupCollapsed;\n                        prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                        var props = {\n                            configurable: true,\n                            enumerable: true,\n                            value: disabledLog,\n                            writable: true\n                        }; // $FlowFixMe Flow thinks console is immutable.\n                        Object.defineProperties(console, {\n                            info: props,\n                            log: props,\n                            warn: props,\n                            error: props,\n                            group: props,\n                            groupCollapsed: props,\n                            groupEnd: props\n                        });\n                    /* eslint-enable react-internal/no-production-logging */ }\n                    disabledDepth++;\n                }\n            }\n            function reenableLogs() {\n                {\n                    disabledDepth--;\n                    if (disabledDepth === 0) {\n                        /* eslint-disable react-internal/no-production-logging */ var props = {\n                            configurable: true,\n                            enumerable: true,\n                            writable: true\n                        }; // $FlowFixMe Flow thinks console is immutable.\n                        Object.defineProperties(console, {\n                            log: assign({}, props, {\n                                value: prevLog\n                            }),\n                            info: assign({}, props, {\n                                value: prevInfo\n                            }),\n                            warn: assign({}, props, {\n                                value: prevWarn\n                            }),\n                            error: assign({}, props, {\n                                value: prevError\n                            }),\n                            group: assign({}, props, {\n                                value: prevGroup\n                            }),\n                            groupCollapsed: assign({}, props, {\n                                value: prevGroupCollapsed\n                            }),\n                            groupEnd: assign({}, props, {\n                                value: prevGroupEnd\n                            })\n                        });\n                    /* eslint-enable react-internal/no-production-logging */ }\n                    if (disabledDepth < 0) {\n                        error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                    }\n                }\n            }\n            var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n            var prefix;\n            function describeBuiltInComponentFrame(name, source, ownerFn) {\n                {\n                    if (prefix === undefined) {\n                        // Extract the VM specific prefix used by each line.\n                        try {\n                            throw Error();\n                        } catch (x) {\n                            var match = x.stack.trim().match(/\\n( *(at )?)/);\n                            prefix = match && match[1] || \"\";\n                        }\n                    } // We use the prefix to ensure our stacks line up with native stack frames.\n                    return \"\\n\" + prefix + name;\n                }\n            }\n            var reentry = false;\n            var componentFrameCache;\n            {\n                var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n                componentFrameCache = new PossiblyWeakMap();\n            }\n            function describeNativeComponentFrame(fn, construct) {\n                // If something asked for a stack inside a fake render, it should get ignored.\n                if (!fn || reentry) {\n                    return \"\";\n                }\n                {\n                    var frame = componentFrameCache.get(fn);\n                    if (frame !== undefined) {\n                        return frame;\n                    }\n                }\n                var control;\n                reentry = true;\n                var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n                Error.prepareStackTrace = undefined;\n                var previousDispatcher;\n                {\n                    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                    // for warnings.\n                    ReactCurrentDispatcher.current = null;\n                    disableLogs();\n                }\n                try {\n                    // This should throw.\n                    if (construct) {\n                        // Something should be setting the props in the constructor.\n                        var Fake = function() {\n                            throw Error();\n                        }; // $FlowFixMe\n                        Object.defineProperty(Fake.prototype, \"props\", {\n                            set: function() {\n                                // We use a throwing setter instead of frozen or non-writable props\n                                // because that won't throw in a non-strict mode function.\n                                throw Error();\n                            }\n                        });\n                        if (typeof Reflect === \"object\" && Reflect.construct) {\n                            // We construct a different control for this case to include any extra\n                            // frames added by the construct call.\n                            try {\n                                Reflect.construct(Fake, []);\n                            } catch (x) {\n                                control = x;\n                            }\n                            Reflect.construct(fn, [], Fake);\n                        } else {\n                            try {\n                                Fake.call();\n                            } catch (x) {\n                                control = x;\n                            }\n                            fn.call(Fake.prototype);\n                        }\n                    } else {\n                        try {\n                            throw Error();\n                        } catch (x) {\n                            control = x;\n                        }\n                        fn();\n                    }\n                } catch (sample) {\n                    // This is inlined manually because closure doesn't do it for us.\n                    if (sample && control && typeof sample.stack === \"string\") {\n                        // This extracts the first frame from the sample that isn't also in the control.\n                        // Skipping one frame that we assume is the frame that calls the two.\n                        var sampleLines = sample.stack.split(\"\\n\");\n                        var controlLines = control.stack.split(\"\\n\");\n                        var s = sampleLines.length - 1;\n                        var c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                        for(; s >= 1 && c >= 0; s--, c--){\n                            // Next we find the first one that isn't the same which should be the\n                            // frame that called our sample function and the control.\n                            if (sampleLines[s] !== controlLines[c]) {\n                                // In V8, the first line is describing the message but other VMs don't.\n                                // If we're about to return the first line, and the control is also on the same\n                                // line, that's a pretty good indicator that our sample threw at same line as\n                                // the control. I.e. before we entered the sample frame. So we ignore this result.\n                                // This can happen if you passed a class to function component, or non-function.\n                                if (s !== 1 || c !== 1) {\n                                    do {\n                                        s--;\n                                        c--; // We may still have similar intermediate frames from the construct call.\n                                        // The next one that isn't the same should be our match though.\n                                        if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                            // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                            var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                            // but we have a user-provided \"displayName\"\n                                            // splice it in to make the stack more readable.\n                                            if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                                _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                            }\n                                            {\n                                                if (typeof fn === \"function\") {\n                                                    componentFrameCache.set(fn, _frame);\n                                                }\n                                            }\n                                            return _frame;\n                                        }\n                                    }while (s >= 1 && c >= 0);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                } finally{\n                    reentry = false;\n                    {\n                        ReactCurrentDispatcher.current = previousDispatcher;\n                        reenableLogs();\n                    }\n                    Error.prepareStackTrace = previousPrepareStackTrace;\n                } // Fallback to just using the name if we couldn't make it throw.\n                var name = fn ? fn.displayName || fn.name : \"\";\n                var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n                {\n                    if (typeof fn === \"function\") {\n                        componentFrameCache.set(fn, syntheticFrame);\n                    }\n                }\n                return syntheticFrame;\n            }\n            function describeFunctionComponentFrame(fn, source, ownerFn) {\n                {\n                    return describeNativeComponentFrame(fn, false);\n                }\n            }\n            function shouldConstruct(Component) {\n                var prototype = Component.prototype;\n                return !!(prototype && prototype.isReactComponent);\n            }\n            function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n                if (type == null) {\n                    return \"\";\n                }\n                if (typeof type === \"function\") {\n                    {\n                        return describeNativeComponentFrame(type, shouldConstruct(type));\n                    }\n                }\n                if (typeof type === \"string\") {\n                    return describeBuiltInComponentFrame(type);\n                }\n                switch(type){\n                    case REACT_SUSPENSE_TYPE:\n                        return describeBuiltInComponentFrame(\"Suspense\");\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return describeBuiltInComponentFrame(\"SuspenseList\");\n                }\n                if (typeof type === \"object\") {\n                    switch(type.$$typeof){\n                        case REACT_FORWARD_REF_TYPE:\n                            return describeFunctionComponentFrame(type.render);\n                        case REACT_MEMO_TYPE:\n                            // Memo may contain any component type so we recursively resolve it.\n                            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                        case REACT_LAZY_TYPE:\n                            {\n                                var lazyComponent = type;\n                                var payload = lazyComponent._payload;\n                                var init = lazyComponent._init;\n                                try {\n                                    // Lazy may contain any component type so we recursively resolve it.\n                                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                                } catch (x) {}\n                            }\n                    }\n                }\n                return \"\";\n            }\n            var hasOwnProperty = Object.prototype.hasOwnProperty;\n            var loggedTypeFailures = {};\n            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n            function setCurrentlyValidatingElement(element) {\n                {\n                    if (element) {\n                        var owner = element._owner;\n                        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                        ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                    } else {\n                        ReactDebugCurrentFrame.setExtraStackFrame(null);\n                    }\n                }\n            }\n            function checkPropTypes(typeSpecs, values, location, componentName, element) {\n                {\n                    // $FlowFixMe This is okay but Flow doesn't know it.\n                    var has = Function.call.bind(hasOwnProperty);\n                    for(var typeSpecName in typeSpecs){\n                        if (has(typeSpecs, typeSpecName)) {\n                            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                            // fail the render phase where it didn't fail before. So we log it.\n                            // After these have been cleaned up, we'll let them throw.\n                            try {\n                                // This is intentionally an invariant that gets caught. It's the same\n                                // behavior as without this statement except with a better message.\n                                if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                    // eslint-disable-next-line react-internal/prod-error-codes\n                                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                    err.name = \"Invariant Violation\";\n                                    throw err;\n                                }\n                                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                            } catch (ex) {\n                                error$1 = ex;\n                            }\n                            if (error$1 && !(error$1 instanceof Error)) {\n                                setCurrentlyValidatingElement(element);\n                                error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                                setCurrentlyValidatingElement(null);\n                            }\n                            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                                // Only monitor this failure once because there tends to be a lot of the\n                                // same error.\n                                loggedTypeFailures[error$1.message] = true;\n                                setCurrentlyValidatingElement(element);\n                                error(\"Failed %s type: %s\", location, error$1.message);\n                                setCurrentlyValidatingElement(null);\n                            }\n                        }\n                    }\n                }\n            }\n            var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n            function isArray(a) {\n                return isArrayImpl(a);\n            }\n            /*\n\t * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n\t * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n\t *\n\t * The functions in this module will throw an easier-to-understand,\n\t * easier-to-debug exception with a clear errors message message explaining the\n\t * problem. (Instead of a confusing exception thrown inside the implementation\n\t * of the `value` object).\n\t */ // $FlowFixMe only called in DEV, so void return is not possible.\n            function typeName(value) {\n                {\n                    // toStringTag is needed for namespaced types like Temporal.Instant\n                    var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n                    return type;\n                }\n            } // $FlowFixMe only called in DEV, so void return is not possible.\n            function willCoercionThrow(value) {\n                {\n                    try {\n                        testStringCoercion(value);\n                        return false;\n                    } catch (e) {\n                        return true;\n                    }\n                }\n            }\n            function testStringCoercion(value) {\n                // If you ended up here by following an exception call stack, here's what's\n                // happened: you supplied an object or symbol value to React (as a prop, key,\n                // DOM attribute, CSS property, string ref, etc.) and when React tried to\n                // coerce it to a string using `'' + value`, an exception was thrown.\n                //\n                // The most common types that will cause this exception are `Symbol` instances\n                // and Temporal objects like `Temporal.Instant`. But any object that has a\n                // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n                // exception. (Library authors do this to prevent users from using built-in\n                // numeric operators like `+` or comparison operators like `>=` because custom\n                // methods are needed to perform accurate arithmetic or comparison.)\n                //\n                // To fix the problem, coerce this object or symbol value to a string before\n                // passing it to React. The most reliable way is usually `String(value)`.\n                //\n                // To find which value is throwing, check the browser or debugger console.\n                // Before this exception was thrown, there should be `console.error` output\n                // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n                // problem and how that type was used: key, atrribute, input value prop, etc.\n                // In most cases, this console output also shows the component and its\n                // ancestor components where the exception happened.\n                //\n                // eslint-disable-next-line react-internal/safe-string-coercion\n                return \"\" + value;\n            }\n            function checkKeyStringCoercion(value) {\n                {\n                    if (willCoercionThrow(value)) {\n                        error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                        return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                    }\n                }\n            }\n            var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n            var RESERVED_PROPS = {\n                key: true,\n                ref: true,\n                __self: true,\n                __source: true\n            };\n            var specialPropKeyWarningShown;\n            var specialPropRefWarningShown;\n            var didWarnAboutStringRefs;\n            {\n                didWarnAboutStringRefs = {};\n            }\n            function hasValidRef(config) {\n                {\n                    if (hasOwnProperty.call(config, \"ref\")) {\n                        var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                        if (getter && getter.isReactWarning) {\n                            return false;\n                        }\n                    }\n                }\n                return config.ref !== undefined;\n            }\n            function hasValidKey(config) {\n                {\n                    if (hasOwnProperty.call(config, \"key\")) {\n                        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                        if (getter && getter.isReactWarning) {\n                            return false;\n                        }\n                    }\n                }\n                return config.key !== undefined;\n            }\n            function warnIfStringRefCannotBeAutoConverted(config, self) {\n                {\n                    if (typeof config.ref === \"string\" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n                        var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n                        if (!didWarnAboutStringRefs[componentName]) {\n                            error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n                            didWarnAboutStringRefs[componentName] = true;\n                        }\n                    }\n                }\n            }\n            function defineKeyPropWarningGetter(props, displayName) {\n                {\n                    var warnAboutAccessingKey = function() {\n                        if (!specialPropKeyWarningShown) {\n                            specialPropKeyWarningShown = true;\n                            error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                        }\n                    };\n                    warnAboutAccessingKey.isReactWarning = true;\n                    Object.defineProperty(props, \"key\", {\n                        get: warnAboutAccessingKey,\n                        configurable: true\n                    });\n                }\n            }\n            function defineRefPropWarningGetter(props, displayName) {\n                {\n                    var warnAboutAccessingRef = function() {\n                        if (!specialPropRefWarningShown) {\n                            specialPropRefWarningShown = true;\n                            error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                        }\n                    };\n                    warnAboutAccessingRef.isReactWarning = true;\n                    Object.defineProperty(props, \"ref\", {\n                        get: warnAboutAccessingRef,\n                        configurable: true\n                    });\n                }\n            }\n            /**\n\t * Factory method to create a new React element. This no longer adheres to\n\t * the class pattern, so do not use new to call it. Also, instanceof check\n\t * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n\t * if something is a React Element.\n\t *\n\t * @param {*} type\n\t * @param {*} props\n\t * @param {*} key\n\t * @param {string|object} ref\n\t * @param {*} owner\n\t * @param {*} self A *temporary* helper to detect places where `this` is\n\t * different from the `owner` when React.createElement is called, so that we\n\t * can warn. We want to get rid of owner and replace string `ref`s with arrow\n\t * functions, and as long as `this` and owner are the same, there will be no\n\t * change in behavior.\n\t * @param {*} source An annotation object (added by a transpiler or otherwise)\n\t * indicating filename, line number, and/or other information.\n\t * @internal\n\t */ var ReactElement = function(type, key, ref, self, source, owner, props) {\n                var element = {\n                    // This tag allows us to uniquely identify this as a React Element\n                    $$typeof: REACT_ELEMENT_TYPE,\n                    // Built-in properties that belong on the element\n                    type: type,\n                    key: key,\n                    ref: ref,\n                    props: props,\n                    // Record the component responsible for creating this element.\n                    _owner: owner\n                };\n                {\n                    // The validation flag is currently mutative. We put it on\n                    // an external backing store so that we can freeze the whole object.\n                    // This can be replaced with a WeakMap once they are implemented in\n                    // commonly used development environments.\n                    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                    // the validation flag non-enumerable (where possible, which should\n                    // include every environment we run tests in), so the test framework\n                    // ignores it.\n                    Object.defineProperty(element._store, \"validated\", {\n                        configurable: false,\n                        enumerable: false,\n                        writable: true,\n                        value: false\n                    }); // self and source are DEV only properties.\n                    Object.defineProperty(element, \"_self\", {\n                        configurable: false,\n                        enumerable: false,\n                        writable: false,\n                        value: self\n                    }); // Two elements created in two different places should be considered\n                    // equal for testing purposes and therefore we hide it from enumeration.\n                    Object.defineProperty(element, \"_source\", {\n                        configurable: false,\n                        enumerable: false,\n                        writable: false,\n                        value: source\n                    });\n                    if (Object.freeze) {\n                        Object.freeze(element.props);\n                        Object.freeze(element);\n                    }\n                }\n                return element;\n            };\n            /**\n\t * https://github.com/reactjs/rfcs/pull/107\n\t * @param {*} type\n\t * @param {object} props\n\t * @param {string} key\n\t */ function jsxDEV(type, config, maybeKey, source, self) {\n                {\n                    var propName; // Reserved names are extracted\n                    var props = {};\n                    var key = null;\n                    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                    // but as an intermediary step, we will use jsxDEV for everything except\n                    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                    // key is explicitly declared to be undefined or not.\n                    if (maybeKey !== undefined) {\n                        {\n                            checkKeyStringCoercion(maybeKey);\n                        }\n                        key = \"\" + maybeKey;\n                    }\n                    if (hasValidKey(config)) {\n                        {\n                            checkKeyStringCoercion(config.key);\n                        }\n                        key = \"\" + config.key;\n                    }\n                    if (hasValidRef(config)) {\n                        ref = config.ref;\n                        warnIfStringRefCannotBeAutoConverted(config, self);\n                    } // Remaining properties are added to a new props object\n                    for(propName in config){\n                        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                            props[propName] = config[propName];\n                        }\n                    } // Resolve default props\n                    if (type && type.defaultProps) {\n                        var defaultProps = type.defaultProps;\n                        for(propName in defaultProps){\n                            if (props[propName] === undefined) {\n                                props[propName] = defaultProps[propName];\n                            }\n                        }\n                    }\n                    if (key || ref) {\n                        var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                        if (key) {\n                            defineKeyPropWarningGetter(props, displayName);\n                        }\n                        if (ref) {\n                            defineRefPropWarningGetter(props, displayName);\n                        }\n                    }\n                    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n                }\n            }\n            var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n            var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n            function setCurrentlyValidatingElement$1(element) {\n                {\n                    if (element) {\n                        var owner = element._owner;\n                        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                        ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                    } else {\n                        ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                    }\n                }\n            }\n            var propTypesMisspellWarningShown;\n            {\n                propTypesMisspellWarningShown = false;\n            }\n            /**\n\t * Verifies the object is a ReactElement.\n\t * See https://reactjs.org/docs/react-api.html#isvalidelement\n\t * @param {?object} object\n\t * @return {boolean} True if `object` is a ReactElement.\n\t * @final\n\t */ function isValidElement(object) {\n                {\n                    return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                }\n            }\n            function getDeclarationErrorAddendum() {\n                {\n                    if (ReactCurrentOwner$1.current) {\n                        var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                        if (name) {\n                            return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                        }\n                    }\n                    return \"\";\n                }\n            }\n            function getSourceInfoErrorAddendum(source) {\n                {\n                    if (source !== undefined) {\n                        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                        var lineNumber = source.lineNumber;\n                        return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                    }\n                    return \"\";\n                }\n            }\n            /**\n\t * Warn if there's no key explicitly set on dynamic arrays of children or\n\t * object keys are not valid. This allows us to keep track of children between\n\t * updates.\n\t */ var ownerHasKeyUseWarning = {};\n            function getCurrentComponentErrorInfo(parentType) {\n                {\n                    var info = getDeclarationErrorAddendum();\n                    if (!info) {\n                        var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n                        if (parentName) {\n                            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                        }\n                    }\n                    return info;\n                }\n            }\n            /**\n\t * Warn if the element doesn't have an explicit key assigned to it.\n\t * This element is in an array. The array could grow and shrink or be\n\t * reordered. All children that haven't already been validated are required to\n\t * have a \"key\" property assigned to it. Error statuses are cached so a warning\n\t * will only be shown once.\n\t *\n\t * @internal\n\t * @param {ReactElement} element Element that requires a key.\n\t * @param {*} parentType element's parent's type.\n\t */ function validateExplicitKey(element, parentType) {\n                {\n                    if (!element._store || element._store.validated || element.key != null) {\n                        return;\n                    }\n                    element._store.validated = true;\n                    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                        return;\n                    }\n                    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                    // property, it may be the creator of the child that's responsible for\n                    // assigning it a key.\n                    var childOwner = \"\";\n                    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n                        // Give the component that originally created this child.\n                        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                    }\n                    setCurrentlyValidatingElement$1(element);\n                    error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                    setCurrentlyValidatingElement$1(null);\n                }\n            }\n            /**\n\t * Ensure that every element either is passed in a static location, in an\n\t * array with an explicit keys property defined, or in an object literal\n\t * with valid key property.\n\t *\n\t * @internal\n\t * @param {ReactNode} node Statically passed child of any type.\n\t * @param {*} parentType node's parent's type.\n\t */ function validateChildKeys(node, parentType) {\n                {\n                    if (typeof node !== \"object\") {\n                        return;\n                    }\n                    if (isArray(node)) {\n                        for(var i = 0; i < node.length; i++){\n                            var child = node[i];\n                            if (isValidElement(child)) {\n                                validateExplicitKey(child, parentType);\n                            }\n                        }\n                    } else if (isValidElement(node)) {\n                        // This element was passed in a valid location.\n                        if (node._store) {\n                            node._store.validated = true;\n                        }\n                    } else if (node) {\n                        var iteratorFn = getIteratorFn(node);\n                        if (typeof iteratorFn === \"function\") {\n                            // Entry iterators used to provide implicit keys,\n                            // but now we print a separate warning for them later.\n                            if (iteratorFn !== node.entries) {\n                                var iterator = iteratorFn.call(node);\n                                var step;\n                                while(!(step = iterator.next()).done){\n                                    if (isValidElement(step.value)) {\n                                        validateExplicitKey(step.value, parentType);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            /**\n\t * Given an element, validate that its props follow the propTypes definition,\n\t * provided by the type.\n\t *\n\t * @param {ReactElement} element\n\t */ function validatePropTypes(element) {\n                {\n                    var type = element.type;\n                    if (type === null || type === undefined || typeof type === \"string\") {\n                        return;\n                    }\n                    var propTypes;\n                    if (typeof type === \"function\") {\n                        propTypes = type.propTypes;\n                    } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                    // Inner props are checked in the reconciler.\n                    type.$$typeof === REACT_MEMO_TYPE)) {\n                        propTypes = type.propTypes;\n                    } else {\n                        return;\n                    }\n                    if (propTypes) {\n                        // Intentionally inside to avoid triggering lazy initializers:\n                        var name = getComponentNameFromType(type);\n                        checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                        propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                        var _name = getComponentNameFromType(type);\n                        error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                    }\n                    if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                        error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                    }\n                }\n            }\n            /**\n\t * Given a fragment, validate that it can only be provided with fragment props\n\t * @param {ReactElement} fragment\n\t */ function validateFragmentProps(fragment) {\n                {\n                    var keys = Object.keys(fragment.props);\n                    for(var i = 0; i < keys.length; i++){\n                        var key = keys[i];\n                        if (key !== \"children\" && key !== \"key\") {\n                            setCurrentlyValidatingElement$1(fragment);\n                            error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                            setCurrentlyValidatingElement$1(null);\n                            break;\n                        }\n                    }\n                    if (fragment.ref !== null) {\n                        setCurrentlyValidatingElement$1(fragment);\n                        error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                        setCurrentlyValidatingElement$1(null);\n                    }\n                }\n            }\n            function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n                {\n                    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                    // succeed and there will likely be errors in render.\n                    if (!validType) {\n                        var info = \"\";\n                        if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                            info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                        }\n                        var sourceInfo = getSourceInfoErrorAddendum(source);\n                        if (sourceInfo) {\n                            info += sourceInfo;\n                        } else {\n                            info += getDeclarationErrorAddendum();\n                        }\n                        var typeString;\n                        if (type === null) {\n                            typeString = \"null\";\n                        } else if (isArray(type)) {\n                            typeString = \"array\";\n                        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                            typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                            info = \" Did you accidentally export a JSX literal instead of a component?\";\n                        } else {\n                            typeString = typeof type;\n                        }\n                        error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                    }\n                    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                    // TODO: Drop this when these are no longer allowed as the type argument.\n                    if (element == null) {\n                        return element;\n                    } // Skip key warning if the type isn't valid since our key validation logic\n                    // doesn't expect a non-string/function type and can throw confusing errors.\n                    // We don't want exception behavior to differ between dev and prod.\n                    // (Rendering will throw with a helpful message and as soon as the type is\n                    // fixed, the key warnings will appear.)\n                    if (validType) {\n                        var children = props.children;\n                        if (children !== undefined) {\n                            if (isStaticChildren) {\n                                if (isArray(children)) {\n                                    for(var i = 0; i < children.length; i++){\n                                        validateChildKeys(children[i], type);\n                                    }\n                                    if (Object.freeze) {\n                                        Object.freeze(children);\n                                    }\n                                } else {\n                                    error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                                }\n                            } else {\n                                validateChildKeys(children, type);\n                            }\n                        }\n                    }\n                    if (type === REACT_FRAGMENT_TYPE) {\n                        validateFragmentProps(element);\n                    } else {\n                        validatePropTypes(element);\n                    }\n                    return element;\n                }\n            } // These two functions exist to still get child warnings in dev\n            // even with the prod transform. This means that jsxDEV is purely\n            // opt-in behavior for better messages but that we won't stop\n            // giving you warnings if you use production apis.\n            function jsxWithValidationStatic(type, props, key) {\n                {\n                    return jsxWithValidation(type, props, key, true);\n                }\n            }\n            function jsxWithValidationDynamic(type, props, key) {\n                {\n                    return jsxWithValidation(type, props, key, false);\n                }\n            }\n            var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.\n            // for now we can ship identical prod functions\n            var jsxs = jsxWithValidationStatic;\n            reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;\n            reactJsxRuntime_development.jsx = jsx;\n            reactJsxRuntime_development.jsxs = jsxs;\n        })();\n    }\n    return reactJsxRuntime_development;\n}\nif (false) {} else {\n    jsxRuntime.exports = requireReactJsxRuntime_development();\n}\nvar jsxRuntimeExports = jsxRuntime.exports;\n/** Returns true when the props are of type {@link DayPickerMultipleProps}. */ function isDayPickerMultiple(props) {\n    return props.mode === \"multiple\";\n}\n/** Returns true when the props are of type {@link DayPickerRangeProps}. */ function isDayPickerRange(props) {\n    return props.mode === \"range\";\n}\n/** Returns true when the props are of type {@link DayPickerSingleProps}. */ function isDayPickerSingle(props) {\n    return props.mode === \"single\";\n}\n/**\n * The name of the default CSS classes.\n */ var defaultClassNames = {\n    root: \"rdp\",\n    multiple_months: \"rdp-multiple_months\",\n    with_weeknumber: \"rdp-with_weeknumber\",\n    vhidden: \"rdp-vhidden\",\n    button_reset: \"rdp-button_reset\",\n    button: \"rdp-button\",\n    caption: \"rdp-caption\",\n    caption_start: \"rdp-caption_start\",\n    caption_end: \"rdp-caption_end\",\n    caption_between: \"rdp-caption_between\",\n    caption_label: \"rdp-caption_label\",\n    caption_dropdowns: \"rdp-caption_dropdowns\",\n    dropdown: \"rdp-dropdown\",\n    dropdown_month: \"rdp-dropdown_month\",\n    dropdown_year: \"rdp-dropdown_year\",\n    dropdown_icon: \"rdp-dropdown_icon\",\n    months: \"rdp-months\",\n    month: \"rdp-month\",\n    table: \"rdp-table\",\n    tbody: \"rdp-tbody\",\n    tfoot: \"rdp-tfoot\",\n    head: \"rdp-head\",\n    head_row: \"rdp-head_row\",\n    head_cell: \"rdp-head_cell\",\n    nav: \"rdp-nav\",\n    nav_button: \"rdp-nav_button\",\n    nav_button_previous: \"rdp-nav_button_previous\",\n    nav_button_next: \"rdp-nav_button_next\",\n    nav_icon: \"rdp-nav_icon\",\n    row: \"rdp-row\",\n    weeknumber: \"rdp-weeknumber\",\n    cell: \"rdp-cell\",\n    day: \"rdp-day\",\n    day_today: \"rdp-day_today\",\n    day_outside: \"rdp-day_outside\",\n    day_selected: \"rdp-day_selected\",\n    day_disabled: \"rdp-day_disabled\",\n    day_hidden: \"rdp-day_hidden\",\n    day_range_start: \"rdp-day_range_start\",\n    day_range_end: \"rdp-day_range_end\",\n    day_range_middle: \"rdp-day_range_middle\"\n};\n/**\n * The default formatter for the caption.\n */ function formatCaption(month, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(month, \"LLLL y\", options);\n}\n/**\n * The default formatter for the Day button.\n */ function formatDay(day, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(day, \"d\", options);\n}\n/**\n * The default formatter for the Month caption.\n */ function formatMonthCaption(month, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(month, \"LLLL\", options);\n}\n/**\n * The default formatter for the week number.\n */ function formatWeekNumber(weekNumber) {\n    return \"\".concat(weekNumber);\n}\n/**\n * The default formatter for the name of the weekday.\n */ function formatWeekdayName(weekday, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(weekday, \"cccccc\", options);\n}\n/**\n * The default formatter for the Year caption.\n */ function formatYearCaption(year, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(year, \"yyyy\", options);\n}\nvar formatters = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    formatCaption: formatCaption,\n    formatDay: formatDay,\n    formatMonthCaption: formatMonthCaption,\n    formatWeekNumber: formatWeekNumber,\n    formatWeekdayName: formatWeekdayName,\n    formatYearCaption: formatYearCaption\n});\n/**\n * The default ARIA label for the day button.\n */ var labelDay = function(day, activeModifiers, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(day, \"do MMMM (EEEE)\", options);\n};\n/**\n * The default ARIA label for the WeekNumber element.\n */ var labelMonthDropdown = function() {\n    return \"Month: \";\n};\n/**\n * The default ARIA label for next month button in navigation\n */ var labelNext = function() {\n    return \"Go to next month\";\n};\n/**\n * The default ARIA label for previous month button in navigation\n */ var labelPrevious = function() {\n    return \"Go to previous month\";\n};\n/**\n * The default ARIA label for the Weekday element.\n */ var labelWeekday = function(day, options) {\n    return (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(day, \"cccc\", options);\n};\n/**\n * The default ARIA label for the WeekNumber element.\n */ var labelWeekNumber = function(n) {\n    return \"Week n. \".concat(n);\n};\n/**\n * The default ARIA label for the WeekNumber element.\n */ var labelYearDropdown = function() {\n    return \"Year: \";\n};\nvar labels = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    labelDay: labelDay,\n    labelMonthDropdown: labelMonthDropdown,\n    labelNext: labelNext,\n    labelPrevious: labelPrevious,\n    labelWeekNumber: labelWeekNumber,\n    labelWeekday: labelWeekday,\n    labelYearDropdown: labelYearDropdown\n});\n/**\n * Returns the default values to use in the DayPickerContext, in case they are\n * not passed down with the DayPicker initial props.\n */ function getDefaultContextValues() {\n    var captionLayout = \"buttons\";\n    var classNames = defaultClassNames;\n    var locale = date_fns_locale__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n    var modifiersClassNames = {};\n    var modifiers = {};\n    var numberOfMonths = 1;\n    var styles = {};\n    var today = new Date();\n    return {\n        captionLayout: captionLayout,\n        classNames: classNames,\n        formatters: formatters,\n        labels: labels,\n        locale: locale,\n        modifiersClassNames: modifiersClassNames,\n        modifiers: modifiers,\n        numberOfMonths: numberOfMonths,\n        styles: styles,\n        today: today,\n        mode: \"default\"\n    };\n}\n/** Return the `fromDate` and `toDate` prop values values parsing the DayPicker props. */ function parseFromToProps(props) {\n    var fromYear = props.fromYear, toYear = props.toYear, fromMonth = props.fromMonth, toMonth = props.toMonth;\n    var fromDate = props.fromDate, toDate = props.toDate;\n    if (fromMonth) {\n        fromDate = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(fromMonth);\n    } else if (fromYear) {\n        fromDate = new Date(fromYear, 0, 1);\n    }\n    if (toMonth) {\n        toDate = (0,date_fns_endOfMonth__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(toMonth);\n    } else if (toYear) {\n        toDate = new Date(toYear, 11, 31);\n    }\n    return {\n        fromDate: fromDate ? (0,date_fns_startOfDay__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(fromDate) : undefined,\n        toDate: toDate ? (0,date_fns_startOfDay__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(toDate) : undefined\n    };\n}\n/**\n * The DayPicker context shares the props passed to DayPicker within internal\n * and custom components. It is used to set the default values and perform\n * one-time calculations required to render the days.\n *\n * Access to this context from the {@link useDayPicker} hook.\n */ var DayPickerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/**\n * The provider for the {@link DayPickerContext}, assigning the defaults from the\n * initial DayPicker props.\n */ function DayPickerProvider(props) {\n    var _a;\n    var initialProps = props.initialProps;\n    var defaultContextValues = getDefaultContextValues();\n    var _b = parseFromToProps(initialProps), fromDate = _b.fromDate, toDate = _b.toDate;\n    var captionLayout = (_a = initialProps.captionLayout) !== null && _a !== void 0 ? _a : defaultContextValues.captionLayout;\n    if (captionLayout !== \"buttons\" && (!fromDate || !toDate)) {\n        // When no from/to dates are set, the caption is always buttons\n        captionLayout = \"buttons\";\n    }\n    var onSelect;\n    if (isDayPickerSingle(initialProps) || isDayPickerMultiple(initialProps) || isDayPickerRange(initialProps)) {\n        onSelect = initialProps.onSelect;\n    }\n    var value = __assign(__assign(__assign({}, defaultContextValues), initialProps), {\n        captionLayout: captionLayout,\n        classNames: __assign(__assign({}, defaultContextValues.classNames), initialProps.classNames),\n        components: __assign({}, initialProps.components),\n        formatters: __assign(__assign({}, defaultContextValues.formatters), initialProps.formatters),\n        fromDate: fromDate,\n        labels: __assign(__assign({}, defaultContextValues.labels), initialProps.labels),\n        mode: initialProps.mode || defaultContextValues.mode,\n        modifiers: __assign(__assign({}, defaultContextValues.modifiers), initialProps.modifiers),\n        modifiersClassNames: __assign(__assign({}, defaultContextValues.modifiersClassNames), initialProps.modifiersClassNames),\n        onSelect: onSelect,\n        styles: __assign(__assign({}, defaultContextValues.styles), initialProps.styles),\n        toDate: toDate\n    });\n    return jsxRuntimeExports.jsx(DayPickerContext.Provider, __assign({\n        value: value\n    }, {\n        children: props.children\n    }));\n}\n/**\n * Hook to access the {@link DayPickerContextValue}.\n *\n * Use the DayPicker context to access to the props passed to DayPicker inside\n * internal or custom components.\n */ function useDayPicker() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DayPickerContext);\n    if (!context) {\n        throw new Error(\"useDayPicker must be used within a DayPickerProvider.\");\n    }\n    return context;\n}\n/** Render the caption for the displayed month. This component is used when `captionLayout=\"buttons\"`. */ function CaptionLabel(props) {\n    var _a = useDayPicker(), locale = _a.locale, classNames = _a.classNames, styles = _a.styles, formatCaption = _a.formatters.formatCaption;\n    return jsxRuntimeExports.jsx(\"div\", __assign({\n        className: classNames.caption_label,\n        style: styles.caption_label,\n        \"aria-live\": \"polite\",\n        role: \"presentation\",\n        id: props.id\n    }, {\n        children: formatCaption(props.displayMonth, {\n            locale: locale\n        })\n    }));\n}\n/**\n * Render the icon in the styled drop-down.\n */ function IconDropdown(props) {\n    return jsxRuntimeExports.jsx(\"svg\", __assign({\n        width: \"8px\",\n        height: \"8px\",\n        viewBox: \"0 0 120 120\",\n        \"data-testid\": \"iconDropdown\"\n    }, props, {\n        children: jsxRuntimeExports.jsx(\"path\", {\n            d: \"M4.22182541,48.2218254 C8.44222828,44.0014225 15.2388494,43.9273804 19.5496459,47.9996989 L19.7781746,48.2218254 L60,88.443 L100.221825,48.2218254 C104.442228,44.0014225 111.238849,43.9273804 115.549646,47.9996989 L115.778175,48.2218254 C119.998577,52.4422283 120.07262,59.2388494 116.000301,63.5496459 L115.778175,63.7781746 L67.7781746,111.778175 C63.5577717,115.998577 56.7611506,116.07262 52.4503541,112.000301 L52.2218254,111.778175 L4.22182541,63.7781746 C-0.0739418023,59.4824074 -0.0739418023,52.5175926 4.22182541,48.2218254 Z\",\n            fill: \"currentColor\",\n            fillRule: \"nonzero\"\n        })\n    }));\n}\n/**\n * Render a styled select component – displaying a caption and a custom\n * drop-down icon.\n */ function Dropdown(props) {\n    var _a, _b;\n    var onChange = props.onChange, value = props.value, children = props.children, caption = props.caption, className = props.className, style = props.style;\n    var dayPicker = useDayPicker();\n    var IconDropdownComponent = (_b = (_a = dayPicker.components) === null || _a === void 0 ? void 0 : _a.IconDropdown) !== null && _b !== void 0 ? _b : IconDropdown;\n    return jsxRuntimeExports.jsxs(\"div\", __assign({\n        className: className,\n        style: style\n    }, {\n        children: [\n            jsxRuntimeExports.jsx(\"span\", __assign({\n                className: dayPicker.classNames.vhidden\n            }, {\n                children: props[\"aria-label\"]\n            })),\n            jsxRuntimeExports.jsx(\"select\", __assign({\n                name: props.name,\n                \"aria-label\": props[\"aria-label\"],\n                className: dayPicker.classNames.dropdown,\n                style: dayPicker.styles.dropdown,\n                value: value,\n                onChange: onChange\n            }, {\n                children: children\n            })),\n            jsxRuntimeExports.jsxs(\"div\", __assign({\n                className: dayPicker.classNames.caption_label,\n                style: dayPicker.styles.caption_label,\n                \"aria-hidden\": \"true\"\n            }, {\n                children: [\n                    caption,\n                    jsxRuntimeExports.jsx(IconDropdownComponent, {\n                        className: dayPicker.classNames.dropdown_icon,\n                        style: dayPicker.styles.dropdown_icon\n                    })\n                ]\n            }))\n        ]\n    }));\n}\n/** Render the dropdown to navigate between months. */ function MonthsDropdown(props) {\n    var _a;\n    var _b = useDayPicker(), fromDate = _b.fromDate, toDate = _b.toDate, styles = _b.styles, locale = _b.locale, formatMonthCaption = _b.formatters.formatMonthCaption, classNames = _b.classNames, components = _b.components, labelMonthDropdown = _b.labels.labelMonthDropdown;\n    // Dropdown should appear only when both from/toDate is set\n    if (!fromDate) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    if (!toDate) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    var dropdownMonths = [];\n    if ((0,date_fns_isSameYear__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(fromDate, toDate)) {\n        // only display the months included in the range\n        var date = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(fromDate);\n        for(var month = fromDate.getMonth(); month <= toDate.getMonth(); month++){\n            dropdownMonths.push((0,date_fns_setMonth__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(date, month));\n        }\n    } else {\n        // display all the 12 months\n        var date = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new Date()); // Any date should be OK, as we just need the year\n        for(var month = 0; month <= 11; month++){\n            dropdownMonths.push((0,date_fns_setMonth__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(date, month));\n        }\n    }\n    var handleChange = function(e) {\n        var selectedMonth = Number(e.target.value);\n        var newMonth = (0,date_fns_setMonth__WEBPACK_IMPORTED_MODULE_7__[\"default\"])((0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(props.displayMonth), selectedMonth);\n        props.onChange(newMonth);\n    };\n    var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : Dropdown;\n    return jsxRuntimeExports.jsx(DropdownComponent, __assign({\n        name: \"months\",\n        \"aria-label\": labelMonthDropdown(),\n        className: classNames.dropdown_month,\n        style: styles.dropdown_month,\n        onChange: handleChange,\n        value: props.displayMonth.getMonth(),\n        caption: formatMonthCaption(props.displayMonth, {\n            locale: locale\n        })\n    }, {\n        children: dropdownMonths.map(function(m) {\n            return jsxRuntimeExports.jsx(\"option\", __assign({\n                value: m.getMonth()\n            }, {\n                children: formatMonthCaption(m, {\n                    locale: locale\n                })\n            }), m.getMonth());\n        })\n    }));\n}\n/**\n * Render a dropdown to change the year. Take in account the `nav.fromDate` and\n * `toDate` from context.\n */ function YearsDropdown(props) {\n    var _a;\n    var displayMonth = props.displayMonth;\n    var _b = useDayPicker(), fromDate = _b.fromDate, toDate = _b.toDate, locale = _b.locale, styles = _b.styles, classNames = _b.classNames, components = _b.components, formatYearCaption = _b.formatters.formatYearCaption, labelYearDropdown = _b.labels.labelYearDropdown;\n    var years = [];\n    // Dropdown should appear only when both from/toDate is set\n    if (!fromDate) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    if (!toDate) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    var fromYear = fromDate.getFullYear();\n    var toYear = toDate.getFullYear();\n    for(var year = fromYear; year <= toYear; year++){\n        years.push((0,date_fns_setYear__WEBPACK_IMPORTED_MODULE_8__[\"default\"])((0,date_fns_startOfYear__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(new Date()), year));\n    }\n    var handleChange = function(e) {\n        var newMonth = (0,date_fns_setYear__WEBPACK_IMPORTED_MODULE_8__[\"default\"])((0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(displayMonth), Number(e.target.value));\n        props.onChange(newMonth);\n    };\n    var DropdownComponent = (_a = components === null || components === void 0 ? void 0 : components.Dropdown) !== null && _a !== void 0 ? _a : Dropdown;\n    return jsxRuntimeExports.jsx(DropdownComponent, __assign({\n        name: \"years\",\n        \"aria-label\": labelYearDropdown(),\n        className: classNames.dropdown_year,\n        style: styles.dropdown_year,\n        onChange: handleChange,\n        value: displayMonth.getFullYear(),\n        caption: formatYearCaption(displayMonth, {\n            locale: locale\n        })\n    }, {\n        children: years.map(function(year) {\n            return jsxRuntimeExports.jsx(\"option\", __assign({\n                value: year.getFullYear()\n            }, {\n                children: formatYearCaption(year, {\n                    locale: locale\n                })\n            }), year.getFullYear());\n        })\n    }));\n}\n/**\n * Helper hook for using controlled/uncontrolled values from a component props.\n *\n * When the value is not controlled, pass `undefined` as `controlledValue` and\n * use the returned setter to update it.\n *\n * When the value is controlled, pass the controlled value as second\n * argument, which will be always returned as `value`.\n */ function useControlledValue(defaultValue, controlledValue) {\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue), uncontrolledValue = _a[0], setValue = _a[1];\n    var value = controlledValue === undefined ? uncontrolledValue : controlledValue;\n    return [\n        value,\n        setValue\n    ];\n}\n/** Return the initial month according to the given options. */ function getInitialMonth(context) {\n    var month = context.month, defaultMonth = context.defaultMonth, today = context.today;\n    var initialMonth = month || defaultMonth || today || new Date();\n    var toDate = context.toDate, fromDate = context.fromDate, _a = context.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;\n    // Fix the initialMonth if is after the to-date\n    if (toDate && (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(toDate, initialMonth) < 0) {\n        var offset = -1 * (numberOfMonths - 1);\n        initialMonth = (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(toDate, offset);\n    }\n    // Fix the initialMonth if is before the from-date\n    if (fromDate && (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(initialMonth, fromDate) < 0) {\n        initialMonth = fromDate;\n    }\n    return (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(initialMonth);\n}\n/** Controls the navigation state. */ function useNavigationState() {\n    var context = useDayPicker();\n    var initialMonth = getInitialMonth(context);\n    var _a = useControlledValue(initialMonth, context.month), month = _a[0], setMonth = _a[1];\n    var goToMonth = function(date) {\n        var _a;\n        if (context.disableNavigation) return;\n        var month = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(date);\n        setMonth(month);\n        (_a = context.onMonthChange) === null || _a === void 0 ? void 0 : _a.call(context, month);\n    };\n    return [\n        month,\n        goToMonth\n    ];\n}\n/**\n * Return the months to display in the component according to the number of\n * months and the from/to date.\n */ function getDisplayMonths(month, _a) {\n    var reverseMonths = _a.reverseMonths, numberOfMonths = _a.numberOfMonths;\n    var start = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(month);\n    var end = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(start, numberOfMonths));\n    var monthsDiff = (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(end, start);\n    var months = [];\n    for(var i = 0; i < monthsDiff; i++){\n        var nextMonth = (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(start, i);\n        months.push(nextMonth);\n    }\n    if (reverseMonths) months = months.reverse();\n    return months;\n}\n/**\n * Returns the next month the user can navigate to according to the given\n * options.\n *\n * Please note that the next month is not always the next calendar month:\n *\n * - if after the `toDate` range, is undefined;\n * - if the navigation is paged, is the number of months displayed ahead.\n *\n */ function getNextMonth(startingMonth, options) {\n    if (options.disableNavigation) {\n        return undefined;\n    }\n    var toDate = options.toDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;\n    var offset = pagedNavigation ? numberOfMonths : 1;\n    var month = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(startingMonth);\n    if (!toDate) {\n        return (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(month, offset);\n    }\n    var monthsDiff = (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(toDate, startingMonth);\n    if (monthsDiff < numberOfMonths) {\n        return undefined;\n    }\n    // Jump forward as the number of months when paged navigation\n    return (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(month, offset);\n}\n/**\n * Returns the next previous the user can navigate to, according to the given\n * options.\n *\n * Please note that the previous month is not always the previous calendar\n * month:\n *\n * - if before the `fromDate` date, is `undefined`;\n * - if the navigation is paged, is the number of months displayed before.\n *\n */ function getPreviousMonth(startingMonth, options) {\n    if (options.disableNavigation) {\n        return undefined;\n    }\n    var fromDate = options.fromDate, pagedNavigation = options.pagedNavigation, _a = options.numberOfMonths, numberOfMonths = _a === void 0 ? 1 : _a;\n    var offset = pagedNavigation ? numberOfMonths : 1;\n    var month = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(startingMonth);\n    if (!fromDate) {\n        return (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(month, -offset);\n    }\n    var monthsDiff = (0,date_fns_differenceInCalendarMonths__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(month, fromDate);\n    if (monthsDiff <= 0) {\n        return undefined;\n    }\n    // Jump back as the number of months when paged navigation\n    return (0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(month, -offset);\n}\n/**\n * The Navigation context shares details and methods to navigate the months in DayPicker.\n * Access this context from the {@link useNavigation} hook.\n */ var NavigationContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provides the values for the {@link NavigationContext}. */ function NavigationProvider(props) {\n    var dayPicker = useDayPicker();\n    var _a = useNavigationState(), currentMonth = _a[0], goToMonth = _a[1];\n    var displayMonths = getDisplayMonths(currentMonth, dayPicker);\n    var nextMonth = getNextMonth(currentMonth, dayPicker);\n    var previousMonth = getPreviousMonth(currentMonth, dayPicker);\n    var isDateDisplayed = function(date) {\n        return displayMonths.some(function(displayMonth) {\n            return (0,date_fns_isSameMonth__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(date, displayMonth);\n        });\n    };\n    var goToDate = function(date, refDate) {\n        if (isDateDisplayed(date)) {\n            return;\n        }\n        if (refDate && (0,date_fns_isBefore__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(date, refDate)) {\n            goToMonth((0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(date, 1 + dayPicker.numberOfMonths * -1));\n        } else {\n            goToMonth(date);\n        }\n    };\n    var value = {\n        currentMonth: currentMonth,\n        displayMonths: displayMonths,\n        goToMonth: goToMonth,\n        goToDate: goToDate,\n        previousMonth: previousMonth,\n        nextMonth: nextMonth,\n        isDateDisplayed: isDateDisplayed\n    };\n    return jsxRuntimeExports.jsx(NavigationContext.Provider, __assign({\n        value: value\n    }, {\n        children: props.children\n    }));\n}\n/**\n * Hook to access the {@link NavigationContextValue}. Use this hook to navigate\n * between months or years in DayPicker.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useNavigation() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext);\n    if (!context) {\n        throw new Error(\"useNavigation must be used within a NavigationProvider\");\n    }\n    return context;\n}\n/**\n * Render a caption with the dropdowns to navigate between months and years.\n */ function CaptionDropdowns(props) {\n    var _a;\n    var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;\n    var goToMonth = useNavigation().goToMonth;\n    var handleMonthChange = function(newMonth) {\n        goToMonth((0,date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(newMonth, props.displayIndex ? -props.displayIndex : 0));\n    };\n    var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;\n    var captionLabel = jsxRuntimeExports.jsx(CaptionLabelComponent, {\n        id: props.id,\n        displayMonth: props.displayMonth\n    });\n    return jsxRuntimeExports.jsxs(\"div\", __assign({\n        className: classNames.caption_dropdowns,\n        style: styles.caption_dropdowns\n    }, {\n        children: [\n            jsxRuntimeExports.jsx(\"div\", __assign({\n                className: classNames.vhidden\n            }, {\n                children: captionLabel\n            })),\n            jsxRuntimeExports.jsx(MonthsDropdown, {\n                onChange: handleMonthChange,\n                displayMonth: props.displayMonth\n            }),\n            jsxRuntimeExports.jsx(YearsDropdown, {\n                onChange: handleMonthChange,\n                displayMonth: props.displayMonth\n            })\n        ]\n    }));\n}\n/**\n * Render the \"previous month\" button in the navigation.\n */ function IconLeft(props) {\n    return jsxRuntimeExports.jsx(\"svg\", __assign({\n        width: \"16px\",\n        height: \"16px\",\n        viewBox: \"0 0 120 120\"\n    }, props, {\n        children: jsxRuntimeExports.jsx(\"path\", {\n            d: \"M69.490332,3.34314575 C72.6145263,0.218951416 77.6798462,0.218951416 80.8040405,3.34314575 C83.8617626,6.40086786 83.9268205,11.3179931 80.9992143,14.4548388 L80.8040405,14.6568542 L35.461,60 L80.8040405,105.343146 C83.8617626,108.400868 83.9268205,113.317993 80.9992143,116.454839 L80.8040405,116.656854 C77.7463184,119.714576 72.8291931,119.779634 69.6923475,116.852028 L69.490332,116.656854 L18.490332,65.6568542 C15.4326099,62.5991321 15.367552,57.6820069 18.2951583,54.5451612 L18.490332,54.3431458 L69.490332,3.34314575 Z\",\n            fill: \"currentColor\",\n            fillRule: \"nonzero\"\n        })\n    }));\n}\n/**\n * Render the \"next month\" button in the navigation.\n */ function IconRight(props) {\n    return jsxRuntimeExports.jsx(\"svg\", __assign({\n        width: \"16px\",\n        height: \"16px\",\n        viewBox: \"0 0 120 120\"\n    }, props, {\n        children: jsxRuntimeExports.jsx(\"path\", {\n            d: \"M49.8040405,3.34314575 C46.6798462,0.218951416 41.6145263,0.218951416 38.490332,3.34314575 C35.4326099,6.40086786 35.367552,11.3179931 38.2951583,14.4548388 L38.490332,14.6568542 L83.8333725,60 L38.490332,105.343146 C35.4326099,108.400868 35.367552,113.317993 38.2951583,116.454839 L38.490332,116.656854 C41.5480541,119.714576 46.4651794,119.779634 49.602025,116.852028 L49.8040405,116.656854 L100.804041,65.6568542 C103.861763,62.5991321 103.926821,57.6820069 100.999214,54.5451612 L100.804041,54.3431458 L49.8040405,3.34314575 Z\",\n            fill: \"currentColor\"\n        })\n    }));\n}\n/** Render a button HTML element applying the reset class name. */ var Button = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(props, ref) {\n    var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles;\n    var classNamesArr = [\n        classNames.button_reset,\n        classNames.button\n    ];\n    if (props.className) {\n        classNamesArr.push(props.className);\n    }\n    var className = classNamesArr.join(\" \");\n    var style = __assign(__assign({}, styles.button_reset), styles.button);\n    if (props.style) {\n        Object.assign(style, props.style);\n    }\n    return jsxRuntimeExports.jsx(\"button\", __assign({}, props, {\n        ref: ref,\n        type: \"button\",\n        className: className,\n        style: style\n    }));\n});\n/** A component rendering the navigation buttons or the drop-downs. */ function Navigation(props) {\n    var _a, _b;\n    var _c = useDayPicker(), dir = _c.dir, locale = _c.locale, classNames = _c.classNames, styles = _c.styles, _d = _c.labels, labelPrevious = _d.labelPrevious, labelNext = _d.labelNext, components = _c.components;\n    if (!props.nextMonth && !props.previousMonth) {\n        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    }\n    var previousLabel = labelPrevious(props.previousMonth, {\n        locale: locale\n    });\n    var previousClassName = [\n        classNames.nav_button,\n        classNames.nav_button_previous\n    ].join(\" \");\n    var nextLabel = labelNext(props.nextMonth, {\n        locale: locale\n    });\n    var nextClassName = [\n        classNames.nav_button,\n        classNames.nav_button_next\n    ].join(\" \");\n    var IconRightComponent = (_a = components === null || components === void 0 ? void 0 : components.IconRight) !== null && _a !== void 0 ? _a : IconRight;\n    var IconLeftComponent = (_b = components === null || components === void 0 ? void 0 : components.IconLeft) !== null && _b !== void 0 ? _b : IconLeft;\n    return jsxRuntimeExports.jsxs(\"div\", __assign({\n        className: classNames.nav,\n        style: styles.nav\n    }, {\n        children: [\n            !props.hidePrevious && jsxRuntimeExports.jsx(Button, __assign({\n                name: \"previous-month\",\n                \"aria-label\": previousLabel,\n                className: previousClassName,\n                style: styles.nav_button_previous,\n                disabled: !props.previousMonth,\n                onClick: props.onPreviousClick\n            }, {\n                children: dir === \"rtl\" ? jsxRuntimeExports.jsx(IconRightComponent, {\n                    className: classNames.nav_icon,\n                    style: styles.nav_icon\n                }) : jsxRuntimeExports.jsx(IconLeftComponent, {\n                    className: classNames.nav_icon,\n                    style: styles.nav_icon\n                })\n            })),\n            !props.hideNext && jsxRuntimeExports.jsx(Button, __assign({\n                name: \"next-month\",\n                \"aria-label\": nextLabel,\n                className: nextClassName,\n                style: styles.nav_button_next,\n                disabled: !props.nextMonth,\n                onClick: props.onNextClick\n            }, {\n                children: dir === \"rtl\" ? jsxRuntimeExports.jsx(IconLeftComponent, {\n                    className: classNames.nav_icon,\n                    style: styles.nav_icon\n                }) : jsxRuntimeExports.jsx(IconRightComponent, {\n                    className: classNames.nav_icon,\n                    style: styles.nav_icon\n                })\n            }))\n        ]\n    }));\n}\n/**\n * Render a caption with a button-based navigation.\n */ function CaptionNavigation(props) {\n    var numberOfMonths = useDayPicker().numberOfMonths;\n    var _a = useNavigation(), previousMonth = _a.previousMonth, nextMonth = _a.nextMonth, goToMonth = _a.goToMonth, displayMonths = _a.displayMonths;\n    var displayIndex = displayMonths.findIndex(function(month) {\n        return (0,date_fns_isSameMonth__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(props.displayMonth, month);\n    });\n    var isFirst = displayIndex === 0;\n    var isLast = displayIndex === displayMonths.length - 1;\n    var hideNext = numberOfMonths > 1 && (isFirst || !isLast);\n    var hidePrevious = numberOfMonths > 1 && (isLast || !isFirst);\n    var handlePreviousClick = function() {\n        if (!previousMonth) return;\n        goToMonth(previousMonth);\n    };\n    var handleNextClick = function() {\n        if (!nextMonth) return;\n        goToMonth(nextMonth);\n    };\n    return jsxRuntimeExports.jsx(Navigation, {\n        displayMonth: props.displayMonth,\n        hideNext: hideNext,\n        hidePrevious: hidePrevious,\n        nextMonth: nextMonth,\n        previousMonth: previousMonth,\n        onPreviousClick: handlePreviousClick,\n        onNextClick: handleNextClick\n    });\n}\n/**\n * Render the caption of a month. The caption has a different layout when\n * setting the {@link DayPickerBase.captionLayout} prop.\n */ function Caption(props) {\n    var _a;\n    var _b = useDayPicker(), classNames = _b.classNames, disableNavigation = _b.disableNavigation, styles = _b.styles, captionLayout = _b.captionLayout, components = _b.components;\n    var CaptionLabelComponent = (_a = components === null || components === void 0 ? void 0 : components.CaptionLabel) !== null && _a !== void 0 ? _a : CaptionLabel;\n    var caption;\n    if (disableNavigation) {\n        caption = jsxRuntimeExports.jsx(CaptionLabelComponent, {\n            id: props.id,\n            displayMonth: props.displayMonth\n        });\n    } else if (captionLayout === \"dropdown\") {\n        caption = jsxRuntimeExports.jsx(CaptionDropdowns, {\n            displayMonth: props.displayMonth,\n            id: props.id\n        });\n    } else if (captionLayout === \"dropdown-buttons\") {\n        caption = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {\n            children: [\n                jsxRuntimeExports.jsx(CaptionDropdowns, {\n                    displayMonth: props.displayMonth,\n                    displayIndex: props.displayIndex,\n                    id: props.id\n                }),\n                jsxRuntimeExports.jsx(CaptionNavigation, {\n                    displayMonth: props.displayMonth,\n                    displayIndex: props.displayIndex,\n                    id: props.id\n                })\n            ]\n        });\n    } else {\n        caption = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {\n            children: [\n                jsxRuntimeExports.jsx(CaptionLabelComponent, {\n                    id: props.id,\n                    displayMonth: props.displayMonth,\n                    displayIndex: props.displayIndex\n                }),\n                jsxRuntimeExports.jsx(CaptionNavigation, {\n                    displayMonth: props.displayMonth,\n                    id: props.id\n                })\n            ]\n        });\n    }\n    return jsxRuntimeExports.jsx(\"div\", __assign({\n        className: classNames.caption,\n        style: styles.caption\n    }, {\n        children: caption\n    }));\n}\n/** Render the Footer component (empty as default).*/ // eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction Footer(props) {\n    var _a = useDayPicker(), footer = _a.footer, styles = _a.styles, tfoot = _a.classNames.tfoot;\n    if (!footer) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});\n    return jsxRuntimeExports.jsx(\"tfoot\", __assign({\n        className: tfoot,\n        style: styles.tfoot\n    }, {\n        children: jsxRuntimeExports.jsx(\"tr\", {\n            children: jsxRuntimeExports.jsx(\"td\", __assign({\n                colSpan: 8\n            }, {\n                children: footer\n            }))\n        })\n    }));\n}\n/**\n * Generate a series of 7 days, starting from the week, to use for formatting\n * the weekday names (Monday, Tuesday, etc.).\n */ function getWeekdays(locale, /** The index of the first day of the week (0 - Sunday). */ weekStartsOn, /** Use ISOWeek instead of locale/ */ ISOWeek) {\n    var start = ISOWeek ? (0,date_fns_startOfISOWeek__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(new Date()) : (0,date_fns_startOfWeek__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(new Date(), {\n        locale: locale,\n        weekStartsOn: weekStartsOn\n    });\n    var days = [];\n    for(var i = 0; i < 7; i++){\n        var day = (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(start, i);\n        days.push(day);\n    }\n    return days;\n}\n/**\n * Render the HeadRow component - i.e. the table head row with the weekday names.\n */ function HeadRow() {\n    var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles, showWeekNumber = _a.showWeekNumber, locale = _a.locale, weekStartsOn = _a.weekStartsOn, ISOWeek = _a.ISOWeek, formatWeekdayName = _a.formatters.formatWeekdayName, labelWeekday = _a.labels.labelWeekday;\n    var weekdays = getWeekdays(locale, weekStartsOn, ISOWeek);\n    return jsxRuntimeExports.jsxs(\"tr\", __assign({\n        style: styles.head_row,\n        className: classNames.head_row\n    }, {\n        children: [\n            showWeekNumber && jsxRuntimeExports.jsx(\"td\", {\n                style: styles.head_cell,\n                className: classNames.head_cell\n            }),\n            weekdays.map(function(weekday, i) {\n                return jsxRuntimeExports.jsx(\"th\", __assign({\n                    scope: \"col\",\n                    className: classNames.head_cell,\n                    style: styles.head_cell,\n                    \"aria-label\": labelWeekday(weekday, {\n                        locale: locale\n                    })\n                }, {\n                    children: formatWeekdayName(weekday, {\n                        locale: locale\n                    })\n                }), i);\n            })\n        ]\n    }));\n}\n/** Render the table head. */ function Head() {\n    var _a;\n    var _b = useDayPicker(), classNames = _b.classNames, styles = _b.styles, components = _b.components;\n    var HeadRowComponent = (_a = components === null || components === void 0 ? void 0 : components.HeadRow) !== null && _a !== void 0 ? _a : HeadRow;\n    return jsxRuntimeExports.jsx(\"thead\", __assign({\n        style: styles.head,\n        className: classNames.head\n    }, {\n        children: jsxRuntimeExports.jsx(HeadRowComponent, {})\n    }));\n}\n/** Render the content of the day cell. */ function DayContent(props) {\n    var _a = useDayPicker(), locale = _a.locale, formatDay = _a.formatters.formatDay;\n    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {\n        children: formatDay(props.date, {\n            locale: locale\n        })\n    });\n}\n/**\n * The SelectMultiple context shares details about the selected days when in\n * multiple selection mode.\n *\n * Access this context from the {@link useSelectMultiple} hook.\n */ var SelectMultipleContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provides the values for the {@link SelectMultipleContext}. */ function SelectMultipleProvider(props) {\n    if (!isDayPickerMultiple(props.initialProps)) {\n        var emptyContextValue = {\n            selected: undefined,\n            modifiers: {\n                disabled: []\n            }\n        };\n        return jsxRuntimeExports.jsx(SelectMultipleContext.Provider, __assign({\n            value: emptyContextValue\n        }, {\n            children: props.children\n        }));\n    }\n    return jsxRuntimeExports.jsx(SelectMultipleProviderInternal, {\n        initialProps: props.initialProps,\n        children: props.children\n    });\n}\nfunction SelectMultipleProviderInternal(_a) {\n    var initialProps = _a.initialProps, children = _a.children;\n    var selected = initialProps.selected, min = initialProps.min, max = initialProps.max;\n    var onDayClick = function(day, activeModifiers, e) {\n        var _a, _b;\n        (_a = initialProps.onDayClick) === null || _a === void 0 ? void 0 : _a.call(initialProps, day, activeModifiers, e);\n        var isMinSelected = Boolean(activeModifiers.selected && min && (selected === null || selected === void 0 ? void 0 : selected.length) === min);\n        if (isMinSelected) {\n            return;\n        }\n        var isMaxSelected = Boolean(!activeModifiers.selected && max && (selected === null || selected === void 0 ? void 0 : selected.length) === max);\n        if (isMaxSelected) {\n            return;\n        }\n        var selectedDays = selected ? __spreadArray([], selected, true) : [];\n        if (activeModifiers.selected) {\n            var index = selectedDays.findIndex(function(selectedDay) {\n                return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(day, selectedDay);\n            });\n            selectedDays.splice(index, 1);\n        } else {\n            selectedDays.push(day);\n        }\n        (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, selectedDays, day, activeModifiers, e);\n    };\n    var modifiers = {\n        disabled: []\n    };\n    if (selected) {\n        modifiers.disabled.push(function(day) {\n            var isMaxSelected = max && selected.length > max - 1;\n            var isSelected = selected.some(function(selectedDay) {\n                return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(selectedDay, day);\n            });\n            return Boolean(isMaxSelected && !isSelected);\n        });\n    }\n    var contextValue = {\n        selected: selected,\n        onDayClick: onDayClick,\n        modifiers: modifiers\n    };\n    return jsxRuntimeExports.jsx(SelectMultipleContext.Provider, __assign({\n        value: contextValue\n    }, {\n        children: children\n    }));\n}\n/**\n * Hook to access the {@link SelectMultipleContextValue}.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useSelectMultiple() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SelectMultipleContext);\n    if (!context) {\n        throw new Error(\"useSelectMultiple must be used within a SelectMultipleProvider\");\n    }\n    return context;\n}\n/**\n * Add a day to an existing range.\n *\n * The returned range takes in account the `undefined` values and if the added\n * day is already present in the range.\n */ function addToRange(day, range) {\n    var _a = range || {}, from = _a.from, to = _a.to;\n    if (from && to) {\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(to, day) && (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(from, day)) {\n            return undefined;\n        }\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(to, day)) {\n            return {\n                from: to,\n                to: undefined\n            };\n        }\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(from, day)) {\n            return undefined;\n        }\n        if ((0,date_fns_isAfter__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(from, day)) {\n            return {\n                from: day,\n                to: to\n            };\n        }\n        return {\n            from: from,\n            to: day\n        };\n    }\n    if (to) {\n        if ((0,date_fns_isAfter__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(day, to)) {\n            return {\n                from: to,\n                to: day\n            };\n        }\n        return {\n            from: day,\n            to: to\n        };\n    }\n    if (from) {\n        if ((0,date_fns_isBefore__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(day, from)) {\n            return {\n                from: day,\n                to: from\n            };\n        }\n        return {\n            from: from,\n            to: day\n        };\n    }\n    return {\n        from: day,\n        to: undefined\n    };\n}\n/**\n * The SelectRange context shares details about the selected days when in\n * range selection mode.\n *\n * Access this context from the {@link useSelectRange} hook.\n */ var SelectRangeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provides the values for the {@link SelectRangeProvider}. */ function SelectRangeProvider(props) {\n    if (!isDayPickerRange(props.initialProps)) {\n        var emptyContextValue = {\n            selected: undefined,\n            modifiers: {\n                range_start: [],\n                range_end: [],\n                range_middle: [],\n                disabled: []\n            }\n        };\n        return jsxRuntimeExports.jsx(SelectRangeContext.Provider, __assign({\n            value: emptyContextValue\n        }, {\n            children: props.children\n        }));\n    }\n    return jsxRuntimeExports.jsx(SelectRangeProviderInternal, {\n        initialProps: props.initialProps,\n        children: props.children\n    });\n}\nfunction SelectRangeProviderInternal(_a) {\n    var initialProps = _a.initialProps, children = _a.children;\n    var selected = initialProps.selected;\n    var _b = selected || {}, selectedFrom = _b.from, selectedTo = _b.to;\n    var min = initialProps.min;\n    var max = initialProps.max;\n    var onDayClick = function(day, activeModifiers, e) {\n        var _a, _b;\n        (_a = initialProps.onDayClick) === null || _a === void 0 ? void 0 : _a.call(initialProps, day, activeModifiers, e);\n        var newRange = addToRange(day, selected);\n        (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, newRange, day, activeModifiers, e);\n    };\n    var modifiers = {\n        range_start: [],\n        range_end: [],\n        range_middle: [],\n        disabled: []\n    };\n    if (selectedFrom) {\n        modifiers.range_start = [\n            selectedFrom\n        ];\n        if (!selectedTo) {\n            modifiers.range_end = [\n                selectedFrom\n            ];\n        } else {\n            modifiers.range_end = [\n                selectedTo\n            ];\n            if (!(0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(selectedFrom, selectedTo)) {\n                modifiers.range_middle = [\n                    {\n                        after: selectedFrom,\n                        before: selectedTo\n                    }\n                ];\n            }\n        }\n    } else if (selectedTo) {\n        modifiers.range_start = [\n            selectedTo\n        ];\n        modifiers.range_end = [\n            selectedTo\n        ];\n    }\n    if (min) {\n        if (selectedFrom && !selectedTo) {\n            modifiers.disabled.push({\n                after: (0,date_fns_subDays__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(selectedFrom, min - 1),\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedFrom, min - 1)\n            });\n        }\n        if (selectedFrom && selectedTo) {\n            modifiers.disabled.push({\n                after: selectedFrom,\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedFrom, min - 1)\n            });\n        }\n        if (!selectedFrom && selectedTo) {\n            modifiers.disabled.push({\n                after: (0,date_fns_subDays__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(selectedTo, min - 1),\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedTo, min - 1)\n            });\n        }\n    }\n    if (max) {\n        if (selectedFrom && !selectedTo) {\n            modifiers.disabled.push({\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedFrom, -max + 1)\n            });\n            modifiers.disabled.push({\n                after: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedFrom, max - 1)\n            });\n        }\n        if (selectedFrom && selectedTo) {\n            var selectedCount = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(selectedTo, selectedFrom) + 1;\n            var offset = max - selectedCount;\n            modifiers.disabled.push({\n                before: (0,date_fns_subDays__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(selectedFrom, offset)\n            });\n            modifiers.disabled.push({\n                after: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedTo, offset)\n            });\n        }\n        if (!selectedFrom && selectedTo) {\n            modifiers.disabled.push({\n                before: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedTo, -max + 1)\n            });\n            modifiers.disabled.push({\n                after: (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(selectedTo, max - 1)\n            });\n        }\n    }\n    return jsxRuntimeExports.jsx(SelectRangeContext.Provider, __assign({\n        value: {\n            selected: selected,\n            onDayClick: onDayClick,\n            modifiers: modifiers\n        }\n    }, {\n        children: children\n    }));\n}\n/**\n * Hook to access the {@link SelectRangeContextValue}.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useSelectRange() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SelectRangeContext);\n    if (!context) {\n        throw new Error(\"useSelectRange must be used within a SelectRangeProvider\");\n    }\n    return context;\n}\n/** Normalize to array a matcher input. */ function matcherToArray(matcher) {\n    if (Array.isArray(matcher)) {\n        return __spreadArray([], matcher, true);\n    } else if (matcher !== undefined) {\n        return [\n            matcher\n        ];\n    } else {\n        return [];\n    }\n}\n/** Create CustomModifiers from dayModifiers */ function getCustomModifiers(dayModifiers) {\n    var customModifiers = {};\n    Object.entries(dayModifiers).forEach(function(_a) {\n        var modifier = _a[0], matcher = _a[1];\n        customModifiers[modifier] = matcherToArray(matcher);\n    });\n    return customModifiers;\n}\n/** The name of the modifiers that are used internally by DayPicker. */ var InternalModifier;\n(function(InternalModifier) {\n    InternalModifier[\"Outside\"] = \"outside\";\n    /** Name of the modifier applied to the disabled days, using the `disabled` prop. */ InternalModifier[\"Disabled\"] = \"disabled\";\n    /** Name of the modifier applied to the selected days using the `selected` prop). */ InternalModifier[\"Selected\"] = \"selected\";\n    /** Name of the modifier applied to the hidden days using the `hidden` prop). */ InternalModifier[\"Hidden\"] = \"hidden\";\n    /** Name of the modifier applied to the day specified using the `today` prop). */ InternalModifier[\"Today\"] = \"today\";\n    /** The modifier applied to the day starting a selected range, when in range selection mode.  */ InternalModifier[\"RangeStart\"] = \"range_start\";\n    /** The modifier applied to the day ending a selected range, when in range selection mode.  */ InternalModifier[\"RangeEnd\"] = \"range_end\";\n    /** The modifier applied to the days between the start and the end of a selected range, when in range selection mode.  */ InternalModifier[\"RangeMiddle\"] = \"range_middle\";\n})(InternalModifier || (InternalModifier = {}));\nvar Selected = InternalModifier.Selected, Disabled = InternalModifier.Disabled, Hidden = InternalModifier.Hidden, Today = InternalModifier.Today, RangeEnd = InternalModifier.RangeEnd, RangeMiddle = InternalModifier.RangeMiddle, RangeStart = InternalModifier.RangeStart, Outside = InternalModifier.Outside;\n/** Return the {@link InternalModifiers} from the DayPicker and select contexts. */ function getInternalModifiers(dayPicker, selectMultiple, selectRange) {\n    var _a;\n    var internalModifiers = (_a = {}, _a[Selected] = matcherToArray(dayPicker.selected), _a[Disabled] = matcherToArray(dayPicker.disabled), _a[Hidden] = matcherToArray(dayPicker.hidden), _a[Today] = [\n        dayPicker.today\n    ], _a[RangeEnd] = [], _a[RangeMiddle] = [], _a[RangeStart] = [], _a[Outside] = [], _a);\n    if (dayPicker.fromDate) {\n        internalModifiers[Disabled].push({\n            before: dayPicker.fromDate\n        });\n    }\n    if (dayPicker.toDate) {\n        internalModifiers[Disabled].push({\n            after: dayPicker.toDate\n        });\n    }\n    if (isDayPickerMultiple(dayPicker)) {\n        internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectMultiple.modifiers[Disabled]);\n    } else if (isDayPickerRange(dayPicker)) {\n        internalModifiers[Disabled] = internalModifiers[Disabled].concat(selectRange.modifiers[Disabled]);\n        internalModifiers[RangeStart] = selectRange.modifiers[RangeStart];\n        internalModifiers[RangeMiddle] = selectRange.modifiers[RangeMiddle];\n        internalModifiers[RangeEnd] = selectRange.modifiers[RangeEnd];\n    }\n    return internalModifiers;\n}\n/** The Modifiers context store the modifiers used in DayPicker. To access the value of this context, use {@link useModifiers}. */ var ModifiersContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provide the value for the {@link ModifiersContext}. */ function ModifiersProvider(props) {\n    var dayPicker = useDayPicker();\n    var selectMultiple = useSelectMultiple();\n    var selectRange = useSelectRange();\n    var internalModifiers = getInternalModifiers(dayPicker, selectMultiple, selectRange);\n    var customModifiers = getCustomModifiers(dayPicker.modifiers);\n    var modifiers = __assign(__assign({}, internalModifiers), customModifiers);\n    return jsxRuntimeExports.jsx(ModifiersContext.Provider, __assign({\n        value: modifiers\n    }, {\n        children: props.children\n    }));\n}\n/**\n * Return the modifiers used by DayPicker.\n *\n * This hook is meant to be used inside internal or custom components.\n * Requires to be wrapped into {@link ModifiersProvider}.\n *\n */ function useModifiers() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ModifiersContext);\n    if (!context) {\n        throw new Error(\"useModifiers must be used within a ModifiersProvider\");\n    }\n    return context;\n}\n/** Returns true if `matcher` is of type {@link DateInterval}. */ function isDateInterval(matcher) {\n    return Boolean(matcher && typeof matcher === \"object\" && \"before\" in matcher && \"after\" in matcher);\n}\n/** Returns true if `value` is a {@link DateRange} type. */ function isDateRange(value) {\n    return Boolean(value && typeof value === \"object\" && \"from\" in value);\n}\n/** Returns true if `value` is of type {@link DateAfter}. */ function isDateAfterType(value) {\n    return Boolean(value && typeof value === \"object\" && \"after\" in value);\n}\n/** Returns true if `value` is of type {@link DateBefore}. */ function isDateBeforeType(value) {\n    return Boolean(value && typeof value === \"object\" && \"before\" in value);\n}\n/** Returns true if `value` is a {@link DayOfWeek} type. */ function isDayOfWeekType(value) {\n    return Boolean(value && typeof value === \"object\" && \"dayOfWeek\" in value);\n}\n/** Return `true` whether `date` is inside `range`. */ function isDateInRange(date, range) {\n    var _a;\n    var from = range.from, to = range.to;\n    if (from && to) {\n        var isRangeInverted = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(to, from) < 0;\n        if (isRangeInverted) {\n            _a = [\n                to,\n                from\n            ], from = _a[0], to = _a[1];\n        }\n        var isInRange = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(date, from) >= 0 && (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(to, date) >= 0;\n        return isInRange;\n    }\n    if (to) {\n        return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(to, date);\n    }\n    if (from) {\n        return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(from, date);\n    }\n    return false;\n}\n/** Returns true if `value` is a Date type. */ function isDateType(value) {\n    return (0,date_fns_isDate__WEBPACK_IMPORTED_MODULE_21__[\"default\"])(value);\n}\n/** Returns true if `value` is an array of valid dates. */ function isArrayOfDates(value) {\n    return Array.isArray(value) && value.every(date_fns_isDate__WEBPACK_IMPORTED_MODULE_21__[\"default\"]);\n}\n/**\n * Returns whether a day matches against at least one of the given Matchers.\n *\n * ```\n * const day = new Date(2022, 5, 19);\n * const matcher1: DateRange = {\n *    from: new Date(2021, 12, 21),\n *    to: new Date(2021, 12, 30)\n * }\n * const matcher2: DateRange = {\n *    from: new Date(2022, 5, 1),\n *    to: new Date(2022, 5, 23)\n * }\n *\n * const isMatch(day, [matcher1, matcher2]); // true, since day is in the matcher1 range.\n * ```\n * */ function isMatch(day, matchers) {\n    return matchers.some(function(matcher) {\n        if (typeof matcher === \"boolean\") {\n            return matcher;\n        }\n        if (isDateType(matcher)) {\n            return (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(day, matcher);\n        }\n        if (isArrayOfDates(matcher)) {\n            return matcher.includes(day);\n        }\n        if (isDateRange(matcher)) {\n            return isDateInRange(day, matcher);\n        }\n        if (isDayOfWeekType(matcher)) {\n            return matcher.dayOfWeek.includes(day.getDay());\n        }\n        if (isDateInterval(matcher)) {\n            var diffBefore = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(matcher.before, day);\n            var diffAfter = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(matcher.after, day);\n            var isDayBefore = diffBefore > 0;\n            var isDayAfter = diffAfter < 0;\n            var isClosedInterval = (0,date_fns_isAfter__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(matcher.before, matcher.after);\n            if (isClosedInterval) {\n                return isDayAfter && isDayBefore;\n            } else {\n                return isDayBefore || isDayAfter;\n            }\n        }\n        if (isDateAfterType(matcher)) {\n            return (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(day, matcher.after) > 0;\n        }\n        if (isDateBeforeType(matcher)) {\n            return (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(matcher.before, day) > 0;\n        }\n        if (typeof matcher === \"function\") {\n            return matcher(day);\n        }\n        return false;\n    });\n}\n/** Return the active modifiers for the given day. */ function getActiveModifiers(day, /** The modifiers to match for the given date. */ modifiers, /** The month where the day is displayed, to add the \"outside\" modifiers.  */ displayMonth) {\n    var matchedModifiers = Object.keys(modifiers).reduce(function(result, key) {\n        var modifier = modifiers[key];\n        if (isMatch(day, modifier)) {\n            result.push(key);\n        }\n        return result;\n    }, []);\n    var activeModifiers = {};\n    matchedModifiers.forEach(function(modifier) {\n        return activeModifiers[modifier] = true;\n    });\n    if (displayMonth && !(0,date_fns_isSameMonth__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(day, displayMonth)) {\n        activeModifiers.outside = true;\n    }\n    return activeModifiers;\n}\n/**\n * Returns the day that should be the target of the focus when DayPicker is\n * rendered the first time.\n *\n * TODO: this function doesn't consider if the day is outside the month. We\n * implemented this check in `useDayRender` but it should probably go here. See\n * https://github.com/gpbl/react-day-picker/pull/1576\n */ function getInitialFocusTarget(displayMonths, modifiers) {\n    var firstDayInMonth = (0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(displayMonths[0]);\n    var lastDayInMonth = (0,date_fns_endOfMonth__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(displayMonths[displayMonths.length - 1]);\n    // TODO: cleanup code\n    var firstFocusableDay;\n    var today;\n    var date = firstDayInMonth;\n    while(date <= lastDayInMonth){\n        var activeModifiers = getActiveModifiers(date, modifiers);\n        var isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;\n        if (!isFocusable) {\n            date = (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(date, 1);\n            continue;\n        }\n        if (activeModifiers.selected) {\n            return date;\n        }\n        if (activeModifiers.today && !today) {\n            today = date;\n        }\n        if (!firstFocusableDay) {\n            firstFocusableDay = date;\n        }\n        date = (0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(date, 1);\n    }\n    if (today) {\n        return today;\n    } else {\n        return firstFocusableDay;\n    }\n}\nvar MAX_RETRY = 365;\n/** Return the next date to be focused. */ function getNextFocus(focusedDay, options) {\n    var moveBy = options.moveBy, direction = options.direction, context = options.context, modifiers = options.modifiers, _a = options.retry, retry = _a === void 0 ? {\n        count: 0,\n        lastFocused: focusedDay\n    } : _a;\n    var weekStartsOn = context.weekStartsOn, fromDate = context.fromDate, toDate = context.toDate, locale = context.locale;\n    var moveFns = {\n        day: date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\n        week: date_fns_addWeeks__WEBPACK_IMPORTED_MODULE_22__[\"default\"],\n        month: date_fns_addMonths__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        year: date_fns_addYears__WEBPACK_IMPORTED_MODULE_23__[\"default\"],\n        startOfWeek: function(date) {\n            return context.ISOWeek ? (0,date_fns_startOfISOWeek__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(date) : (0,date_fns_startOfWeek__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(date, {\n                locale: locale,\n                weekStartsOn: weekStartsOn\n            });\n        },\n        endOfWeek: function(date) {\n            return context.ISOWeek ? (0,date_fns_endOfISOWeek__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(date) : (0,date_fns_endOfWeek__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(date, {\n                locale: locale,\n                weekStartsOn: weekStartsOn\n            });\n        }\n    };\n    var newFocusedDay = moveFns[moveBy](focusedDay, direction === \"after\" ? 1 : -1);\n    if (direction === \"before\" && fromDate) {\n        newFocusedDay = (0,date_fns_max__WEBPACK_IMPORTED_MODULE_26__[\"default\"])([\n            fromDate,\n            newFocusedDay\n        ]);\n    } else if (direction === \"after\" && toDate) {\n        newFocusedDay = (0,date_fns_min__WEBPACK_IMPORTED_MODULE_27__[\"default\"])([\n            toDate,\n            newFocusedDay\n        ]);\n    }\n    var isFocusable = true;\n    if (modifiers) {\n        var activeModifiers = getActiveModifiers(newFocusedDay, modifiers);\n        isFocusable = !activeModifiers.disabled && !activeModifiers.hidden;\n    }\n    if (isFocusable) {\n        return newFocusedDay;\n    } else {\n        if (retry.count > MAX_RETRY) {\n            return retry.lastFocused;\n        }\n        return getNextFocus(newFocusedDay, {\n            moveBy: moveBy,\n            direction: direction,\n            context: context,\n            modifiers: modifiers,\n            retry: __assign(__assign({}, retry), {\n                count: retry.count + 1\n            })\n        });\n    }\n}\n/**\n * The Focus context shares details about the focused day for the keyboard\n *\n * Access this context from the {@link useFocusContext} hook.\n */ var FocusContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** The provider for the {@link FocusContext}. */ function FocusProvider(props) {\n    var navigation = useNavigation();\n    var modifiers = useModifiers();\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), focusedDay = _a[0], setFocusedDay = _a[1];\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), lastFocused = _b[0], setLastFocused = _b[1];\n    var initialFocusTarget = getInitialFocusTarget(navigation.displayMonths, modifiers);\n    // TODO: cleanup and test obscure code below\n    var focusTarget = (focusedDay !== null && focusedDay !== void 0 ? focusedDay : lastFocused && navigation.isDateDisplayed(lastFocused)) ? lastFocused : initialFocusTarget;\n    var blur = function() {\n        setLastFocused(focusedDay);\n        setFocusedDay(undefined);\n    };\n    var focus = function(date) {\n        setFocusedDay(date);\n    };\n    var context = useDayPicker();\n    var moveFocus = function(moveBy, direction) {\n        if (!focusedDay) return;\n        var nextFocused = getNextFocus(focusedDay, {\n            moveBy: moveBy,\n            direction: direction,\n            context: context,\n            modifiers: modifiers\n        });\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(focusedDay, nextFocused)) return undefined;\n        navigation.goToDate(nextFocused, focusedDay);\n        focus(nextFocused);\n    };\n    var value = {\n        focusedDay: focusedDay,\n        focusTarget: focusTarget,\n        blur: blur,\n        focus: focus,\n        focusDayAfter: function() {\n            return moveFocus(\"day\", \"after\");\n        },\n        focusDayBefore: function() {\n            return moveFocus(\"day\", \"before\");\n        },\n        focusWeekAfter: function() {\n            return moveFocus(\"week\", \"after\");\n        },\n        focusWeekBefore: function() {\n            return moveFocus(\"week\", \"before\");\n        },\n        focusMonthBefore: function() {\n            return moveFocus(\"month\", \"before\");\n        },\n        focusMonthAfter: function() {\n            return moveFocus(\"month\", \"after\");\n        },\n        focusYearBefore: function() {\n            return moveFocus(\"year\", \"before\");\n        },\n        focusYearAfter: function() {\n            return moveFocus(\"year\", \"after\");\n        },\n        focusStartOfWeek: function() {\n            return moveFocus(\"startOfWeek\", \"before\");\n        },\n        focusEndOfWeek: function() {\n            return moveFocus(\"endOfWeek\", \"after\");\n        }\n    };\n    return jsxRuntimeExports.jsx(FocusContext.Provider, __assign({\n        value: value\n    }, {\n        children: props.children\n    }));\n}\n/**\n * Hook to access the {@link FocusContextValue}. Use this hook to handle the\n * focus state of the elements.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useFocusContext() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FocusContext);\n    if (!context) {\n        throw new Error(\"useFocusContext must be used within a FocusProvider\");\n    }\n    return context;\n}\n/**\n * Return the active modifiers for the specified day.\n *\n * This hook is meant to be used inside internal or custom components.\n *\n * @param day\n * @param displayMonth\n */ function useActiveModifiers(day, /**\n * The month where the date is displayed. If not the same as `date`, the day\n * is an \"outside day\".\n */ displayMonth) {\n    var modifiers = useModifiers();\n    var activeModifiers = getActiveModifiers(day, modifiers, displayMonth);\n    return activeModifiers;\n}\n/**\n * The SelectSingle context shares details about the selected days when in\n * single selection mode.\n *\n * Access this context from the {@link useSelectSingle} hook.\n */ var SelectSingleContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\n/** Provides the values for the {@link SelectSingleProvider}. */ function SelectSingleProvider(props) {\n    if (!isDayPickerSingle(props.initialProps)) {\n        var emptyContextValue = {\n            selected: undefined\n        };\n        return jsxRuntimeExports.jsx(SelectSingleContext.Provider, __assign({\n            value: emptyContextValue\n        }, {\n            children: props.children\n        }));\n    }\n    return jsxRuntimeExports.jsx(SelectSingleProviderInternal, {\n        initialProps: props.initialProps,\n        children: props.children\n    });\n}\nfunction SelectSingleProviderInternal(_a) {\n    var initialProps = _a.initialProps, children = _a.children;\n    var onDayClick = function(day, activeModifiers, e) {\n        var _a, _b, _c;\n        (_a = initialProps.onDayClick) === null || _a === void 0 ? void 0 : _a.call(initialProps, day, activeModifiers, e);\n        if (activeModifiers.selected && !initialProps.required) {\n            (_b = initialProps.onSelect) === null || _b === void 0 ? void 0 : _b.call(initialProps, undefined, day, activeModifiers, e);\n            return;\n        }\n        (_c = initialProps.onSelect) === null || _c === void 0 ? void 0 : _c.call(initialProps, day, day, activeModifiers, e);\n    };\n    var contextValue = {\n        selected: initialProps.selected,\n        onDayClick: onDayClick\n    };\n    return jsxRuntimeExports.jsx(SelectSingleContext.Provider, __assign({\n        value: contextValue\n    }, {\n        children: children\n    }));\n}\n/**\n * Hook to access the {@link SelectSingleContextValue}.\n *\n * This hook is meant to be used inside internal or custom components.\n */ function useSelectSingle() {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SelectSingleContext);\n    if (!context) {\n        throw new Error(\"useSelectSingle must be used within a SelectSingleProvider\");\n    }\n    return context;\n}\n/**\n * This hook returns details about the content to render in the day cell.\n *\n *\n * When a day cell is rendered in the table, DayPicker can either:\n *\n * - render nothing: when the day is outside the month or has matched the\n *   \"hidden\" modifier.\n * - render a button when `onDayClick` or a selection mode is set.\n * - render a non-interactive element: when no selection mode is set, the day\n *   cell shouldn’t respond to any interaction. DayPicker should render a `div`\n *   or a `span`.\n *\n * ### Usage\n *\n * Use this hook to customize the behavior of the {@link Day} component. Create a\n * new `Day` component using this hook and pass it to the `components` prop.\n * The source of {@link Day} can be a good starting point.\n *\n */ function useDayEventHandlers(date, activeModifiers) {\n    var dayPicker = useDayPicker();\n    var single = useSelectSingle();\n    var multiple = useSelectMultiple();\n    var range = useSelectRange();\n    var _a = useFocusContext(), focusDayAfter = _a.focusDayAfter, focusDayBefore = _a.focusDayBefore, focusWeekAfter = _a.focusWeekAfter, focusWeekBefore = _a.focusWeekBefore, blur = _a.blur, focus = _a.focus, focusMonthBefore = _a.focusMonthBefore, focusMonthAfter = _a.focusMonthAfter, focusYearBefore = _a.focusYearBefore, focusYearAfter = _a.focusYearAfter, focusStartOfWeek = _a.focusStartOfWeek, focusEndOfWeek = _a.focusEndOfWeek;\n    var onClick = function(e) {\n        var _a, _b, _c, _d;\n        if (isDayPickerSingle(dayPicker)) {\n            (_a = single.onDayClick) === null || _a === void 0 ? void 0 : _a.call(single, date, activeModifiers, e);\n        } else if (isDayPickerMultiple(dayPicker)) {\n            (_b = multiple.onDayClick) === null || _b === void 0 ? void 0 : _b.call(multiple, date, activeModifiers, e);\n        } else if (isDayPickerRange(dayPicker)) {\n            (_c = range.onDayClick) === null || _c === void 0 ? void 0 : _c.call(range, date, activeModifiers, e);\n        } else {\n            (_d = dayPicker.onDayClick) === null || _d === void 0 ? void 0 : _d.call(dayPicker, date, activeModifiers, e);\n        }\n    };\n    var onFocus = function(e) {\n        var _a;\n        focus(date);\n        (_a = dayPicker.onDayFocus) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onBlur = function(e) {\n        var _a;\n        blur();\n        (_a = dayPicker.onDayBlur) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onMouseEnter = function(e) {\n        var _a;\n        (_a = dayPicker.onDayMouseEnter) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onMouseLeave = function(e) {\n        var _a;\n        (_a = dayPicker.onDayMouseLeave) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onPointerEnter = function(e) {\n        var _a;\n        (_a = dayPicker.onDayPointerEnter) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onPointerLeave = function(e) {\n        var _a;\n        (_a = dayPicker.onDayPointerLeave) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onTouchCancel = function(e) {\n        var _a;\n        (_a = dayPicker.onDayTouchCancel) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onTouchEnd = function(e) {\n        var _a;\n        (_a = dayPicker.onDayTouchEnd) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onTouchMove = function(e) {\n        var _a;\n        (_a = dayPicker.onDayTouchMove) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onTouchStart = function(e) {\n        var _a;\n        (_a = dayPicker.onDayTouchStart) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onKeyUp = function(e) {\n        var _a;\n        (_a = dayPicker.onDayKeyUp) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var onKeyDown = function(e) {\n        var _a;\n        switch(e.key){\n            case \"ArrowLeft\":\n                e.preventDefault();\n                e.stopPropagation();\n                dayPicker.dir === \"rtl\" ? focusDayAfter() : focusDayBefore();\n                break;\n            case \"ArrowRight\":\n                e.preventDefault();\n                e.stopPropagation();\n                dayPicker.dir === \"rtl\" ? focusDayBefore() : focusDayAfter();\n                break;\n            case \"ArrowDown\":\n                e.preventDefault();\n                e.stopPropagation();\n                focusWeekAfter();\n                break;\n            case \"ArrowUp\":\n                e.preventDefault();\n                e.stopPropagation();\n                focusWeekBefore();\n                break;\n            case \"PageUp\":\n                e.preventDefault();\n                e.stopPropagation();\n                e.shiftKey ? focusYearBefore() : focusMonthBefore();\n                break;\n            case \"PageDown\":\n                e.preventDefault();\n                e.stopPropagation();\n                e.shiftKey ? focusYearAfter() : focusMonthAfter();\n                break;\n            case \"Home\":\n                e.preventDefault();\n                e.stopPropagation();\n                focusStartOfWeek();\n                break;\n            case \"End\":\n                e.preventDefault();\n                e.stopPropagation();\n                focusEndOfWeek();\n                break;\n        }\n        (_a = dayPicker.onDayKeyDown) === null || _a === void 0 ? void 0 : _a.call(dayPicker, date, activeModifiers, e);\n    };\n    var eventHandlers = {\n        onClick: onClick,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        onKeyDown: onKeyDown,\n        onKeyUp: onKeyUp,\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave,\n        onPointerEnter: onPointerEnter,\n        onPointerLeave: onPointerLeave,\n        onTouchCancel: onTouchCancel,\n        onTouchEnd: onTouchEnd,\n        onTouchMove: onTouchMove,\n        onTouchStart: onTouchStart\n    };\n    return eventHandlers;\n}\n/**\n * Return the current selected days when DayPicker is in selection mode. Days\n * selected by the custom selection mode are not returned.\n *\n * This hook is meant to be used inside internal or custom components.\n *\n */ function useSelectedDays() {\n    var dayPicker = useDayPicker();\n    var single = useSelectSingle();\n    var multiple = useSelectMultiple();\n    var range = useSelectRange();\n    var selectedDays = isDayPickerSingle(dayPicker) ? single.selected : isDayPickerMultiple(dayPicker) ? multiple.selected : isDayPickerRange(dayPicker) ? range.selected : undefined;\n    return selectedDays;\n}\nfunction isInternalModifier(modifier) {\n    return Object.values(InternalModifier).includes(modifier);\n}\n/**\n * Return the class names for the Day element, according to the given active\n * modifiers.\n *\n * Custom class names are set via `modifiersClassNames` or `classNames`,\n * where the first have the precedence.\n */ function getDayClassNames(dayPicker, activeModifiers) {\n    var classNames = [\n        dayPicker.classNames.day\n    ];\n    Object.keys(activeModifiers).forEach(function(modifier) {\n        var customClassName = dayPicker.modifiersClassNames[modifier];\n        if (customClassName) {\n            classNames.push(customClassName);\n        } else if (isInternalModifier(modifier)) {\n            var internalClassName = dayPicker.classNames[\"day_\".concat(modifier)];\n            if (internalClassName) {\n                classNames.push(internalClassName);\n            }\n        }\n    });\n    return classNames;\n}\n/** Return the style for the Day element, according to the given active modifiers. */ function getDayStyle(dayPicker, activeModifiers) {\n    var style = __assign({}, dayPicker.styles.day);\n    Object.keys(activeModifiers).forEach(function(modifier) {\n        var _a;\n        style = __assign(__assign({}, style), (_a = dayPicker.modifiersStyles) === null || _a === void 0 ? void 0 : _a[modifier]);\n    });\n    return style;\n}\n/**\n * Return props and data used to render the {@link Day} component.\n *\n * Use this hook when creating a component to replace the built-in `Day`\n * component.\n */ function useDayRender(/** The date to render. */ day, /** The month where the date is displayed (if not the same as `date`, it means it is an \"outside\" day). */ displayMonth, /** A ref to the button element that will be target of focus when rendered (if required). */ buttonRef) {\n    var _a;\n    var _b, _c;\n    var dayPicker = useDayPicker();\n    var focusContext = useFocusContext();\n    var activeModifiers = useActiveModifiers(day, displayMonth);\n    var eventHandlers = useDayEventHandlers(day, activeModifiers);\n    var selectedDays = useSelectedDays();\n    var isButton = Boolean(dayPicker.onDayClick || dayPicker.mode !== \"default\");\n    // Focus the button if the day is focused according to the focus context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        var _a;\n        if (activeModifiers.outside) return;\n        if (!focusContext.focusedDay) return;\n        if (!isButton) return;\n        if ((0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(focusContext.focusedDay, day)) {\n            (_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n    }, [\n        focusContext.focusedDay,\n        day,\n        buttonRef,\n        isButton,\n        activeModifiers.outside\n    ]);\n    var className = getDayClassNames(dayPicker, activeModifiers).join(\" \");\n    var style = getDayStyle(dayPicker, activeModifiers);\n    var isHidden = Boolean(activeModifiers.outside && !dayPicker.showOutsideDays || activeModifiers.hidden);\n    var DayContentComponent = (_c = (_b = dayPicker.components) === null || _b === void 0 ? void 0 : _b.DayContent) !== null && _c !== void 0 ? _c : DayContent;\n    var children = jsxRuntimeExports.jsx(DayContentComponent, {\n        date: day,\n        displayMonth: displayMonth,\n        activeModifiers: activeModifiers\n    });\n    var divProps = {\n        style: style,\n        className: className,\n        children: children,\n        role: \"gridcell\"\n    };\n    var isFocusTarget = focusContext.focusTarget && (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(focusContext.focusTarget, day) && !activeModifiers.outside;\n    var isFocused = focusContext.focusedDay && (0,date_fns_isSameDay__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(focusContext.focusedDay, day);\n    var buttonProps = __assign(__assign(__assign({}, divProps), (_a = {\n        disabled: activeModifiers.disabled,\n        role: \"gridcell\"\n    }, _a[\"aria-selected\"] = activeModifiers.selected, _a.tabIndex = isFocused || isFocusTarget ? 0 : -1, _a)), eventHandlers);\n    var dayRender = {\n        isButton: isButton,\n        isHidden: isHidden,\n        activeModifiers: activeModifiers,\n        selectedDays: selectedDays,\n        buttonProps: buttonProps,\n        divProps: divProps\n    };\n    return dayRender;\n}\n/**\n * The content of a day cell – as a button or span element according to its\n * modifiers.\n */ function Day(props) {\n    var buttonRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var dayRender = useDayRender(props.date, props.displayMonth, buttonRef);\n    if (dayRender.isHidden) {\n        return jsxRuntimeExports.jsx(\"div\", {\n            role: \"gridcell\"\n        });\n    }\n    if (!dayRender.isButton) {\n        return jsxRuntimeExports.jsx(\"div\", __assign({}, dayRender.divProps));\n    }\n    return jsxRuntimeExports.jsx(Button, __assign({\n        name: \"day\",\n        ref: buttonRef\n    }, dayRender.buttonProps));\n}\n/**\n * Render the week number element. If `onWeekNumberClick` is passed to DayPicker, it\n * renders a button, otherwise a span element.\n */ function WeekNumber(props) {\n    var weekNumber = props.number, dates = props.dates;\n    var _a = useDayPicker(), onWeekNumberClick = _a.onWeekNumberClick, styles = _a.styles, classNames = _a.classNames, locale = _a.locale, labelWeekNumber = _a.labels.labelWeekNumber, formatWeekNumber = _a.formatters.formatWeekNumber;\n    var content = formatWeekNumber(Number(weekNumber), {\n        locale: locale\n    });\n    if (!onWeekNumberClick) {\n        return jsxRuntimeExports.jsx(\"span\", __assign({\n            className: classNames.weeknumber,\n            style: styles.weeknumber\n        }, {\n            children: content\n        }));\n    }\n    var label = labelWeekNumber(Number(weekNumber), {\n        locale: locale\n    });\n    var handleClick = function(e) {\n        onWeekNumberClick(weekNumber, dates, e);\n    };\n    return jsxRuntimeExports.jsx(Button, __assign({\n        name: \"week-number\",\n        \"aria-label\": label,\n        className: classNames.weeknumber,\n        style: styles.weeknumber,\n        onClick: handleClick\n    }, {\n        children: content\n    }));\n}\n/** Render a row in the calendar, with the days and the week number. */ function Row(props) {\n    var _a, _b;\n    var _c = useDayPicker(), styles = _c.styles, classNames = _c.classNames, showWeekNumber = _c.showWeekNumber, components = _c.components;\n    var DayComponent = (_a = components === null || components === void 0 ? void 0 : components.Day) !== null && _a !== void 0 ? _a : Day;\n    var WeeknumberComponent = (_b = components === null || components === void 0 ? void 0 : components.WeekNumber) !== null && _b !== void 0 ? _b : WeekNumber;\n    var weekNumberCell;\n    if (showWeekNumber) {\n        weekNumberCell = jsxRuntimeExports.jsx(\"td\", __assign({\n            className: classNames.cell,\n            style: styles.cell\n        }, {\n            children: jsxRuntimeExports.jsx(WeeknumberComponent, {\n                number: props.weekNumber,\n                dates: props.dates\n            })\n        }));\n    }\n    return jsxRuntimeExports.jsxs(\"tr\", __assign({\n        className: classNames.row,\n        style: styles.row\n    }, {\n        children: [\n            weekNumberCell,\n            props.dates.map(function(date) {\n                return jsxRuntimeExports.jsx(\"td\", __assign({\n                    className: classNames.cell,\n                    style: styles.cell,\n                    role: \"presentation\"\n                }, {\n                    children: jsxRuntimeExports.jsx(DayComponent, {\n                        displayMonth: props.displayMonth,\n                        date: date\n                    })\n                }), (0,date_fns_getUnixTime__WEBPACK_IMPORTED_MODULE_28__[\"default\"])(date));\n            })\n        ]\n    }));\n}\n/** Return the weeks between two dates.  */ function daysToMonthWeeks(fromDate, toDate, options) {\n    var toWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? (0,date_fns_endOfISOWeek__WEBPACK_IMPORTED_MODULE_24__[\"default\"])(toDate) : (0,date_fns_endOfWeek__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(toDate, options);\n    var fromWeek = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? (0,date_fns_startOfISOWeek__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(fromDate) : (0,date_fns_startOfWeek__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(fromDate, options);\n    var nOfDays = (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(toWeek, fromWeek);\n    var days = [];\n    for(var i = 0; i <= nOfDays; i++){\n        days.push((0,date_fns_addDays__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(fromWeek, i));\n    }\n    var weeksInMonth = days.reduce(function(result, date) {\n        var weekNumber = (options === null || options === void 0 ? void 0 : options.ISOWeek) ? (0,date_fns_getISOWeek__WEBPACK_IMPORTED_MODULE_29__[\"default\"])(date) : (0,date_fns_getWeek__WEBPACK_IMPORTED_MODULE_30__[\"default\"])(date, options);\n        var existingWeek = result.find(function(value) {\n            return value.weekNumber === weekNumber;\n        });\n        if (existingWeek) {\n            existingWeek.dates.push(date);\n            return result;\n        }\n        result.push({\n            weekNumber: weekNumber,\n            dates: [\n                date\n            ]\n        });\n        return result;\n    }, []);\n    return weeksInMonth;\n}\n/**\n * Return the weeks belonging to the given month, adding the \"outside days\" to\n * the first and last week.\n */ function getMonthWeeks(month, options) {\n    var weeksInMonth = daysToMonthWeeks((0,date_fns_startOfMonth__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(month), (0,date_fns_endOfMonth__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(month), options);\n    if (options === null || options === void 0 ? void 0 : options.useFixedWeeks) {\n        // Add extra weeks to the month, up to 6 weeks\n        var nrOfMonthWeeks = (0,date_fns_getWeeksInMonth__WEBPACK_IMPORTED_MODULE_31__[\"default\"])(month, options);\n        if (nrOfMonthWeeks < 6) {\n            var lastWeek = weeksInMonth[weeksInMonth.length - 1];\n            var lastDate = lastWeek.dates[lastWeek.dates.length - 1];\n            var toDate = (0,date_fns_addWeeks__WEBPACK_IMPORTED_MODULE_22__[\"default\"])(lastDate, 6 - nrOfMonthWeeks);\n            var extraWeeks = daysToMonthWeeks((0,date_fns_addWeeks__WEBPACK_IMPORTED_MODULE_22__[\"default\"])(lastDate, 1), toDate, options);\n            weeksInMonth.push.apply(weeksInMonth, extraWeeks);\n        }\n    }\n    return weeksInMonth;\n}\n/** Render the table with the calendar. */ function Table(props) {\n    var _a, _b, _c;\n    var _d = useDayPicker(), locale = _d.locale, classNames = _d.classNames, styles = _d.styles, hideHead = _d.hideHead, fixedWeeks = _d.fixedWeeks, components = _d.components, weekStartsOn = _d.weekStartsOn, firstWeekContainsDate = _d.firstWeekContainsDate, ISOWeek = _d.ISOWeek;\n    var weeks = getMonthWeeks(props.displayMonth, {\n        useFixedWeeks: Boolean(fixedWeeks),\n        ISOWeek: ISOWeek,\n        locale: locale,\n        weekStartsOn: weekStartsOn,\n        firstWeekContainsDate: firstWeekContainsDate\n    });\n    var HeadComponent = (_a = components === null || components === void 0 ? void 0 : components.Head) !== null && _a !== void 0 ? _a : Head;\n    var RowComponent = (_b = components === null || components === void 0 ? void 0 : components.Row) !== null && _b !== void 0 ? _b : Row;\n    var FooterComponent = (_c = components === null || components === void 0 ? void 0 : components.Footer) !== null && _c !== void 0 ? _c : Footer;\n    return jsxRuntimeExports.jsxs(\"table\", __assign({\n        id: props.id,\n        className: classNames.table,\n        style: styles.table,\n        role: \"grid\",\n        \"aria-labelledby\": props[\"aria-labelledby\"]\n    }, {\n        children: [\n            !hideHead && jsxRuntimeExports.jsx(HeadComponent, {}),\n            jsxRuntimeExports.jsx(\"tbody\", __assign({\n                className: classNames.tbody,\n                style: styles.tbody\n            }, {\n                children: weeks.map(function(week) {\n                    return jsxRuntimeExports.jsx(RowComponent, {\n                        displayMonth: props.displayMonth,\n                        dates: week.dates,\n                        weekNumber: week.weekNumber\n                    }, week.weekNumber);\n                })\n            })),\n            jsxRuntimeExports.jsx(FooterComponent, {\n                displayMonth: props.displayMonth\n            })\n        ]\n    }));\n}\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2018-present, React Training LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/ /* eslint-disable prefer-const */ /* eslint-disable @typescript-eslint/ban-ts-comment */ /*\n * Welcome to @reach/auto-id!\n * Let's see if we can make sense of why this hook exists and its\n * implementation.\n *\n * Some background:\n *   1. Accessibility APIs rely heavily on element IDs\n *   2. Requiring developers to put IDs on every element in Reach UI is both\n *      cumbersome and error-prone\n *   3. With a component model, we can generate IDs for them!\n *\n * Solution 1: Generate random IDs.\n *\n * This works great as long as you don't server render your app. When React (in\n * the client) tries to reuse the markup from the server, the IDs won't match\n * and React will then recreate the entire DOM tree.\n *\n * Solution 2: Increment an integer\n *\n * This sounds great. Since we're rendering the exact same tree on the server\n * and client, we can increment a counter and get a deterministic result between\n * client and server. Also, JS integers can go up to nine-quadrillion. I'm\n * pretty sure the tab will be closed before an app never needs\n * 10 quadrillion IDs!\n *\n * Problem solved, right?\n *\n * Ah, but there's a catch! React's concurrent rendering makes this approach\n * non-deterministic. While the client and server will end up with the same\n * elements in the end, depending on suspense boundaries (and possibly some user\n * input during the initial render) the incrementing integers won't always match\n * up.\n *\n * Solution 3: Don't use IDs at all on the server; patch after first render.\n *\n * What we've done here is solution 2 with some tricks. With this approach, the\n * ID returned is an empty string on the first render. This way the server and\n * client have the same markup no matter how wild the concurrent rendering may\n * have gotten.\n *\n * After the render, we patch up the components with an incremented ID. This\n * causes a double render on any components with `useId`. Shouldn't be a problem\n * since the components using this hook should be small, and we're only updating\n * the ID attribute on the DOM, nothing big is happening.\n *\n * It doesn't have to be an incremented number, though--we could do generate\n * random strings instead, but incrementing a number is probably the cheapest\n * thing we can do.\n *\n * Additionally, we only do this patchup on the very first client render ever.\n * Any calls to `useId` that happen dynamically in the client will be\n * populated immediately with a value. So, we only get the double render after\n * server hydration and never again, SO BACK OFF ALRIGHT?\n */ function canUseDOM() {\n    return !!( false && 0);\n}\n/**\n * React currently throws a warning when using useLayoutEffect on the server. To\n * get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect in the browser. We occasionally need useLayoutEffect to\n * ensure we don't get a render flash for certain operations, but we may also\n * need affected components to render on the server. One example is when setting\n * a component's descendants to retrieve their index values.\n *\n * Important to note that using this hook as an escape hatch will break the\n * eslint dependency warnings unless you rename the import to `useLayoutEffect`.\n * Use sparingly only when the effect won't effect the rendered HTML to avoid\n * any server/client mismatch.\n *\n * If a useLayoutEffect is needed and the result would create a mismatch, it's\n * likely that the component in question shouldn't be rendered on the server at\n * all, so a better approach would be to lazily render those in a parent\n * component after client-side hydration.\n *\n * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\n * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js\n *\n * @param effect\n * @param deps\n */ var useIsomorphicLayoutEffect = canUseDOM() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar serverHandoffComplete = false;\nvar id = 0;\nfunction genId() {\n    return \"react-day-picker-\".concat(++id);\n}\nfunction useId(providedId) {\n    // TODO: Remove error flag when updating internal deps to React 18. None of\n    // our tricks will play well with concurrent rendering anyway.\n    var _a;\n    // If this instance isn't part of the initial render, we don't have to do the\n    // double render/patch-up dance. We can just generate the ID and return it.\n    var initialId = providedId !== null && providedId !== void 0 ? providedId : serverHandoffComplete ? genId() : null;\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialId), id = _b[0], setId = _b[1];\n    useIsomorphicLayoutEffect(function() {\n        if (id === null) {\n            // Patch the ID after render. We do this in `useLayoutEffect` to avoid any\n            // rendering flicker, though it'll make the first render slower (unlikely\n            // to matter, but you're welcome to measure your app and let us know if\n            // it's a problem).\n            setId(genId());\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (serverHandoffComplete === false) {\n            // Flag all future uses of `useId` to skip the update dance. This is in\n            // `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\n            // accidentally bail out of the patch-up dance prematurely.\n            serverHandoffComplete = true;\n        }\n    }, []);\n    return (_a = providedId !== null && providedId !== void 0 ? providedId : id) !== null && _a !== void 0 ? _a : undefined;\n}\n/** Render a month. */ function Month(props) {\n    var _a;\n    var _b;\n    var dayPicker = useDayPicker();\n    var dir = dayPicker.dir, classNames = dayPicker.classNames, styles = dayPicker.styles, components = dayPicker.components;\n    var displayMonths = useNavigation().displayMonths;\n    var captionId = useId(dayPicker.id ? \"\".concat(dayPicker.id, \"-\").concat(props.displayIndex) : undefined);\n    var tableId = dayPicker.id ? \"\".concat(dayPicker.id, \"-grid-\").concat(props.displayIndex) : undefined;\n    var className = [\n        classNames.month\n    ];\n    var style = styles.month;\n    var isStart = props.displayIndex === 0;\n    var isEnd = props.displayIndex === displayMonths.length - 1;\n    var isCenter = !isStart && !isEnd;\n    if (dir === \"rtl\") {\n        _a = [\n            isStart,\n            isEnd\n        ], isEnd = _a[0], isStart = _a[1];\n    }\n    if (isStart) {\n        className.push(classNames.caption_start);\n        style = __assign(__assign({}, style), styles.caption_start);\n    }\n    if (isEnd) {\n        className.push(classNames.caption_end);\n        style = __assign(__assign({}, style), styles.caption_end);\n    }\n    if (isCenter) {\n        className.push(classNames.caption_between);\n        style = __assign(__assign({}, style), styles.caption_between);\n    }\n    var CaptionComponent = (_b = components === null || components === void 0 ? void 0 : components.Caption) !== null && _b !== void 0 ? _b : Caption;\n    return jsxRuntimeExports.jsxs(\"div\", __assign({\n        className: className.join(\" \"),\n        style: style\n    }, {\n        children: [\n            jsxRuntimeExports.jsx(CaptionComponent, {\n                id: captionId,\n                displayMonth: props.displayMonth,\n                displayIndex: props.displayIndex\n            }),\n            jsxRuntimeExports.jsx(Table, {\n                id: tableId,\n                \"aria-labelledby\": captionId,\n                displayMonth: props.displayMonth\n            })\n        ]\n    }), props.displayIndex);\n}\n/**\n * Render the wrapper for the month grids.\n */ function Months(props) {\n    var _a = useDayPicker(), classNames = _a.classNames, styles = _a.styles;\n    return jsxRuntimeExports.jsx(\"div\", __assign({\n        className: classNames.months,\n        style: styles.months\n    }, {\n        children: props.children\n    }));\n}\n/** Render the container with the months according to the number of months to display. */ function Root(_a) {\n    var _b, _c;\n    var initialProps = _a.initialProps;\n    var dayPicker = useDayPicker();\n    var focusContext = useFocusContext();\n    var navigation = useNavigation();\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), hasInitialFocus = _d[0], setHasInitialFocus = _d[1];\n    // Focus the focus target when initialFocus is passed in\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (!dayPicker.initialFocus) return;\n        if (!focusContext.focusTarget) return;\n        if (hasInitialFocus) return;\n        focusContext.focus(focusContext.focusTarget);\n        setHasInitialFocus(true);\n    }, [\n        dayPicker.initialFocus,\n        hasInitialFocus,\n        focusContext.focus,\n        focusContext.focusTarget,\n        focusContext\n    ]);\n    // Apply classnames according to props\n    var classNames = [\n        dayPicker.classNames.root,\n        dayPicker.className\n    ];\n    if (dayPicker.numberOfMonths > 1) {\n        classNames.push(dayPicker.classNames.multiple_months);\n    }\n    if (dayPicker.showWeekNumber) {\n        classNames.push(dayPicker.classNames.with_weeknumber);\n    }\n    var style = __assign(__assign({}, dayPicker.styles.root), dayPicker.style);\n    var dataAttributes = Object.keys(initialProps).filter(function(key) {\n        return key.startsWith(\"data-\");\n    }).reduce(function(attrs, key) {\n        var _a;\n        return __assign(__assign({}, attrs), (_a = {}, _a[key] = initialProps[key], _a));\n    }, {});\n    var MonthsComponent = (_c = (_b = initialProps.components) === null || _b === void 0 ? void 0 : _b.Months) !== null && _c !== void 0 ? _c : Months;\n    return jsxRuntimeExports.jsx(\"div\", __assign({\n        className: classNames.join(\" \"),\n        style: style,\n        dir: dayPicker.dir,\n        id: dayPicker.id,\n        nonce: initialProps.nonce,\n        title: initialProps.title,\n        lang: initialProps.lang\n    }, dataAttributes, {\n        children: jsxRuntimeExports.jsx(MonthsComponent, {\n            children: navigation.displayMonths.map(function(month, i) {\n                return jsxRuntimeExports.jsx(Month, {\n                    displayIndex: i,\n                    displayMonth: month\n                }, i);\n            })\n        })\n    }));\n}\n/** Provide the value for all the context providers. */ function RootProvider(props) {\n    var children = props.children, initialProps = __rest(props, [\n        \"children\"\n    ]);\n    return jsxRuntimeExports.jsx(DayPickerProvider, __assign({\n        initialProps: initialProps\n    }, {\n        children: jsxRuntimeExports.jsx(NavigationProvider, {\n            children: jsxRuntimeExports.jsx(SelectSingleProvider, __assign({\n                initialProps: initialProps\n            }, {\n                children: jsxRuntimeExports.jsx(SelectMultipleProvider, __assign({\n                    initialProps: initialProps\n                }, {\n                    children: jsxRuntimeExports.jsx(SelectRangeProvider, __assign({\n                        initialProps: initialProps\n                    }, {\n                        children: jsxRuntimeExports.jsx(ModifiersProvider, {\n                            children: jsxRuntimeExports.jsx(FocusProvider, {\n                                children: children\n                            })\n                        })\n                    }))\n                }))\n            }))\n        })\n    }));\n}\n/**\n * DayPicker render a date picker component to let users pick dates from a\n * calendar. See http://react-day-picker.js.org for updated documentation and\n * examples.\n *\n * ### Customization\n *\n * DayPicker offers different customization props. For example,\n *\n * - show multiple months using `numberOfMonths`\n * - display a dropdown to navigate the months via `captionLayout`\n * - display the week numbers with `showWeekNumbers`\n * - disable or hide days with `disabled` or `hidden`\n *\n * ### Controlling the months\n *\n * Change the initially displayed month using the `defaultMonth` prop. The\n * displayed months are controlled by DayPicker and stored in its internal\n * state. To control the months yourself, use `month` instead of `defaultMonth`\n * and use the `onMonthChange` event to set it.\n *\n * To limit the months the user can navigate to, use\n * `fromDate`/`fromMonth`/`fromYear` or `toDate`/`toMonth`/`toYear`.\n *\n * ### Selection modes\n *\n * DayPicker supports different selection mode that can be toggled using the\n * `mode` prop:\n *\n * - `mode=\"single\"`: only one day can be selected. Use `required` to make the\n *   selection required. Use the `onSelect` event handler to get the selected\n *   days.\n * - `mode=\"multiple\"`: users can select one or more days. Limit the amount of\n *   days that can be selected with the `min` or the `max` props.\n * - `mode=\"range\"`: users can select a range of days. Limit the amount of days\n *   in the range with the `min` or the `max` props.\n * - `mode=\"default\"` (default): the built-in selections are disabled. Implement\n *   your own selection mode with `onDayClick`.\n *\n * The selection modes should cover the most common use cases. In case you\n * need a more refined way of selecting days, use `mode=\"default\"`. Use the\n * `selected` props and add the day event handlers to add/remove days from the\n * selection.\n *\n * ### Modifiers\n *\n * A _modifier_ represents different styles or states for the days displayed in\n * the calendar (like \"selected\" or \"disabled\"). Define custom modifiers using\n * the `modifiers` prop.\n *\n * ### Formatters and custom component\n *\n * You can customize how the content is displayed in the date picker by using\n * either the formatters or replacing the internal components.\n *\n * For the most common cases you want to use the `formatters` prop to change how\n * the content is formatted in the calendar. Use the `components` prop to\n * replace the internal components, like the navigation icons.\n *\n * ### Styling\n *\n * DayPicker comes with a default, basic style in `react-day-picker/style` – use\n * it as template for your own style.\n *\n * If you are using CSS modules, pass the imported styles object the\n * `classNames` props.\n *\n * You can also style the elements via inline styles using the `styles` prop.\n *\n * ### Form fields\n *\n * If you need to bind the date picker to a form field, you can use the\n * `useInput` hooks for a basic behavior. See the `useInput` source as an\n * example to bind the date picker with form fields.\n *\n * ### Localization\n *\n * To localize DayPicker, import the locale from `date-fns` package and use the\n * `locale` prop.\n *\n * For example, to use Spanish locale:\n *\n * ```\n * import { es } from 'date-fns/locale';\n * <DayPicker locale={es} />\n * ```\n */ function DayPicker(props) {\n    return jsxRuntimeExports.jsx(RootProvider, __assign({}, props, {\n        children: jsxRuntimeExports.jsx(Root, {\n            initialProps: props\n        })\n    }));\n}\n/** @private */ function isValidDate(day) {\n    return !isNaN(day.getTime());\n}\n/** Return props and setters for binding an input field to DayPicker. */ function useInput(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _a = options.locale, locale = _a === void 0 ? date_fns_locale__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : _a, required = options.required, _b = options.format, format$1 = _b === void 0 ? \"PP\" : _b, defaultSelected = options.defaultSelected, _c = options.today, today = _c === void 0 ? new Date() : _c;\n    var _d = parseFromToProps(options), fromDate = _d.fromDate, toDate = _d.toDate;\n    // Shortcut to the DateFns functions\n    var parseValue = function(value) {\n        return (0,date_fns_parse__WEBPACK_IMPORTED_MODULE_32__[\"default\"])(value, format$1, today, {\n            locale: locale\n        });\n    };\n    // Initialize states\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : today), month = _e[0], setMonth = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultSelected), selectedDay = _f[0], setSelectedDay = _f[1];\n    var defaultInputValue = defaultSelected ? (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(defaultSelected, format$1, {\n        locale: locale\n    }) : \"\";\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultInputValue), inputValue = _g[0], setInputValue = _g[1];\n    var reset = function() {\n        setSelectedDay(defaultSelected);\n        setMonth(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : today);\n        setInputValue(defaultInputValue !== null && defaultInputValue !== void 0 ? defaultInputValue : \"\");\n    };\n    var setSelected = function(date) {\n        setSelectedDay(date);\n        setMonth(date !== null && date !== void 0 ? date : today);\n        setInputValue(date ? (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(date, format$1, {\n            locale: locale\n        }) : \"\");\n    };\n    var handleDayClick = function(day, _a) {\n        var selected = _a.selected;\n        if (!required && selected) {\n            setSelectedDay(undefined);\n            setInputValue(\"\");\n            return;\n        }\n        setSelectedDay(day);\n        setInputValue(day ? (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(day, format$1, {\n            locale: locale\n        }) : \"\");\n    };\n    var handleMonthChange = function(month) {\n        setMonth(month);\n    };\n    // When changing the input field, save its value in state and check if the\n    // string is a valid date. If it is a valid day, set it as selected and update\n    // the calendar’s month.\n    var handleChange = function(e) {\n        setInputValue(e.target.value);\n        var day = parseValue(e.target.value);\n        var isBefore = fromDate && (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(fromDate, day) > 0;\n        var isAfter = toDate && (0,date_fns_differenceInCalendarDays__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(day, toDate) > 0;\n        if (!isValidDate(day) || isBefore || isAfter) {\n            setSelectedDay(undefined);\n            return;\n        }\n        setSelectedDay(day);\n        setMonth(day);\n    };\n    // Special case for _required_ fields: on blur, if the value of the input is not\n    // a valid date, reset the calendar and the input value.\n    var handleBlur = function(e) {\n        var day = parseValue(e.target.value);\n        if (!isValidDate(day)) {\n            reset();\n        }\n    };\n    // When focusing, make sure DayPicker visualizes the month of the date in the\n    // input field.\n    var handleFocus = function(e) {\n        if (!e.target.value) {\n            reset();\n            return;\n        }\n        var day = parseValue(e.target.value);\n        if (isValidDate(day)) {\n            setMonth(day);\n        }\n    };\n    var dayPickerProps = {\n        month: month,\n        onDayClick: handleDayClick,\n        onMonthChange: handleMonthChange,\n        selected: selectedDay,\n        locale: locale,\n        fromDate: fromDate,\n        toDate: toDate,\n        today: today\n    };\n    var inputProps = {\n        onBlur: handleBlur,\n        onChange: handleChange,\n        onFocus: handleFocus,\n        value: inputValue,\n        placeholder: (0,date_fns_format__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(new Date(), format$1, {\n            locale: locale\n        })\n    };\n    return {\n        dayPickerProps: dayPickerProps,\n        inputProps: inputProps,\n        reset: reset,\n        setSelected: setSelected\n    };\n}\n/** Returns true when the props are of type {@link DayPickerDefaultProps}. */ function isDayPickerDefault(props) {\n    return props.mode === undefined || props.mode === \"default\";\n}\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF5LXBpY2tlci9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3SDtBQUNnUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNqVztBQUV2Qzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsb0RBQW9ELEdBR3BELElBQUl3QyxXQUFXO0lBQ1hBLFdBQVdDLE9BQU9DLE1BQU0sSUFBSSxTQUFTRixTQUFTRyxDQUFDO1FBQzNDLElBQUssSUFBSUMsR0FBR0MsSUFBSSxHQUFHQyxJQUFJQyxVQUFVQyxNQUFNLEVBQUVILElBQUlDLEdBQUdELElBQUs7WUFDakRELElBQUlHLFNBQVMsQ0FBQ0YsRUFBRTtZQUNoQixJQUFLLElBQUlJLEtBQUtMLEVBQUcsSUFBSUgsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtRQUNoRjtRQUNBLE9BQU9OO0lBQ1g7SUFDQSxPQUFPSCxTQUFTYSxLQUFLLENBQUMsSUFBSSxFQUFFTjtBQUNoQztBQUVBLFNBQVNPLE9BQU9WLENBQUMsRUFBRVcsQ0FBQztJQUNoQixJQUFJWixJQUFJLENBQUM7SUFDVCxJQUFLLElBQUlNLEtBQUtMLEVBQUcsSUFBSUgsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssTUFBTU0sRUFBRUMsT0FBTyxDQUFDUCxL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O0lBQ0o7SUFDQSxJQUFJNGEsaUJBQWlCO1FBQ2pCM2IsT0FBT0E7UUFDUDRMLFlBQVk0UDtRQUNadFUsZUFBZXVCO1FBQ2ZpRCxVQUFVUTtRQUNWbEosUUFBUUE7UUFDUlksVUFBVUE7UUFDVkMsUUFBUUE7UUFDUlIsT0FBT0E7SUFDWDtJQUNBLElBQUl1WSxhQUFhO1FBQ2JwSSxRQUFRaUk7UUFDUnBXLFVBQVVRO1FBQ1Z5TixTQUFTb0k7UUFDVHZsQixPQUFPaWxCO1FBQ1BTLGFBQWFweEIsMkRBQU1BLENBQUMsSUFBSTZZLFFBQVFzWCxVQUFVO1lBQUU1WCxRQUFRQTtRQUFPO0lBQy9EO0lBQ0EsT0FBTztRQUFFMlksZ0JBQWdCQTtRQUFnQkMsWUFBWUE7UUFBWU4sT0FBT0E7UUFBT0MsYUFBYUE7SUFBWTtBQUM1RztBQUVBLDJFQUEyRSxHQUMzRSxTQUFTTyxtQkFBbUJ6ckIsS0FBSztJQUM3QixPQUFPQSxNQUFNc08sSUFBSSxLQUFLaEwsYUFBYXRELE1BQU1zTyxJQUFJLEtBQUs7QUFDdEQ7QUFFZzNCLENBQ2gzQixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ib29raW5nLWNsb25lLXlvdXR1YmUvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF5LXBpY2tlci9kaXN0L2luZGV4LmVzbS5qcz82ZjNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZXF1aXJlJCQwLCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZm9ybWF0LCBzdGFydE9mTW9udGgsIGVuZE9mTW9udGgsIHN0YXJ0T2ZEYXksIGlzU2FtZVllYXIsIHNldE1vbnRoLCBzZXRZZWFyLCBzdGFydE9mWWVhciwgZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMsIGFkZE1vbnRocywgaXNTYW1lTW9udGgsIGlzQmVmb3JlLCBzdGFydE9mSVNPV2Vlaywgc3RhcnRPZldlZWssIGFkZERheXMsIGlzU2FtZURheSwgaXNBZnRlciwgc3ViRGF5cywgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLCBpc0RhdGUsIG1heCwgbWluLCBhZGRXZWVrcywgYWRkWWVhcnMsIGVuZE9mSVNPV2VlaywgZW5kT2ZXZWVrLCBnZXRVbml4VGltZSwgZ2V0SVNPV2VlaywgZ2V0V2VlaywgZ2V0V2Vla3NJbk1vbnRoLCBwYXJzZSB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7IGVuVVMgfSBmcm9tICdkYXRlLWZucy9sb2NhbGUnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXHJcblxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbnZhciBqc3hSdW50aW1lID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbiA9IHt9O1xuXG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbjtcblxuZnVuY3Rpb24gcmVxdWlyZVJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbikgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbjtcblx0aGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4gPSAxO1xudmFyIGY9cmVxdWlyZSQkMCxrPVN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLGw9U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLG09T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxuPWYuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIscD17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuXHRmdW5jdGlvbiBxKGMsYSxnKXt2YXIgYixkPXt9LGU9bnVsbCxoPW51bGw7dm9pZCAwIT09ZyYmKGU9XCJcIitnKTt2b2lkIDAhPT1hLmtleSYmKGU9XCJcIithLmtleSk7dm9pZCAwIT09YS5yZWYmJihoPWEucmVmKTtmb3IoYiBpbiBhKW0uY2FsbChhLGIpJiYhcC5oYXNPd25Qcm9wZXJ0eShiKSYmKGRbYl09YVtiXSk7aWYoYyYmYy5kZWZhdWx0UHJvcHMpZm9yKGIgaW4gYT1jLmRlZmF1bHRQcm9wcyxhKXZvaWQgMD09PWRbYl0mJihkW2JdPWFbYl0pO3JldHVybiB7JCR0eXBlb2Y6ayx0eXBlOmMsa2V5OmUscmVmOmgscHJvcHM6ZCxfb3duZXI6bi5jdXJyZW50fX1yZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4uRnJhZ21lbnQ9bDtyZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4uanN4PXE7cmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluLmpzeHM9cTtcblx0cmV0dXJuIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbjtcbn1cblxudmFyIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCA9IHt9O1xuXG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcblxuZnVuY3Rpb24gcmVxdWlyZVJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCkgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcblx0aGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQgPSAxO1xuXG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcblx0ICAoZnVuY3Rpb24oKSB7XG5cblx0dmFyIFJlYWN0ID0gcmVxdWlyZSQkMDtcblxuXHQvLyBBVFRFTlRJT05cblx0Ly8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuXHQvLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG5cdC8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxuXHR2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xuXHR2YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcblx0dmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuXHR2YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG5cdHZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcblx0dmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xuXHR2YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xuXHR2YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG5cdHZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcblx0dmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcblx0dmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcblx0dmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcblx0dmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG5cdHZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG5cdHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblx0ZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG5cdCAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cblx0ICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuXHQgIH1cblxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cblx0ZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG5cdCAge1xuXHQgICAge1xuXHQgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHQgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgIH1cblxuXHQgICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuXHQgIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuXHQgIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuXHQgIHtcblx0ICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblx0ICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG5cdCAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG5cdCAgICAgIGZvcm1hdCArPSAnJXMnO1xuXHQgICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG5cdCAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cblx0ICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG5cdCAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuXHQgICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG5cdCAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cblx0ICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG5cdCAgfVxuXHR9XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHR2YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXHR2YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG5cdHZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG5cdHZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG5cdC8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcblx0Ly8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cblx0dmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxuXHR2YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxuXHR7XG5cdCAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cblx0ICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG5cdCAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3Rcblx0ICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2Vcblx0ICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuXHQgICAgLy8gd2l0aC5cblx0ICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuXHQgIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuXHQgIGlmIChkaXNwbGF5TmFtZSkge1xuXHQgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuXHQgIH1cblxuXHQgIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcblx0fSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5cdGZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcblx0ICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG5cdH0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cblx0ZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcblx0ICBpZiAodHlwZSA9PSBudWxsKSB7XG5cdCAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gdHlwZTtcblx0ICB9XG5cblx0ICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcblx0ICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cblx0ICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG5cdCAgICAgIHJldHVybiAnUG9ydGFsJztcblxuXHQgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuXHQgICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuXHQgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuXHQgICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG5cdCAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG5cdCAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG5cdCAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcblx0ICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuXHQgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG5cdCAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuXHQgICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblx0ICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuXHQgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG5cdCAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcblx0ICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cblx0ICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuXHQgICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuXHQgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcblx0ICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG5cdCAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG5cdCAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcblx0ICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcblx0ICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cblx0Ly8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuXHQvLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuXHQvLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG5cdC8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxuXHR2YXIgZGlzYWJsZWREZXB0aCA9IDA7XG5cdHZhciBwcmV2TG9nO1xuXHR2YXIgcHJldkluZm87XG5cdHZhciBwcmV2V2Fybjtcblx0dmFyIHByZXZFcnJvcjtcblx0dmFyIHByZXZHcm91cDtcblx0dmFyIHByZXZHcm91cENvbGxhcHNlZDtcblx0dmFyIHByZXZHcm91cEVuZDtcblxuXHRmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cblx0ZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcblx0ZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG5cdCAge1xuXHQgICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcblx0ICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG5cdCAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcblx0ICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG5cdCAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuXHQgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuXHQgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuXHQgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuXHQgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cblx0ICAgICAgdmFyIHByb3BzID0ge1xuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcblx0ICAgICAgICB3cml0YWJsZTogdHJ1ZVxuXHQgICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcblx0ICAgICAgICBpbmZvOiBwcm9wcyxcblx0ICAgICAgICBsb2c6IHByb3BzLFxuXHQgICAgICAgIHdhcm46IHByb3BzLFxuXHQgICAgICAgIGVycm9yOiBwcm9wcyxcblx0ICAgICAgICBncm91cDogcHJvcHMsXG5cdCAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuXHQgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuXHQgICAgICB9KTtcblx0ICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cblx0ICAgIH1cblxuXHQgICAgZGlzYWJsZWREZXB0aCsrO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG5cdCAge1xuXHQgICAgZGlzYWJsZWREZXB0aC0tO1xuXG5cdCAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuXHQgICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cblx0ICAgICAgdmFyIHByb3BzID0ge1xuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIHdyaXRhYmxlOiB0cnVlXG5cdCAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cblx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuXHQgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuXHQgICAgICAgICAgdmFsdWU6IHByZXZMb2dcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG5cdCAgICAgICAgICB2YWx1ZTogcHJldkluZm9cblx0ICAgICAgICB9KSxcblx0ICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG5cdCAgICAgICAgICB2YWx1ZTogcHJldldhcm5cblx0ICAgICAgICB9KSxcblx0ICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuXHQgICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG5cdCAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcblx0ICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuXHQgICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuXHQgICAgICAgIH0pXG5cdCAgICAgIH0pO1xuXHQgICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcblx0ICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcblx0dmFyIHByZWZpeDtcblx0ZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG5cdCAge1xuXHQgICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICB0aHJvdyBFcnJvcigpO1xuXHQgICAgICB9IGNhdGNoICh4KSB7XG5cdCAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcblx0ICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcblx0ICAgICAgfVxuXHQgICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG5cdCAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuXHQgIH1cblx0fVxuXHR2YXIgcmVlbnRyeSA9IGZhbHNlO1xuXHR2YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxuXHR7XG5cdCAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblx0ICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG5cdCAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG5cdCAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuXHQgICAgcmV0dXJuICcnO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuXHQgICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgcmV0dXJuIGZyYW1lO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBjb250cm9sO1xuXHQgIHJlZW50cnkgPSB0cnVlO1xuXHQgIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG5cdCAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG5cdCAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuXHQgIHtcblx0ICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG5cdCAgICAvLyBmb3Igd2FybmluZ3MuXG5cblx0ICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG5cdCAgICBkaXNhYmxlTG9ncygpO1xuXHQgIH1cblxuXHQgIHRyeSB7XG5cdCAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cblx0ICAgIGlmIChjb25zdHJ1Y3QpIHtcblx0ICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG5cdCAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRocm93IEVycm9yKCk7XG5cdCAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuXHQgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuXHQgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcblx0ICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG5cdCAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuXHQgICAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICAgIGNvbnRyb2wgPSB4O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIEZha2UuY2FsbCgpO1xuXHQgICAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICAgIGNvbnRyb2wgPSB4O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHRocm93IEVycm9yKCk7XG5cdCAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICBjb250cm9sID0geDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZuKCk7XG5cdCAgICB9XG5cdCAgfSBjYXRjaCAoc2FtcGxlKSB7XG5cdCAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuXHQgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG5cdCAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuXHQgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuXHQgICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG5cdCAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuXHQgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG5cdCAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG5cdCAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuXHQgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG5cdCAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcblx0ICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuXHQgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuXHQgICAgICAgIGMtLTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuXHQgICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuXHQgICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuXHQgICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG5cdCAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuXHQgICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuXHQgICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcblx0ICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cblx0ICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG5cdCAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG5cdCAgICAgICAgICAgIGRvIHtcblx0ICAgICAgICAgICAgICBzLS07XG5cdCAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG5cdCAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cblx0ICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuXHQgICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG5cdCAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcblx0ICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcblx0ICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cblx0ICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcblx0ICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IGZpbmFsbHkge1xuXHQgICAgcmVlbnRyeSA9IGZhbHNlO1xuXG5cdCAgICB7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcblx0ICAgICAgcmVlbmFibGVMb2dzKCk7XG5cdCAgICB9XG5cblx0ICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcblx0ICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG5cdCAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcblx0ICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuXHQgIHtcblx0ICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gc3ludGhldGljRnJhbWU7XG5cdH1cblx0ZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcblx0ICB7XG5cdCAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcblx0ICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblx0ICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuXHQgIGlmICh0eXBlID09IG51bGwpIHtcblx0ICAgIHJldHVybiAnJztcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHtcblx0ICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG5cdCAgfVxuXG5cdCAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG5cdCAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuXHQgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG5cdCAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuXHQgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG5cdCAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcblx0ICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuXHQgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcblx0ICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuXHQgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG5cdCAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcblx0ICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcblx0ICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuXHQgICAgICAgICAgfSBjYXRjaCAoeCkge31cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuICcnO1xuXHR9XG5cblx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHR2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cdHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuXHRmdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG5cdCAge1xuXHQgICAgaWYgKGVsZW1lbnQpIHtcblx0ICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cdCAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG5cdCAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuXHQgIHtcblx0ICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cblx0ICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG5cdCAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG5cdCAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG5cdCAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG5cdCAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuXHQgICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcblx0ICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cblx0ICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblx0ICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG5cdCAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuXHQgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG5cdCAgICAgICAgICBlcnJvciQxID0gZXg7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG5cdCAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuXHQgICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cblx0ICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuXHQgICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG5cdCAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuXHQgICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuXHQgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cblx0ICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuXHQgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0dmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cdGZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuXHQgIHJldHVybiBpc0FycmF5SW1wbChhKTtcblx0fVxuXG5cdC8qXG5cdCAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuXHQgKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuXHQgKlxuXHQgKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG5cdCAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcblx0ICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG5cdCAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG5cdCAqL1xuXHQvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXHRmdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuXHQgIHtcblx0ICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcblx0ICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuXHQgICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG5cdCAgICByZXR1cm4gdHlwZTtcblx0ICB9XG5cdH0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5cdGZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG5cdCAge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcblx0ICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3Ncblx0ICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuXHQgIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cblx0ICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cblx0ICAvL1xuXHQgIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuXHQgIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG5cdCAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG5cdCAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG5cdCAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG5cdCAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcblx0ICAvL1xuXHQgIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcblx0ICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG5cdCAgLy9cblx0ICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuXHQgIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuXHQgIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcblx0ICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuXHQgIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcblx0ICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG5cdCAgLy9cblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblx0ICByZXR1cm4gJycgKyB2YWx1ZTtcblx0fVxuXHRmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG5cdCAge1xuXHQgICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuXHQgICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG5cdCAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXHR2YXIgUkVTRVJWRURfUFJPUFMgPSB7XG5cdCAga2V5OiB0cnVlLFxuXHQgIHJlZjogdHJ1ZSxcblx0ICBfX3NlbGY6IHRydWUsXG5cdCAgX19zb3VyY2U6IHRydWVcblx0fTtcblx0dmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuXHR2YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cdHZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG5cdHtcblx0ICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG5cdH1cblxuXHRmdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcblx0ICB7XG5cdCAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuXHQgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cblx0ICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG5cdCAge1xuXHQgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcblx0ICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG5cdCAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdGZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcblx0ICB7XG5cdCAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuXHQgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG5cdCAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuXHQgICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuXHQgICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG5cdCAge1xuXHQgICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuXHQgICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuXHQgICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcblx0ICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG5cdCAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG5cdCAge1xuXHQgICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuXHQgICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuXHQgICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcblx0ICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG5cdCAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgfVxuXHR9XG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuXHQgKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuXHQgKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcblx0ICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHsqfSB0eXBlXG5cdCAqIEBwYXJhbSB7Kn0gcHJvcHNcblx0ICogQHBhcmFtIHsqfSBrZXlcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcblx0ICogQHBhcmFtIHsqfSBvd25lclxuXHQgKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcblx0ICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuXHQgKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuXHQgKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG5cdCAqIGNoYW5nZSBpbiBiZWhhdmlvci5cblx0ICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG5cdCAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblxuXG5cdHZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG5cdCAgdmFyIGVsZW1lbnQgPSB7XG5cdCAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcblx0ICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cdCAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG5cdCAgICB0eXBlOiB0eXBlLFxuXHQgICAga2V5OiBrZXksXG5cdCAgICByZWY6IHJlZixcblx0ICAgIHByb3BzOiBwcm9wcyxcblx0ICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG5cdCAgICBfb3duZXI6IG93bmVyXG5cdCAgfTtcblxuXHQgIHtcblx0ICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cblx0ICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG5cdCAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG5cdCAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cblx0ICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG5cdCAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG5cdCAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuXHQgICAgLy8gaWdub3JlcyBpdC5cblxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuXHQgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuXHQgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgd3JpdGFibGU6IHRydWUsXG5cdCAgICAgIHZhbHVlOiBmYWxzZVxuXHQgICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcblx0ICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcblx0ICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgIHdyaXRhYmxlOiBmYWxzZSxcblx0ICAgICAgdmFsdWU6IHNlbGZcblx0ICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuXHQgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcblx0ICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcblx0ICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgIHdyaXRhYmxlOiBmYWxzZSxcblx0ICAgICAgdmFsdWU6IHNvdXJjZVxuXHQgICAgfSk7XG5cblx0ICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG5cdCAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG5cdCAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGVsZW1lbnQ7XG5cdH07XG5cdC8qKlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG5cdCAqIEBwYXJhbSB7Kn0gdHlwZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleVxuXHQgKi9cblxuXHRmdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG5cdCAge1xuXHQgICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblx0ICAgIHZhciBwcm9wcyA9IHt9O1xuXHQgICAgdmFyIGtleSA9IG51bGw7XG5cdCAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG5cdCAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cblx0ICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG5cdCAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcblx0ICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG5cdCAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG5cdCAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB7XG5cdCAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuXHQgICAgICB7XG5cdCAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcblx0ICAgICAgcmVmID0gY29uZmlnLnJlZjtcblx0ICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG5cdCAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG5cdCAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuXHQgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG5cdCAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcblx0ICAgICAgfVxuXHQgICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG5cdCAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHQgICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cblx0ICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcblx0ICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChrZXkgfHwgcmVmKSB7XG5cdCAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuXHQgICAgICBpZiAoa2V5KSB7XG5cdCAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChyZWYpIHtcblx0ICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXHQgIH1cblx0fVxuXG5cdHZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5cdHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5cdGZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuXHQgIHtcblx0ICAgIGlmIChlbGVtZW50KSB7XG5cdCAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXHQgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuXHQgICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0dmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG5cdHtcblx0ICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xuXHR9XG5cdC8qKlxuXHQgKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuXHQgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG5cdCAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG5cdCAqIEBmaW5hbFxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuXHQgIHtcblx0ICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuXHQgIHtcblx0ICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcblx0ICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG5cdCAgICAgIGlmIChuYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiAnJztcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcblx0ICB7XG5cdCAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcblx0ICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcblx0ICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuICcnO1xuXHQgIH1cblx0fVxuXHQvKipcblx0ICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuXHQgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cblx0ICogdXBkYXRlcy5cblx0ICovXG5cblxuXHR2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cblx0ZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG5cdCAge1xuXHQgICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuXHQgICAgaWYgKCFpbmZvKSB7XG5cdCAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG5cdCAgICAgIGlmIChwYXJlbnROYW1lKSB7XG5cdCAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBpbmZvO1xuXHQgIH1cblx0fVxuXHQvKipcblx0ICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuXHQgKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcblx0ICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG5cdCAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuXHQgKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cblx0ICpcblx0ICogQGludGVybmFsXG5cdCAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cblx0ICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuXHQgIHtcblx0ICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXHQgICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG5cdCAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcblx0ICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3Jcblx0ICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuXHQgICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuXHQgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuXHQgICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cblx0ICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG5cdCAgICB9XG5cblx0ICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cblx0ICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG5cdCAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuXHQgIH1cblx0fVxuXHQvKipcblx0ICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuXHQgKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcblx0ICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG5cdCAqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cblx0ICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcblx0ICB7XG5cdCAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuXHQgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcblx0ICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuXHQgICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuXHQgICAgICBpZiAobm9kZS5fc3RvcmUpIHtcblx0ICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG5vZGUpIHtcblx0ICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcblx0ICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cblx0ICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG5cdCAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG5cdCAgICAgICAgICB2YXIgc3RlcDtcblxuXHQgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuXHQgICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdC8qKlxuXHQgKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuXHQgKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cblx0ICpcblx0ICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcblx0ICovXG5cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG5cdCAge1xuXHQgICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cblx0ICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcHJvcFR5cGVzO1xuXG5cdCAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG5cdCAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cblx0ICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcblx0ICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmIChwcm9wVHlwZXMpIHtcblx0ICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblx0ICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cdCAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcblx0ICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG5cdCAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuXHQgICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcblx0ICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0LyoqXG5cdCAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuXHQgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcblx0ICovXG5cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcblx0ICB7XG5cdCAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG5cdCAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuXHQgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG5cdCAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG5cdCAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG5cdCAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG5cdCAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG5cdCAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG5cdCAge1xuXHQgICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cblx0ICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cblx0ICAgIGlmICghdmFsaWRUeXBlKSB7XG5cdCAgICAgIHZhciBpbmZvID0gJyc7XG5cblx0ICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG5cdCAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG5cdCAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdHlwZVN0cmluZztcblxuXHQgICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuXHQgICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG5cdCAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuXHQgICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuXHQgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcblx0ICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG5cdCAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG5cdCAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cblx0ICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIGVsZW1lbnQ7XG5cdCAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG5cdCAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG5cdCAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG5cdCAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuXHQgICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cblx0ICAgIGlmICh2YWxpZFR5cGUpIHtcblx0ICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cblx0ICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuXHQgICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuXHQgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuXHQgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGVsZW1lbnQ7XG5cdCAgfVxuXHR9IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXHQvLyBldmVuIHdpdGggdGhlIHByb2QgdHJhbnNmb3JtLiBUaGlzIG1lYW5zIHRoYXQganN4REVWIGlzIHB1cmVseVxuXHQvLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG5cdC8vIGdpdmluZyB5b3Ugd2FybmluZ3MgaWYgeW91IHVzZSBwcm9kdWN0aW9uIGFwaXMuXG5cblx0ZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuXHQgIHtcblx0ICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcblx0ICB7XG5cdCAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xuXHQgIH1cblx0fVxuXG5cdHZhciBqc3ggPSAganN4V2l0aFZhbGlkYXRpb25EeW5hbWljIDsgLy8gd2UgbWF5IHdhbnQgdG8gc3BlY2lhbCBjYXNlIGpzeHMgaW50ZXJuYWxseSB0byB0YWtlIGFkdmFudGFnZSBvZiBzdGF0aWMgY2hpbGRyZW4uXG5cdC8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cblx0dmFyIGpzeHMgPSAganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5cdHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudC5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5cdHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudC5qc3ggPSBqc3g7XG5cdHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudC5qc3hzID0ganN4cztcblx0ICB9KSgpO1xuXHR9XG5cdHJldHVybiByZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQ7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGpzeFJ1bnRpbWUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4oKTtcbn0gZWxzZSB7XG4gIGpzeFJ1bnRpbWUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQoKTtcbn1cblxudmFyIGpzeFJ1bnRpbWVFeHBvcnRzID0ganN4UnVudGltZS5leHBvcnRzO1xuXG4vKiogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHByb3BzIGFyZSBvZiB0eXBlIHtAbGluayBEYXlQaWNrZXJNdWx0aXBsZVByb3BzfS4gKi9cbmZ1bmN0aW9uIGlzRGF5UGlja2VyTXVsdGlwbGUocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMubW9kZSA9PT0gJ211bHRpcGxlJztcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwcm9wcyBhcmUgb2YgdHlwZSB7QGxpbmsgRGF5UGlja2VyUmFuZ2VQcm9wc30uICovXG5mdW5jdGlvbiBpc0RheVBpY2tlclJhbmdlKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLm1vZGUgPT09ICdyYW5nZSc7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcHJvcHMgYXJlIG9mIHR5cGUge0BsaW5rIERheVBpY2tlclNpbmdsZVByb3BzfS4gKi9cbmZ1bmN0aW9uIGlzRGF5UGlja2VyU2luZ2xlKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLm1vZGUgPT09ICdzaW5nbGUnO1xufVxuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IENTUyBjbGFzc2VzLlxuICovXG52YXIgZGVmYXVsdENsYXNzTmFtZXMgPSB7XG4gICAgcm9vdDogJ3JkcCcsXG4gICAgbXVsdGlwbGVfbW9udGhzOiAncmRwLW11bHRpcGxlX21vbnRocycsXG4gICAgd2l0aF93ZWVrbnVtYmVyOiAncmRwLXdpdGhfd2Vla251bWJlcicsXG4gICAgdmhpZGRlbjogJ3JkcC12aGlkZGVuJyxcbiAgICBidXR0b25fcmVzZXQ6ICdyZHAtYnV0dG9uX3Jlc2V0JyxcbiAgICBidXR0b246ICdyZHAtYnV0dG9uJyxcbiAgICBjYXB0aW9uOiAncmRwLWNhcHRpb24nLFxuICAgIGNhcHRpb25fc3RhcnQ6ICdyZHAtY2FwdGlvbl9zdGFydCcsXG4gICAgY2FwdGlvbl9lbmQ6ICdyZHAtY2FwdGlvbl9lbmQnLFxuICAgIGNhcHRpb25fYmV0d2VlbjogJ3JkcC1jYXB0aW9uX2JldHdlZW4nLFxuICAgIGNhcHRpb25fbGFiZWw6ICdyZHAtY2FwdGlvbl9sYWJlbCcsXG4gICAgY2FwdGlvbl9kcm9wZG93bnM6ICdyZHAtY2FwdGlvbl9kcm9wZG93bnMnLFxuICAgIGRyb3Bkb3duOiAncmRwLWRyb3Bkb3duJyxcbiAgICBkcm9wZG93bl9tb250aDogJ3JkcC1kcm9wZG93bl9tb250aCcsXG4gICAgZHJvcGRvd25feWVhcjogJ3JkcC1kcm9wZG93bl95ZWFyJyxcbiAgICBkcm9wZG93bl9pY29uOiAncmRwLWRyb3Bkb3duX2ljb24nLFxuICAgIG1vbnRoczogJ3JkcC1tb250aHMnLFxuICAgIG1vbnRoOiAncmRwLW1vbnRoJyxcbiAgICB0YWJsZTogJ3JkcC10YWJsZScsXG4gICAgdGJvZHk6ICdyZHAtdGJvZHknLFxuICAgIHRmb290OiAncmRwLXRmb290JyxcbiAgICBoZWFkOiAncmRwLWhlYWQnLFxuICAgIGhlYWRfcm93OiAncmRwLWhlYWRfcm93JyxcbiAgICBoZWFkX2NlbGw6ICdyZHAtaGVhZF9jZWxsJyxcbiAgICBuYXY6ICdyZHAtbmF2JyxcbiAgICBuYXZfYnV0dG9uOiAncmRwLW5hdl9idXR0b24nLFxuICAgIG5hdl9idXR0b25fcHJldmlvdXM6ICdyZHAtbmF2X2J1dHRvbl9wcmV2aW91cycsXG4gICAgbmF2X2J1dHRvbl9uZXh0OiAncmRwLW5hdl9idXR0b25fbmV4dCcsXG4gICAgbmF2X2ljb246ICdyZHAtbmF2X2ljb24nLFxuICAgIHJvdzogJ3JkcC1yb3cnLFxuICAgIHdlZWtudW1iZXI6ICdyZHAtd2Vla251bWJlcicsXG4gICAgY2VsbDogJ3JkcC1jZWxsJyxcbiAgICBkYXk6ICdyZHAtZGF5JyxcbiAgICBkYXlfdG9kYXk6ICdyZHAtZGF5X3RvZGF5JyxcbiAgICBkYXlfb3V0c2lkZTogJ3JkcC1kYXlfb3V0c2lkZScsXG4gICAgZGF5X3NlbGVjdGVkOiAncmRwLWRheV9zZWxlY3RlZCcsXG4gICAgZGF5X2Rpc2FibGVkOiAncmRwLWRheV9kaXNhYmxlZCcsXG4gICAgZGF5X2hpZGRlbjogJ3JkcC1kYXlfaGlkZGVuJyxcbiAgICBkYXlfcmFuZ2Vfc3RhcnQ6ICdyZHAtZGF5X3JhbmdlX3N0YXJ0JyxcbiAgICBkYXlfcmFuZ2VfZW5kOiAncmRwLWRheV9yYW5nZV9lbmQnLFxuICAgIGRheV9yYW5nZV9taWRkbGU6ICdyZHAtZGF5X3JhbmdlX21pZGRsZSdcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZm9ybWF0dGVyIGZvciB0aGUgY2FwdGlvbi5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0Q2FwdGlvbihtb250aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBmb3JtYXQobW9udGgsICdMTExMIHknLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBmb3JtYXR0ZXIgZm9yIHRoZSBEYXkgYnV0dG9uLlxuICovXG5mdW5jdGlvbiBmb3JtYXREYXkoZGF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZvcm1hdChkYXksICdkJywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZm9ybWF0dGVyIGZvciB0aGUgTW9udGggY2FwdGlvbi5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0TW9udGhDYXB0aW9uKG1vbnRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZvcm1hdChtb250aCwgJ0xMTEwnLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBmb3JtYXR0ZXIgZm9yIHRoZSB3ZWVrIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcih3ZWVrTnVtYmVyKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHdlZWtOdW1iZXIpO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGZvcm1hdHRlciBmb3IgdGhlIG5hbWUgb2YgdGhlIHdlZWtkYXkuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOYW1lKHdlZWtkYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZm9ybWF0KHdlZWtkYXksICdjY2NjY2MnLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBmb3JtYXR0ZXIgZm9yIHRoZSBZZWFyIGNhcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFllYXJDYXB0aW9uKHllYXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZm9ybWF0KHllYXIsICd5eXl5Jywgb3B0aW9ucyk7XG59XG5cbnZhciBmb3JtYXR0ZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBmb3JtYXRDYXB0aW9uOiBmb3JtYXRDYXB0aW9uLFxuICAgIGZvcm1hdERheTogZm9ybWF0RGF5LFxuICAgIGZvcm1hdE1vbnRoQ2FwdGlvbjogZm9ybWF0TW9udGhDYXB0aW9uLFxuICAgIGZvcm1hdFdlZWtOdW1iZXI6IGZvcm1hdFdlZWtOdW1iZXIsXG4gICAgZm9ybWF0V2Vla2RheU5hbWU6IGZvcm1hdFdlZWtkYXlOYW1lLFxuICAgIGZvcm1hdFllYXJDYXB0aW9uOiBmb3JtYXRZZWFyQ2FwdGlvblxufSk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgQVJJQSBsYWJlbCBmb3IgdGhlIGRheSBidXR0b24uXG4gKi9cbnZhciBsYWJlbERheSA9IGZ1bmN0aW9uIChkYXksIGFjdGl2ZU1vZGlmaWVycywgb3B0aW9ucykge1xuICAgIHJldHVybiBmb3JtYXQoZGF5LCAnZG8gTU1NTSAoRUVFRSknLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgQVJJQSBsYWJlbCBmb3IgdGhlIFdlZWtOdW1iZXIgZWxlbWVudC5cbiAqL1xudmFyIGxhYmVsTW9udGhEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ01vbnRoOiAnO1xufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBBUklBIGxhYmVsIGZvciBuZXh0IG1vbnRoIGJ1dHRvbiBpbiBuYXZpZ2F0aW9uXG4gKi9cbnZhciBsYWJlbE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdHbyB0byBuZXh0IG1vbnRoJztcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgQVJJQSBsYWJlbCBmb3IgcHJldmlvdXMgbW9udGggYnV0dG9uIGluIG5hdmlnYXRpb25cbiAqL1xudmFyIGxhYmVsUHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdHbyB0byBwcmV2aW91cyBtb250aCc7XG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IEFSSUEgbGFiZWwgZm9yIHRoZSBXZWVrZGF5IGVsZW1lbnQuXG4gKi9cbnZhciBsYWJlbFdlZWtkYXkgPSBmdW5jdGlvbiAoZGF5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZvcm1hdChkYXksICdjY2NjJywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IEFSSUEgbGFiZWwgZm9yIHRoZSBXZWVrTnVtYmVyIGVsZW1lbnQuXG4gKi9cbnZhciBsYWJlbFdlZWtOdW1iZXIgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBcIldlZWsgbi4gXCIuY29uY2F0KG4pO1xufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBBUklBIGxhYmVsIGZvciB0aGUgV2Vla051bWJlciBlbGVtZW50LlxuICovXG52YXIgbGFiZWxZZWFyRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdZZWFyOiAnO1xufTtcblxudmFyIGxhYmVscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbGFiZWxEYXk6IGxhYmVsRGF5LFxuICAgIGxhYmVsTW9udGhEcm9wZG93bjogbGFiZWxNb250aERyb3Bkb3duLFxuICAgIGxhYmVsTmV4dDogbGFiZWxOZXh0LFxuICAgIGxhYmVsUHJldmlvdXM6IGxhYmVsUHJldmlvdXMsXG4gICAgbGFiZWxXZWVrTnVtYmVyOiBsYWJlbFdlZWtOdW1iZXIsXG4gICAgbGFiZWxXZWVrZGF5OiBsYWJlbFdlZWtkYXksXG4gICAgbGFiZWxZZWFyRHJvcGRvd246IGxhYmVsWWVhckRyb3Bkb3duXG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyB0byB1c2UgaW4gdGhlIERheVBpY2tlckNvbnRleHQsIGluIGNhc2UgdGhleSBhcmVcbiAqIG5vdCBwYXNzZWQgZG93biB3aXRoIHRoZSBEYXlQaWNrZXIgaW5pdGlhbCBwcm9wcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbnRleHRWYWx1ZXMoKSB7XG4gICAgdmFyIGNhcHRpb25MYXlvdXQgPSAnYnV0dG9ucyc7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBkZWZhdWx0Q2xhc3NOYW1lcztcbiAgICB2YXIgbG9jYWxlID0gZW5VUztcbiAgICB2YXIgbW9kaWZpZXJzQ2xhc3NOYW1lcyA9IHt9O1xuICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICB2YXIgbnVtYmVyT2ZNb250aHMgPSAxO1xuICAgIHZhciBzdHlsZXMgPSB7fTtcbiAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhcHRpb25MYXlvdXQ6IGNhcHRpb25MYXlvdXQsXG4gICAgICAgIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXMsXG4gICAgICAgIGZvcm1hdHRlcnM6IGZvcm1hdHRlcnMsXG4gICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgbW9kaWZpZXJzQ2xhc3NOYW1lczogbW9kaWZpZXJzQ2xhc3NOYW1lcyxcbiAgICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICAgIG51bWJlck9mTW9udGhzOiBudW1iZXJPZk1vbnRocyxcbiAgICAgICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgICAgIHRvZGF5OiB0b2RheSxcbiAgICAgICAgbW9kZTogJ2RlZmF1bHQnXG4gICAgfTtcbn1cblxuLyoqIFJldHVybiB0aGUgYGZyb21EYXRlYCBhbmQgYHRvRGF0ZWAgcHJvcCB2YWx1ZXMgdmFsdWVzIHBhcnNpbmcgdGhlIERheVBpY2tlciBwcm9wcy4gKi9cbmZ1bmN0aW9uIHBhcnNlRnJvbVRvUHJvcHMocHJvcHMpIHtcbiAgICB2YXIgZnJvbVllYXIgPSBwcm9wcy5mcm9tWWVhciwgdG9ZZWFyID0gcHJvcHMudG9ZZWFyLCBmcm9tTW9udGggPSBwcm9wcy5mcm9tTW9udGgsIHRvTW9udGggPSBwcm9wcy50b01vbnRoO1xuICAgIHZhciBmcm9tRGF0ZSA9IHByb3BzLmZyb21EYXRlLCB0b0RhdGUgPSBwcm9wcy50b0RhdGU7XG4gICAgaWYgKGZyb21Nb250aCkge1xuICAgICAgICBmcm9tRGF0ZSA9IHN0YXJ0T2ZNb250aChmcm9tTW9udGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmcm9tWWVhcikge1xuICAgICAgICBmcm9tRGF0ZSA9IG5ldyBEYXRlKGZyb21ZZWFyLCAwLCAxKTtcbiAgICB9XG4gICAgaWYgKHRvTW9udGgpIHtcbiAgICAgICAgdG9EYXRlID0gZW5kT2ZNb250aCh0b01vbnRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9ZZWFyKSB7XG4gICAgICAgIHRvRGF0ZSA9IG5ldyBEYXRlKHRvWWVhciwgMTEsIDMxKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbURhdGU6IGZyb21EYXRlID8gc3RhcnRPZkRheShmcm9tRGF0ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHRvRGF0ZTogdG9EYXRlID8gc3RhcnRPZkRheSh0b0RhdGUpIDogdW5kZWZpbmVkXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgRGF5UGlja2VyIGNvbnRleHQgc2hhcmVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gRGF5UGlja2VyIHdpdGhpbiBpbnRlcm5hbFxuICogYW5kIGN1c3RvbSBjb21wb25lbnRzLiBJdCBpcyB1c2VkIHRvIHNldCB0aGUgZGVmYXVsdCB2YWx1ZXMgYW5kIHBlcmZvcm1cbiAqIG9uZS10aW1lIGNhbGN1bGF0aW9ucyByZXF1aXJlZCB0byByZW5kZXIgdGhlIGRheXMuXG4gKlxuICogQWNjZXNzIHRvIHRoaXMgY29udGV4dCBmcm9tIHRoZSB7QGxpbmsgdXNlRGF5UGlja2VyfSBob29rLlxuICovXG52YXIgRGF5UGlja2VyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKlxuICogVGhlIHByb3ZpZGVyIGZvciB0aGUge0BsaW5rIERheVBpY2tlckNvbnRleHR9LCBhc3NpZ25pbmcgdGhlIGRlZmF1bHRzIGZyb20gdGhlXG4gKiBpbml0aWFsIERheVBpY2tlciBwcm9wcy5cbiAqL1xuZnVuY3Rpb24gRGF5UGlja2VyUHJvdmlkZXIocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGluaXRpYWxQcm9wcyA9IHByb3BzLmluaXRpYWxQcm9wcztcbiAgICB2YXIgZGVmYXVsdENvbnRleHRWYWx1ZXMgPSBnZXREZWZhdWx0Q29udGV4dFZhbHVlcygpO1xuICAgIHZhciBfYiA9IHBhcnNlRnJvbVRvUHJvcHMoaW5pdGlhbFByb3BzKSwgZnJvbURhdGUgPSBfYi5mcm9tRGF0ZSwgdG9EYXRlID0gX2IudG9EYXRlO1xuICAgIHZhciBjYXB0aW9uTGF5b3V0ID0gKF9hID0gaW5pdGlhbFByb3BzLmNhcHRpb25MYXlvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRDb250ZXh0VmFsdWVzLmNhcHRpb25MYXlvdXQ7XG4gICAgaWYgKGNhcHRpb25MYXlvdXQgIT09ICdidXR0b25zJyAmJiAoIWZyb21EYXRlIHx8ICF0b0RhdGUpKSB7XG4gICAgICAgIC8vIFdoZW4gbm8gZnJvbS90byBkYXRlcyBhcmUgc2V0LCB0aGUgY2FwdGlvbiBpcyBhbHdheXMgYnV0dG9uc1xuICAgICAgICBjYXB0aW9uTGF5b3V0ID0gJ2J1dHRvbnMnO1xuICAgIH1cbiAgICB2YXIgb25TZWxlY3Q7XG4gICAgaWYgKGlzRGF5UGlja2VyU2luZ2xlKGluaXRpYWxQcm9wcykgfHxcbiAgICAgICAgaXNEYXlQaWNrZXJNdWx0aXBsZShpbml0aWFsUHJvcHMpIHx8XG4gICAgICAgIGlzRGF5UGlja2VyUmFuZ2UoaW5pdGlhbFByb3BzKSkge1xuICAgICAgICBvblNlbGVjdCA9IGluaXRpYWxQcm9wcy5vblNlbGVjdDtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRDb250ZXh0VmFsdWVzKSwgaW5pdGlhbFByb3BzKSwgeyBjYXB0aW9uTGF5b3V0OiBjYXB0aW9uTGF5b3V0LCBjbGFzc05hbWVzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdENvbnRleHRWYWx1ZXMuY2xhc3NOYW1lcyksIGluaXRpYWxQcm9wcy5jbGFzc05hbWVzKSwgY29tcG9uZW50czogX19hc3NpZ24oe30sIGluaXRpYWxQcm9wcy5jb21wb25lbnRzKSwgZm9ybWF0dGVyczogX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRDb250ZXh0VmFsdWVzLmZvcm1hdHRlcnMpLCBpbml0aWFsUHJvcHMuZm9ybWF0dGVycyksIGZyb21EYXRlOiBmcm9tRGF0ZSwgbGFiZWxzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdENvbnRleHRWYWx1ZXMubGFiZWxzKSwgaW5pdGlhbFByb3BzLmxhYmVscyksIG1vZGU6IGluaXRpYWxQcm9wcy5tb2RlIHx8IGRlZmF1bHRDb250ZXh0VmFsdWVzLm1vZGUsIG1vZGlmaWVyczogX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRDb250ZXh0VmFsdWVzLm1vZGlmaWVycyksIGluaXRpYWxQcm9wcy5tb2RpZmllcnMpLCBtb2RpZmllcnNDbGFzc05hbWVzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdENvbnRleHRWYWx1ZXMubW9kaWZpZXJzQ2xhc3NOYW1lcyksIGluaXRpYWxQcm9wcy5tb2RpZmllcnNDbGFzc05hbWVzKSwgb25TZWxlY3Q6IG9uU2VsZWN0LCBzdHlsZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0Q29udGV4dFZhbHVlcy5zdHlsZXMpLCBpbml0aWFsUHJvcHMuc3R5bGVzKSwgdG9EYXRlOiB0b0RhdGUgfSk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goRGF5UGlja2VyQ29udGV4dC5Qcm92aWRlciwgX19hc3NpZ24oeyB2YWx1ZTogdmFsdWUgfSwgeyBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSkpKTtcbn1cbi8qKlxuICogSG9vayB0byBhY2Nlc3MgdGhlIHtAbGluayBEYXlQaWNrZXJDb250ZXh0VmFsdWV9LlxuICpcbiAqIFVzZSB0aGUgRGF5UGlja2VyIGNvbnRleHQgdG8gYWNjZXNzIHRvIHRoZSBwcm9wcyBwYXNzZWQgdG8gRGF5UGlja2VyIGluc2lkZVxuICogaW50ZXJuYWwgb3IgY3VzdG9tIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHVzZURheVBpY2tlcigpIHtcbiAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoRGF5UGlja2VyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVzZURheVBpY2tlciBtdXN0IGJlIHVzZWQgd2l0aGluIGEgRGF5UGlja2VyUHJvdmlkZXIuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cblxuLyoqIFJlbmRlciB0aGUgY2FwdGlvbiBmb3IgdGhlIGRpc3BsYXllZCBtb250aC4gVGhpcyBjb21wb25lbnQgaXMgdXNlZCB3aGVuIGBjYXB0aW9uTGF5b3V0PVwiYnV0dG9uc1wiYC4gKi9cbmZ1bmN0aW9uIENhcHRpb25MYWJlbChwcm9wcykge1xuICAgIHZhciBfYSA9IHVzZURheVBpY2tlcigpLCBsb2NhbGUgPSBfYS5sb2NhbGUsIGNsYXNzTmFtZXMgPSBfYS5jbGFzc05hbWVzLCBzdHlsZXMgPSBfYS5zdHlsZXMsIGZvcm1hdENhcHRpb24gPSBfYS5mb3JtYXR0ZXJzLmZvcm1hdENhcHRpb247XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuY2FwdGlvbl9sYWJlbCwgc3R5bGU6IHN0eWxlcy5jYXB0aW9uX2xhYmVsLCBcImFyaWEtbGl2ZVwiOiBcInBvbGl0ZVwiLCByb2xlOiBcInByZXNlbnRhdGlvblwiLCBpZDogcHJvcHMuaWQgfSwgeyBjaGlsZHJlbjogZm9ybWF0Q2FwdGlvbihwcm9wcy5kaXNwbGF5TW9udGgsIHsgbG9jYWxlOiBsb2NhbGUgfSkgfSkpKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIGljb24gaW4gdGhlIHN0eWxlZCBkcm9wLWRvd24uXG4gKi9cbmZ1bmN0aW9uIEljb25Ecm9wZG93bihwcm9wcykge1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwic3ZnXCIsIF9fYXNzaWduKHsgd2lkdGg6IFwiOHB4XCIsIGhlaWdodDogXCI4cHhcIiwgdmlld0JveDogXCIwIDAgMTIwIDEyMFwiLCBcImRhdGEtdGVzdGlkXCI6IFwiaWNvbkRyb3Bkb3duXCIgfSwgcHJvcHMsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk00LjIyMTgyNTQxLDQ4LjIyMTgyNTQgQzguNDQyMjI4MjgsNDQuMDAxNDIyNSAxNS4yMzg4NDk0LDQzLjkyNzM4MDQgMTkuNTQ5NjQ1OSw0Ny45OTk2OTg5IEwxOS43NzgxNzQ2LDQ4LjIyMTgyNTQgTDYwLDg4LjQ0MyBMMTAwLjIyMTgyNSw0OC4yMjE4MjU0IEMxMDQuNDQyMjI4LDQ0LjAwMTQyMjUgMTExLjIzODg0OSw0My45MjczODA0IDExNS41NDk2NDYsNDcuOTk5Njk4OSBMMTE1Ljc3ODE3NSw0OC4yMjE4MjU0IEMxMTkuOTk4NTc3LDUyLjQ0MjIyODMgMTIwLjA3MjYyLDU5LjIzODg0OTQgMTE2LjAwMDMwMSw2My41NDk2NDU5IEwxMTUuNzc4MTc1LDYzLjc3ODE3NDYgTDY3Ljc3ODE3NDYsMTExLjc3ODE3NSBDNjMuNTU3NzcxNywxMTUuOTk4NTc3IDU2Ljc2MTE1MDYsMTE2LjA3MjYyIDUyLjQ1MDM1NDEsMTEyLjAwMDMwMSBMNTIuMjIxODI1NCwxMTEuNzc4MTc1IEw0LjIyMTgyNTQxLDYzLjc3ODE3NDYgQy0wLjA3Mzk0MTgwMjMsNTkuNDgyNDA3NCAtMC4wNzM5NDE4MDIzLDUyLjUxNzU5MjYgNC4yMjE4MjU0MSw0OC4yMjE4MjU0IFpcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgZmlsbFJ1bGU6IFwibm9uemVyb1wiIH0pIH0pKSk7XG59XG5cbi8qKlxuICogUmVuZGVyIGEgc3R5bGVkIHNlbGVjdCBjb21wb25lbnQg4oCTIGRpc3BsYXlpbmcgYSBjYXB0aW9uIGFuZCBhIGN1c3RvbVxuICogZHJvcC1kb3duIGljb24uXG4gKi9cbmZ1bmN0aW9uIERyb3Bkb3duKHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSwgdmFsdWUgPSBwcm9wcy52YWx1ZSwgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbiwgY2FwdGlvbiA9IHByb3BzLmNhcHRpb24sIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSwgc3R5bGUgPSBwcm9wcy5zdHlsZTtcbiAgICB2YXIgZGF5UGlja2VyID0gdXNlRGF5UGlja2VyKCk7XG4gICAgdmFyIEljb25Ecm9wZG93bkNvbXBvbmVudCA9IChfYiA9IChfYSA9IGRheVBpY2tlci5jb21wb25lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuSWNvbkRyb3Bkb3duKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBJY29uRHJvcGRvd247XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHN0eWxlOiBzdHlsZSB9LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4KFwic3BhblwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogZGF5UGlja2VyLmNsYXNzTmFtZXMudmhpZGRlbiB9LCB7IGNoaWxkcmVuOiBwcm9wc1snYXJpYS1sYWJlbCddIH0pKSwganN4UnVudGltZUV4cG9ydHMuanN4KFwic2VsZWN0XCIsIF9fYXNzaWduKHsgbmFtZTogcHJvcHMubmFtZSwgXCJhcmlhLWxhYmVsXCI6IHByb3BzWydhcmlhLWxhYmVsJ10sIGNsYXNzTmFtZTogZGF5UGlja2VyLmNsYXNzTmFtZXMuZHJvcGRvd24sIHN0eWxlOiBkYXlQaWNrZXIuc3R5bGVzLmRyb3Bkb3duLCB2YWx1ZTogdmFsdWUsIG9uQ2hhbmdlOiBvbkNoYW5nZSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeHMoXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGRheVBpY2tlci5jbGFzc05hbWVzLmNhcHRpb25fbGFiZWwsIHN0eWxlOiBkYXlQaWNrZXIuc3R5bGVzLmNhcHRpb25fbGFiZWwsIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSwgeyBjaGlsZHJlbjogW2NhcHRpb24sIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChJY29uRHJvcGRvd25Db21wb25lbnQsIHsgY2xhc3NOYW1lOiBkYXlQaWNrZXIuY2xhc3NOYW1lcy5kcm9wZG93bl9pY29uLCBzdHlsZTogZGF5UGlja2VyLnN0eWxlcy5kcm9wZG93bl9pY29uIH0pXSB9KSldIH0pKSk7XG59XG5cbi8qKiBSZW5kZXIgdGhlIGRyb3Bkb3duIHRvIG5hdmlnYXRlIGJldHdlZW4gbW9udGhzLiAqL1xuZnVuY3Rpb24gTW9udGhzRHJvcGRvd24ocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iID0gdXNlRGF5UGlja2VyKCksIGZyb21EYXRlID0gX2IuZnJvbURhdGUsIHRvRGF0ZSA9IF9iLnRvRGF0ZSwgc3R5bGVzID0gX2Iuc3R5bGVzLCBsb2NhbGUgPSBfYi5sb2NhbGUsIGZvcm1hdE1vbnRoQ2FwdGlvbiA9IF9iLmZvcm1hdHRlcnMuZm9ybWF0TW9udGhDYXB0aW9uLCBjbGFzc05hbWVzID0gX2IuY2xhc3NOYW1lcywgY29tcG9uZW50cyA9IF9iLmNvbXBvbmVudHMsIGxhYmVsTW9udGhEcm9wZG93biA9IF9iLmxhYmVscy5sYWJlbE1vbnRoRHJvcGRvd247XG4gICAgLy8gRHJvcGRvd24gc2hvdWxkIGFwcGVhciBvbmx5IHdoZW4gYm90aCBmcm9tL3RvRGF0ZSBpcyBzZXRcbiAgICBpZiAoIWZyb21EYXRlKVxuICAgICAgICByZXR1cm4ganN4UnVudGltZUV4cG9ydHMuanN4KGpzeFJ1bnRpbWVFeHBvcnRzLkZyYWdtZW50LCB7fSk7XG4gICAgaWYgKCF0b0RhdGUpXG4gICAgICAgIHJldHVybiBqc3hSdW50aW1lRXhwb3J0cy5qc3goanN4UnVudGltZUV4cG9ydHMuRnJhZ21lbnQsIHt9KTtcbiAgICB2YXIgZHJvcGRvd25Nb250aHMgPSBbXTtcbiAgICBpZiAoaXNTYW1lWWVhcihmcm9tRGF0ZSwgdG9EYXRlKSkge1xuICAgICAgICAvLyBvbmx5IGRpc3BsYXkgdGhlIG1vbnRocyBpbmNsdWRlZCBpbiB0aGUgcmFuZ2VcbiAgICAgICAgdmFyIGRhdGUgPSBzdGFydE9mTW9udGgoZnJvbURhdGUpO1xuICAgICAgICBmb3IgKHZhciBtb250aCA9IGZyb21EYXRlLmdldE1vbnRoKCk7IG1vbnRoIDw9IHRvRGF0ZS5nZXRNb250aCgpOyBtb250aCsrKSB7XG4gICAgICAgICAgICBkcm9wZG93bk1vbnRocy5wdXNoKHNldE1vbnRoKGRhdGUsIG1vbnRoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGRpc3BsYXkgYWxsIHRoZSAxMiBtb250aHNcbiAgICAgICAgdmFyIGRhdGUgPSBzdGFydE9mTW9udGgobmV3IERhdGUoKSk7IC8vIEFueSBkYXRlIHNob3VsZCBiZSBPSywgYXMgd2UganVzdCBuZWVkIHRoZSB5ZWFyXG4gICAgICAgIGZvciAodmFyIG1vbnRoID0gMDsgbW9udGggPD0gMTE7IG1vbnRoKyspIHtcbiAgICAgICAgICAgIGRyb3Bkb3duTW9udGhzLnB1c2goc2V0TW9udGgoZGF0ZSwgbW9udGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkTW9udGggPSBOdW1iZXIoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICB2YXIgbmV3TW9udGggPSBzZXRNb250aChzdGFydE9mTW9udGgocHJvcHMuZGlzcGxheU1vbnRoKSwgc2VsZWN0ZWRNb250aCk7XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKG5ld01vbnRoKTtcbiAgICB9O1xuICAgIHZhciBEcm9wZG93bkNvbXBvbmVudCA9IChfYSA9IGNvbXBvbmVudHMgPT09IG51bGwgfHwgY29tcG9uZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50cy5Ecm9wZG93bikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRHJvcGRvd247XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goRHJvcGRvd25Db21wb25lbnQsIF9fYXNzaWduKHsgbmFtZTogXCJtb250aHNcIiwgXCJhcmlhLWxhYmVsXCI6IGxhYmVsTW9udGhEcm9wZG93bigpLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuZHJvcGRvd25fbW9udGgsIHN0eWxlOiBzdHlsZXMuZHJvcGRvd25fbW9udGgsIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsIHZhbHVlOiBwcm9wcy5kaXNwbGF5TW9udGguZ2V0TW9udGgoKSwgY2FwdGlvbjogZm9ybWF0TW9udGhDYXB0aW9uKHByb3BzLmRpc3BsYXlNb250aCwgeyBsb2NhbGU6IGxvY2FsZSB9KSB9LCB7IGNoaWxkcmVuOiBkcm9wZG93bk1vbnRocy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJvcHRpb25cIiwgX19hc3NpZ24oeyB2YWx1ZTogbS5nZXRNb250aCgpIH0sIHsgY2hpbGRyZW46IGZvcm1hdE1vbnRoQ2FwdGlvbihtLCB7IGxvY2FsZTogbG9jYWxlIH0pIH0pLCBtLmdldE1vbnRoKCkpKTsgfSkgfSkpKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSBkcm9wZG93biB0byBjaGFuZ2UgdGhlIHllYXIuIFRha2UgaW4gYWNjb3VudCB0aGUgYG5hdi5mcm9tRGF0ZWAgYW5kXG4gKiBgdG9EYXRlYCBmcm9tIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIFllYXJzRHJvcGRvd24ocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGRpc3BsYXlNb250aCA9IHByb3BzLmRpc3BsYXlNb250aDtcbiAgICB2YXIgX2IgPSB1c2VEYXlQaWNrZXIoKSwgZnJvbURhdGUgPSBfYi5mcm9tRGF0ZSwgdG9EYXRlID0gX2IudG9EYXRlLCBsb2NhbGUgPSBfYi5sb2NhbGUsIHN0eWxlcyA9IF9iLnN0eWxlcywgY2xhc3NOYW1lcyA9IF9iLmNsYXNzTmFtZXMsIGNvbXBvbmVudHMgPSBfYi5jb21wb25lbnRzLCBmb3JtYXRZZWFyQ2FwdGlvbiA9IF9iLmZvcm1hdHRlcnMuZm9ybWF0WWVhckNhcHRpb24sIGxhYmVsWWVhckRyb3Bkb3duID0gX2IubGFiZWxzLmxhYmVsWWVhckRyb3Bkb3duO1xuICAgIHZhciB5ZWFycyA9IFtdO1xuICAgIC8vIERyb3Bkb3duIHNob3VsZCBhcHBlYXIgb25seSB3aGVuIGJvdGggZnJvbS90b0RhdGUgaXMgc2V0XG4gICAgaWYgKCFmcm9tRGF0ZSlcbiAgICAgICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChqc3hSdW50aW1lRXhwb3J0cy5GcmFnbWVudCwge30pO1xuICAgIGlmICghdG9EYXRlKVxuICAgICAgICByZXR1cm4ganN4UnVudGltZUV4cG9ydHMuanN4KGpzeFJ1bnRpbWVFeHBvcnRzLkZyYWdtZW50LCB7fSk7XG4gICAgdmFyIGZyb21ZZWFyID0gZnJvbURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICB2YXIgdG9ZZWFyID0gdG9EYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgZm9yICh2YXIgeWVhciA9IGZyb21ZZWFyOyB5ZWFyIDw9IHRvWWVhcjsgeWVhcisrKSB7XG4gICAgICAgIHllYXJzLnB1c2goc2V0WWVhcihzdGFydE9mWWVhcihuZXcgRGF0ZSgpKSwgeWVhcikpO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG5ld01vbnRoID0gc2V0WWVhcihzdGFydE9mTW9udGgoZGlzcGxheU1vbnRoKSwgTnVtYmVyKGUudGFyZ2V0LnZhbHVlKSk7XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKG5ld01vbnRoKTtcbiAgICB9O1xuICAgIHZhciBEcm9wZG93bkNvbXBvbmVudCA9IChfYSA9IGNvbXBvbmVudHMgPT09IG51bGwgfHwgY29tcG9uZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50cy5Ecm9wZG93bikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRHJvcGRvd247XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goRHJvcGRvd25Db21wb25lbnQsIF9fYXNzaWduKHsgbmFtZTogXCJ5ZWFyc1wiLCBcImFyaWEtbGFiZWxcIjogbGFiZWxZZWFyRHJvcGRvd24oKSwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmRyb3Bkb3duX3llYXIsIHN0eWxlOiBzdHlsZXMuZHJvcGRvd25feWVhciwgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSwgdmFsdWU6IGRpc3BsYXlNb250aC5nZXRGdWxsWWVhcigpLCBjYXB0aW9uOiBmb3JtYXRZZWFyQ2FwdGlvbihkaXNwbGF5TW9udGgsIHsgbG9jYWxlOiBsb2NhbGUgfSkgfSwgeyBjaGlsZHJlbjogeWVhcnMubWFwKGZ1bmN0aW9uICh5ZWFyKSB7IHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwib3B0aW9uXCIsIF9fYXNzaWduKHsgdmFsdWU6IHllYXIuZ2V0RnVsbFllYXIoKSB9LCB7IGNoaWxkcmVuOiBmb3JtYXRZZWFyQ2FwdGlvbih5ZWFyLCB7IGxvY2FsZTogbG9jYWxlIH0pIH0pLCB5ZWFyLmdldEZ1bGxZZWFyKCkpKTsgfSkgfSkpKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgaG9vayBmb3IgdXNpbmcgY29udHJvbGxlZC91bmNvbnRyb2xsZWQgdmFsdWVzIGZyb20gYSBjb21wb25lbnQgcHJvcHMuXG4gKlxuICogV2hlbiB0aGUgdmFsdWUgaXMgbm90IGNvbnRyb2xsZWQsIHBhc3MgYHVuZGVmaW5lZGAgYXMgYGNvbnRyb2xsZWRWYWx1ZWAgYW5kXG4gKiB1c2UgdGhlIHJldHVybmVkIHNldHRlciB0byB1cGRhdGUgaXQuXG4gKlxuICogV2hlbiB0aGUgdmFsdWUgaXMgY29udHJvbGxlZCwgcGFzcyB0aGUgY29udHJvbGxlZCB2YWx1ZSBhcyBzZWNvbmRcbiAqIGFyZ3VtZW50LCB3aGljaCB3aWxsIGJlIGFsd2F5cyByZXR1cm5lZCBhcyBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiB1c2VDb250cm9sbGVkVmFsdWUoZGVmYXVsdFZhbHVlLCBjb250cm9sbGVkVmFsdWUpIHtcbiAgICB2YXIgX2EgPSB1c2VTdGF0ZShkZWZhdWx0VmFsdWUpLCB1bmNvbnRyb2xsZWRWYWx1ZSA9IF9hWzBdLCBzZXRWYWx1ZSA9IF9hWzFdO1xuICAgIHZhciB2YWx1ZSA9IGNvbnRyb2xsZWRWYWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5jb250cm9sbGVkVmFsdWUgOiBjb250cm9sbGVkVmFsdWU7XG4gICAgcmV0dXJuIFt2YWx1ZSwgc2V0VmFsdWVdO1xufVxuXG4vKiogUmV0dXJuIHRoZSBpbml0aWFsIG1vbnRoIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucy4gKi9cbmZ1bmN0aW9uIGdldEluaXRpYWxNb250aChjb250ZXh0KSB7XG4gICAgdmFyIG1vbnRoID0gY29udGV4dC5tb250aCwgZGVmYXVsdE1vbnRoID0gY29udGV4dC5kZWZhdWx0TW9udGgsIHRvZGF5ID0gY29udGV4dC50b2RheTtcbiAgICB2YXIgaW5pdGlhbE1vbnRoID0gbW9udGggfHwgZGVmYXVsdE1vbnRoIHx8IHRvZGF5IHx8IG5ldyBEYXRlKCk7XG4gICAgdmFyIHRvRGF0ZSA9IGNvbnRleHQudG9EYXRlLCBmcm9tRGF0ZSA9IGNvbnRleHQuZnJvbURhdGUsIF9hID0gY29udGV4dC5udW1iZXJPZk1vbnRocywgbnVtYmVyT2ZNb250aHMgPSBfYSA9PT0gdm9pZCAwID8gMSA6IF9hO1xuICAgIC8vIEZpeCB0aGUgaW5pdGlhbE1vbnRoIGlmIGlzIGFmdGVyIHRoZSB0by1kYXRlXG4gICAgaWYgKHRvRGF0ZSAmJiBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyh0b0RhdGUsIGluaXRpYWxNb250aCkgPCAwKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSAtMSAqIChudW1iZXJPZk1vbnRocyAtIDEpO1xuICAgICAgICBpbml0aWFsTW9udGggPSBhZGRNb250aHModG9EYXRlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvLyBGaXggdGhlIGluaXRpYWxNb250aCBpZiBpcyBiZWZvcmUgdGhlIGZyb20tZGF0ZVxuICAgIGlmIChmcm9tRGF0ZSAmJiBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyhpbml0aWFsTW9udGgsIGZyb21EYXRlKSA8IDApIHtcbiAgICAgICAgaW5pdGlhbE1vbnRoID0gZnJvbURhdGU7XG4gICAgfVxuICAgIHJldHVybiBzdGFydE9mTW9udGgoaW5pdGlhbE1vbnRoKTtcbn1cblxuLyoqIENvbnRyb2xzIHRoZSBuYXZpZ2F0aW9uIHN0YXRlLiAqL1xuZnVuY3Rpb24gdXNlTmF2aWdhdGlvblN0YXRlKCkge1xuICAgIHZhciBjb250ZXh0ID0gdXNlRGF5UGlja2VyKCk7XG4gICAgdmFyIGluaXRpYWxNb250aCA9IGdldEluaXRpYWxNb250aChjb250ZXh0KTtcbiAgICB2YXIgX2EgPSB1c2VDb250cm9sbGVkVmFsdWUoaW5pdGlhbE1vbnRoLCBjb250ZXh0Lm1vbnRoKSwgbW9udGggPSBfYVswXSwgc2V0TW9udGggPSBfYVsxXTtcbiAgICB2YXIgZ29Ub01vbnRoID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoY29udGV4dC5kaXNhYmxlTmF2aWdhdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG1vbnRoID0gc3RhcnRPZk1vbnRoKGRhdGUpO1xuICAgICAgICBzZXRNb250aChtb250aCk7XG4gICAgICAgIChfYSA9IGNvbnRleHQub25Nb250aENoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY29udGV4dCwgbW9udGgpO1xuICAgIH07XG4gICAgcmV0dXJuIFttb250aCwgZ29Ub01vbnRoXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1vbnRocyB0byBkaXNwbGF5IGluIHRoZSBjb21wb25lbnQgYWNjb3JkaW5nIHRvIHRoZSBudW1iZXIgb2ZcbiAqIG1vbnRocyBhbmQgdGhlIGZyb20vdG8gZGF0ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGlzcGxheU1vbnRocyhtb250aCwgX2EpIHtcbiAgICB2YXIgcmV2ZXJzZU1vbnRocyA9IF9hLnJldmVyc2VNb250aHMsIG51bWJlck9mTW9udGhzID0gX2EubnVtYmVyT2ZNb250aHM7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRPZk1vbnRoKG1vbnRoKTtcbiAgICB2YXIgZW5kID0gc3RhcnRPZk1vbnRoKGFkZE1vbnRocyhzdGFydCwgbnVtYmVyT2ZNb250aHMpKTtcbiAgICB2YXIgbW9udGhzRGlmZiA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzKGVuZCwgc3RhcnQpO1xuICAgIHZhciBtb250aHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vbnRoc0RpZmY7IGkrKykge1xuICAgICAgICB2YXIgbmV4dE1vbnRoID0gYWRkTW9udGhzKHN0YXJ0LCBpKTtcbiAgICAgICAgbW9udGhzLnB1c2gobmV4dE1vbnRoKTtcbiAgICB9XG4gICAgaWYgKHJldmVyc2VNb250aHMpXG4gICAgICAgIG1vbnRocyA9IG1vbnRocy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIG1vbnRocztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IG1vbnRoIHRoZSB1c2VyIGNhbiBuYXZpZ2F0ZSB0byBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuXG4gKiBvcHRpb25zLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG5leHQgbW9udGggaXMgbm90IGFsd2F5cyB0aGUgbmV4dCBjYWxlbmRhciBtb250aDpcbiAqXG4gKiAtIGlmIGFmdGVyIHRoZSBgdG9EYXRlYCByYW5nZSwgaXMgdW5kZWZpbmVkO1xuICogLSBpZiB0aGUgbmF2aWdhdGlvbiBpcyBwYWdlZCwgaXMgdGhlIG51bWJlciBvZiBtb250aHMgZGlzcGxheWVkIGFoZWFkLlxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dE1vbnRoKHN0YXJ0aW5nTW9udGgsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kaXNhYmxlTmF2aWdhdGlvbikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgdG9EYXRlID0gb3B0aW9ucy50b0RhdGUsIHBhZ2VkTmF2aWdhdGlvbiA9IG9wdGlvbnMucGFnZWROYXZpZ2F0aW9uLCBfYSA9IG9wdGlvbnMubnVtYmVyT2ZNb250aHMsIG51bWJlck9mTW9udGhzID0gX2EgPT09IHZvaWQgMCA/IDEgOiBfYTtcbiAgICB2YXIgb2Zmc2V0ID0gcGFnZWROYXZpZ2F0aW9uID8gbnVtYmVyT2ZNb250aHMgOiAxO1xuICAgIHZhciBtb250aCA9IHN0YXJ0T2ZNb250aChzdGFydGluZ01vbnRoKTtcbiAgICBpZiAoIXRvRGF0ZSkge1xuICAgICAgICByZXR1cm4gYWRkTW9udGhzKG1vbnRoLCBvZmZzZXQpO1xuICAgIH1cbiAgICB2YXIgbW9udGhzRGlmZiA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzKHRvRGF0ZSwgc3RhcnRpbmdNb250aCk7XG4gICAgaWYgKG1vbnRoc0RpZmYgPCBudW1iZXJPZk1vbnRocykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBKdW1wIGZvcndhcmQgYXMgdGhlIG51bWJlciBvZiBtb250aHMgd2hlbiBwYWdlZCBuYXZpZ2F0aW9uXG4gICAgcmV0dXJuIGFkZE1vbnRocyhtb250aCwgb2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IHByZXZpb3VzIHRoZSB1c2VyIGNhbiBuYXZpZ2F0ZSB0bywgYWNjb3JkaW5nIHRvIHRoZSBnaXZlblxuICogb3B0aW9ucy5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBwcmV2aW91cyBtb250aCBpcyBub3QgYWx3YXlzIHRoZSBwcmV2aW91cyBjYWxlbmRhclxuICogbW9udGg6XG4gKlxuICogLSBpZiBiZWZvcmUgdGhlIGBmcm9tRGF0ZWAgZGF0ZSwgaXMgYHVuZGVmaW5lZGA7XG4gKiAtIGlmIHRoZSBuYXZpZ2F0aW9uIGlzIHBhZ2VkLCBpcyB0aGUgbnVtYmVyIG9mIG1vbnRocyBkaXNwbGF5ZWQgYmVmb3JlLlxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0UHJldmlvdXNNb250aChzdGFydGluZ01vbnRoLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZGlzYWJsZU5hdmlnYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGZyb21EYXRlID0gb3B0aW9ucy5mcm9tRGF0ZSwgcGFnZWROYXZpZ2F0aW9uID0gb3B0aW9ucy5wYWdlZE5hdmlnYXRpb24sIF9hID0gb3B0aW9ucy5udW1iZXJPZk1vbnRocywgbnVtYmVyT2ZNb250aHMgPSBfYSA9PT0gdm9pZCAwID8gMSA6IF9hO1xuICAgIHZhciBvZmZzZXQgPSBwYWdlZE5hdmlnYXRpb24gPyBudW1iZXJPZk1vbnRocyA6IDE7XG4gICAgdmFyIG1vbnRoID0gc3RhcnRPZk1vbnRoKHN0YXJ0aW5nTW9udGgpO1xuICAgIGlmICghZnJvbURhdGUpIHtcbiAgICAgICAgcmV0dXJuIGFkZE1vbnRocyhtb250aCwgLW9mZnNldCk7XG4gICAgfVxuICAgIHZhciBtb250aHNEaWZmID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMobW9udGgsIGZyb21EYXRlKTtcbiAgICBpZiAobW9udGhzRGlmZiA8PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEp1bXAgYmFjayBhcyB0aGUgbnVtYmVyIG9mIG1vbnRocyB3aGVuIHBhZ2VkIG5hdmlnYXRpb25cbiAgICByZXR1cm4gYWRkTW9udGhzKG1vbnRoLCAtb2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBUaGUgTmF2aWdhdGlvbiBjb250ZXh0IHNoYXJlcyBkZXRhaWxzIGFuZCBtZXRob2RzIHRvIG5hdmlnYXRlIHRoZSBtb250aHMgaW4gRGF5UGlja2VyLlxuICogQWNjZXNzIHRoaXMgY29udGV4dCBmcm9tIHRoZSB7QGxpbmsgdXNlTmF2aWdhdGlvbn0gaG9vay5cbiAqL1xudmFyIE5hdmlnYXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuLyoqIFByb3ZpZGVzIHRoZSB2YWx1ZXMgZm9yIHRoZSB7QGxpbmsgTmF2aWdhdGlvbkNvbnRleHR9LiAqL1xuZnVuY3Rpb24gTmF2aWdhdGlvblByb3ZpZGVyKHByb3BzKSB7XG4gICAgdmFyIGRheVBpY2tlciA9IHVzZURheVBpY2tlcigpO1xuICAgIHZhciBfYSA9IHVzZU5hdmlnYXRpb25TdGF0ZSgpLCBjdXJyZW50TW9udGggPSBfYVswXSwgZ29Ub01vbnRoID0gX2FbMV07XG4gICAgdmFyIGRpc3BsYXlNb250aHMgPSBnZXREaXNwbGF5TW9udGhzKGN1cnJlbnRNb250aCwgZGF5UGlja2VyKTtcbiAgICB2YXIgbmV4dE1vbnRoID0gZ2V0TmV4dE1vbnRoKGN1cnJlbnRNb250aCwgZGF5UGlja2VyKTtcbiAgICB2YXIgcHJldmlvdXNNb250aCA9IGdldFByZXZpb3VzTW9udGgoY3VycmVudE1vbnRoLCBkYXlQaWNrZXIpO1xuICAgIHZhciBpc0RhdGVEaXNwbGF5ZWQgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGlzcGxheU1vbnRocy5zb21lKGZ1bmN0aW9uIChkaXNwbGF5TW9udGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChkYXRlLCBkaXNwbGF5TW9udGgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBnb1RvRGF0ZSA9IGZ1bmN0aW9uIChkYXRlLCByZWZEYXRlKSB7XG4gICAgICAgIGlmIChpc0RhdGVEaXNwbGF5ZWQoZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmRGF0ZSAmJiBpc0JlZm9yZShkYXRlLCByZWZEYXRlKSkge1xuICAgICAgICAgICAgZ29Ub01vbnRoKGFkZE1vbnRocyhkYXRlLCAxICsgZGF5UGlja2VyLm51bWJlck9mTW9udGhzICogLTEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdvVG9Nb250aChkYXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHZhbHVlID0ge1xuICAgICAgICBjdXJyZW50TW9udGg6IGN1cnJlbnRNb250aCxcbiAgICAgICAgZGlzcGxheU1vbnRoczogZGlzcGxheU1vbnRocyxcbiAgICAgICAgZ29Ub01vbnRoOiBnb1RvTW9udGgsXG4gICAgICAgIGdvVG9EYXRlOiBnb1RvRGF0ZSxcbiAgICAgICAgcHJldmlvdXNNb250aDogcHJldmlvdXNNb250aCxcbiAgICAgICAgbmV4dE1vbnRoOiBuZXh0TW9udGgsXG4gICAgICAgIGlzRGF0ZURpc3BsYXllZDogaXNEYXRlRGlzcGxheWVkXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChOYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlciwgX19hc3NpZ24oeyB2YWx1ZTogdmFsdWUgfSwgeyBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSkpKTtcbn1cbi8qKlxuICogSG9vayB0byBhY2Nlc3MgdGhlIHtAbGluayBOYXZpZ2F0aW9uQ29udGV4dFZhbHVlfS4gVXNlIHRoaXMgaG9vayB0byBuYXZpZ2F0ZVxuICogYmV0d2VlbiBtb250aHMgb3IgeWVhcnMgaW4gRGF5UGlja2VyLlxuICpcbiAqIFRoaXMgaG9vayBpcyBtZWFudCB0byBiZSB1c2VkIGluc2lkZSBpbnRlcm5hbCBvciBjdXN0b20gY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gdXNlTmF2aWdhdGlvbigpIHtcbiAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZU5hdmlnYXRpb24gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIE5hdmlnYXRpb25Qcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSBjYXB0aW9uIHdpdGggdGhlIGRyb3Bkb3ducyB0byBuYXZpZ2F0ZSBiZXR3ZWVuIG1vbnRocyBhbmQgeWVhcnMuXG4gKi9cbmZ1bmN0aW9uIENhcHRpb25Ecm9wZG93bnMocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iID0gdXNlRGF5UGlja2VyKCksIGNsYXNzTmFtZXMgPSBfYi5jbGFzc05hbWVzLCBzdHlsZXMgPSBfYi5zdHlsZXMsIGNvbXBvbmVudHMgPSBfYi5jb21wb25lbnRzO1xuICAgIHZhciBnb1RvTW9udGggPSB1c2VOYXZpZ2F0aW9uKCkuZ29Ub01vbnRoO1xuICAgIHZhciBoYW5kbGVNb250aENoYW5nZSA9IGZ1bmN0aW9uIChuZXdNb250aCkge1xuICAgICAgICBnb1RvTW9udGgoYWRkTW9udGhzKG5ld01vbnRoLCBwcm9wcy5kaXNwbGF5SW5kZXggPyAtcHJvcHMuZGlzcGxheUluZGV4IDogMCkpO1xuICAgIH07XG4gICAgdmFyIENhcHRpb25MYWJlbENvbXBvbmVudCA9IChfYSA9IGNvbXBvbmVudHMgPT09IG51bGwgfHwgY29tcG9uZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50cy5DYXB0aW9uTGFiZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENhcHRpb25MYWJlbDtcbiAgICB2YXIgY2FwdGlvbkxhYmVsID0gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChDYXB0aW9uTGFiZWxDb21wb25lbnQsIHsgaWQ6IHByb3BzLmlkLCBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCB9KSk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNhcHRpb25fZHJvcGRvd25zLCBzdHlsZTogc3R5bGVzLmNhcHRpb25fZHJvcGRvd25zIH0sIHsgY2hpbGRyZW46IFtqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMudmhpZGRlbiB9LCB7IGNoaWxkcmVuOiBjYXB0aW9uTGFiZWwgfSkpLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goTW9udGhzRHJvcGRvd24sIHsgb25DaGFuZ2U6IGhhbmRsZU1vbnRoQ2hhbmdlLCBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFllYXJzRHJvcGRvd24sIHsgb25DaGFuZ2U6IGhhbmRsZU1vbnRoQ2hhbmdlLCBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCB9KV0gfSkpKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIFwicHJldmlvdXMgbW9udGhcIiBidXR0b24gaW4gdGhlIG5hdmlnYXRpb24uXG4gKi9cbmZ1bmN0aW9uIEljb25MZWZ0KHByb3BzKSB7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJzdmdcIiwgX19hc3NpZ24oeyB3aWR0aDogXCIxNnB4XCIsIGhlaWdodDogXCIxNnB4XCIsIHZpZXdCb3g6IFwiMCAwIDEyMCAxMjBcIiB9LCBwcm9wcywgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTTY5LjQ5MDMzMiwzLjM0MzE0NTc1IEM3Mi42MTQ1MjYzLDAuMjE4OTUxNDE2IDc3LjY3OTg0NjIsMC4yMTg5NTE0MTYgODAuODA0MDQwNSwzLjM0MzE0NTc1IEM4My44NjE3NjI2LDYuNDAwODY3ODYgODMuOTI2ODIwNSwxMS4zMTc5OTMxIDgwLjk5OTIxNDMsMTQuNDU0ODM4OCBMODAuODA0MDQwNSwxNC42NTY4NTQyIEwzNS40NjEsNjAgTDgwLjgwNDA0MDUsMTA1LjM0MzE0NiBDODMuODYxNzYyNiwxMDguNDAwODY4IDgzLjkyNjgyMDUsMTEzLjMxNzk5MyA4MC45OTkyMTQzLDExNi40NTQ4MzkgTDgwLjgwNDA0MDUsMTE2LjY1Njg1NCBDNzcuNzQ2MzE4NCwxMTkuNzE0NTc2IDcyLjgyOTE5MzEsMTE5Ljc3OTYzNCA2OS42OTIzNDc1LDExNi44NTIwMjggTDY5LjQ5MDMzMiwxMTYuNjU2ODU0IEwxOC40OTAzMzIsNjUuNjU2ODU0MiBDMTUuNDMyNjA5OSw2Mi41OTkxMzIxIDE1LjM2NzU1Miw1Ny42ODIwMDY5IDE4LjI5NTE1ODMsNTQuNTQ1MTYxMiBMMTguNDkwMzMyLDU0LjM0MzE0NTggTDY5LjQ5MDMzMiwzLjM0MzE0NTc1IFpcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgZmlsbFJ1bGU6IFwibm9uemVyb1wiIH0pIH0pKSk7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSBcIm5leHQgbW9udGhcIiBidXR0b24gaW4gdGhlIG5hdmlnYXRpb24uXG4gKi9cbmZ1bmN0aW9uIEljb25SaWdodChwcm9wcykge1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwic3ZnXCIsIF9fYXNzaWduKHsgd2lkdGg6IFwiMTZweFwiLCBoZWlnaHQ6IFwiMTZweFwiLCB2aWV3Qm94OiBcIjAgMCAxMjAgMTIwXCIgfSwgcHJvcHMsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk00OS44MDQwNDA1LDMuMzQzMTQ1NzUgQzQ2LjY3OTg0NjIsMC4yMTg5NTE0MTYgNDEuNjE0NTI2MywwLjIxODk1MTQxNiAzOC40OTAzMzIsMy4zNDMxNDU3NSBDMzUuNDMyNjA5OSw2LjQwMDg2Nzg2IDM1LjM2NzU1MiwxMS4zMTc5OTMxIDM4LjI5NTE1ODMsMTQuNDU0ODM4OCBMMzguNDkwMzMyLDE0LjY1Njg1NDIgTDgzLjgzMzM3MjUsNjAgTDM4LjQ5MDMzMiwxMDUuMzQzMTQ2IEMzNS40MzI2MDk5LDEwOC40MDA4NjggMzUuMzY3NTUyLDExMy4zMTc5OTMgMzguMjk1MTU4MywxMTYuNDU0ODM5IEwzOC40OTAzMzIsMTE2LjY1Njg1NCBDNDEuNTQ4MDU0MSwxMTkuNzE0NTc2IDQ2LjQ2NTE3OTQsMTE5Ljc3OTYzNCA0OS42MDIwMjUsMTE2Ljg1MjAyOCBMNDkuODA0MDQwNSwxMTYuNjU2ODU0IEwxMDAuODA0MDQxLDY1LjY1Njg1NDIgQzEwMy44NjE3NjMsNjIuNTk5MTMyMSAxMDMuOTI2ODIxLDU3LjY4MjAwNjkgMTAwLjk5OTIxNCw1NC41NDUxNjEyIEwxMDAuODA0MDQxLDU0LjM0MzE0NTggTDQ5LjgwNDA0MDUsMy4zNDMxNDU3NSBaXCIsIGZpbGw6IFwiY3VycmVudENvbG9yXCIgfSkgfSkpKTtcbn1cblxuLyoqIFJlbmRlciBhIGJ1dHRvbiBIVE1MIGVsZW1lbnQgYXBwbHlpbmcgdGhlIHJlc2V0IGNsYXNzIG5hbWUuICovXG52YXIgQnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHZhciBfYSA9IHVzZURheVBpY2tlcigpLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcywgc3R5bGVzID0gX2Euc3R5bGVzO1xuICAgIHZhciBjbGFzc05hbWVzQXJyID0gW2NsYXNzTmFtZXMuYnV0dG9uX3Jlc2V0LCBjbGFzc05hbWVzLmJ1dHRvbl07XG4gICAgaWYgKHByb3BzLmNsYXNzTmFtZSkge1xuICAgICAgICBjbGFzc05hbWVzQXJyLnB1c2gocHJvcHMuY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNBcnIuam9pbignICcpO1xuICAgIHZhciBzdHlsZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZXMuYnV0dG9uX3Jlc2V0KSwgc3R5bGVzLmJ1dHRvbik7XG4gICAgaWYgKHByb3BzLnN0eWxlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHByb3BzLnN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJidXR0b25cIiwgX19hc3NpZ24oe30sIHByb3BzLCB7IHJlZjogcmVmLCB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlIH0pKSk7XG59KTtcblxuLyoqIEEgY29tcG9uZW50IHJlbmRlcmluZyB0aGUgbmF2aWdhdGlvbiBidXR0b25zIG9yIHRoZSBkcm9wLWRvd25zLiAqL1xuZnVuY3Rpb24gTmF2aWdhdGlvbihwcm9wcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIF9jID0gdXNlRGF5UGlja2VyKCksIGRpciA9IF9jLmRpciwgbG9jYWxlID0gX2MubG9jYWxlLCBjbGFzc05hbWVzID0gX2MuY2xhc3NOYW1lcywgc3R5bGVzID0gX2Muc3R5bGVzLCBfZCA9IF9jLmxhYmVscywgbGFiZWxQcmV2aW91cyA9IF9kLmxhYmVsUHJldmlvdXMsIGxhYmVsTmV4dCA9IF9kLmxhYmVsTmV4dCwgY29tcG9uZW50cyA9IF9jLmNvbXBvbmVudHM7XG4gICAgaWYgKCFwcm9wcy5uZXh0TW9udGggJiYgIXByb3BzLnByZXZpb3VzTW9udGgpIHtcbiAgICAgICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChqc3hSdW50aW1lRXhwb3J0cy5GcmFnbWVudCwge30pO1xuICAgIH1cbiAgICB2YXIgcHJldmlvdXNMYWJlbCA9IGxhYmVsUHJldmlvdXMocHJvcHMucHJldmlvdXNNb250aCwgeyBsb2NhbGU6IGxvY2FsZSB9KTtcbiAgICB2YXIgcHJldmlvdXNDbGFzc05hbWUgPSBbXG4gICAgICAgIGNsYXNzTmFtZXMubmF2X2J1dHRvbixcbiAgICAgICAgY2xhc3NOYW1lcy5uYXZfYnV0dG9uX3ByZXZpb3VzXG4gICAgXS5qb2luKCcgJyk7XG4gICAgdmFyIG5leHRMYWJlbCA9IGxhYmVsTmV4dChwcm9wcy5uZXh0TW9udGgsIHsgbG9jYWxlOiBsb2NhbGUgfSk7XG4gICAgdmFyIG5leHRDbGFzc05hbWUgPSBbXG4gICAgICAgIGNsYXNzTmFtZXMubmF2X2J1dHRvbixcbiAgICAgICAgY2xhc3NOYW1lcy5uYXZfYnV0dG9uX25leHRcbiAgICBdLmpvaW4oJyAnKTtcbiAgICB2YXIgSWNvblJpZ2h0Q29tcG9uZW50ID0gKF9hID0gY29tcG9uZW50cyA9PT0gbnVsbCB8fCBjb21wb25lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzLkljb25SaWdodCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSWNvblJpZ2h0O1xuICAgIHZhciBJY29uTGVmdENvbXBvbmVudCA9IChfYiA9IGNvbXBvbmVudHMgPT09IG51bGwgfHwgY29tcG9uZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50cy5JY29uTGVmdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogSWNvbkxlZnQ7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZGl2XCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLm5hdiwgc3R5bGU6IHN0eWxlcy5uYXYgfSwgeyBjaGlsZHJlbjogWyFwcm9wcy5oaWRlUHJldmlvdXMgJiYgKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChCdXR0b24sIF9fYXNzaWduKHsgbmFtZTogXCJwcmV2aW91cy1tb250aFwiLCBcImFyaWEtbGFiZWxcIjogcHJldmlvdXNMYWJlbCwgY2xhc3NOYW1lOiBwcmV2aW91c0NsYXNzTmFtZSwgc3R5bGU6IHN0eWxlcy5uYXZfYnV0dG9uX3ByZXZpb3VzLCBkaXNhYmxlZDogIXByb3BzLnByZXZpb3VzTW9udGgsIG9uQ2xpY2s6IHByb3BzLm9uUHJldmlvdXNDbGljayB9LCB7IGNoaWxkcmVuOiBkaXIgPT09ICdydGwnID8gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChJY29uUmlnaHRDb21wb25lbnQsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLm5hdl9pY29uLCBzdHlsZTogc3R5bGVzLm5hdl9pY29uIH0pKSA6IChqc3hSdW50aW1lRXhwb3J0cy5qc3goSWNvbkxlZnRDb21wb25lbnQsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLm5hdl9pY29uLCBzdHlsZTogc3R5bGVzLm5hdl9pY29uIH0pKSB9KSkpLCAhcHJvcHMuaGlkZU5leHQgJiYgKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChCdXR0b24sIF9fYXNzaWduKHsgbmFtZTogXCJuZXh0LW1vbnRoXCIsIFwiYXJpYS1sYWJlbFwiOiBuZXh0TGFiZWwsIGNsYXNzTmFtZTogbmV4dENsYXNzTmFtZSwgc3R5bGU6IHN0eWxlcy5uYXZfYnV0dG9uX25leHQsIGRpc2FibGVkOiAhcHJvcHMubmV4dE1vbnRoLCBvbkNsaWNrOiBwcm9wcy5vbk5leHRDbGljayB9LCB7IGNoaWxkcmVuOiBkaXIgPT09ICdydGwnID8gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChJY29uTGVmdENvbXBvbmVudCwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMubmF2X2ljb24sIHN0eWxlOiBzdHlsZXMubmF2X2ljb24gfSkpIDogKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChJY29uUmlnaHRDb21wb25lbnQsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLm5hdl9pY29uLCBzdHlsZTogc3R5bGVzLm5hdl9pY29uIH0pKSB9KSkpXSB9KSkpO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIGNhcHRpb24gd2l0aCBhIGJ1dHRvbi1iYXNlZCBuYXZpZ2F0aW9uLlxuICovXG5mdW5jdGlvbiBDYXB0aW9uTmF2aWdhdGlvbihwcm9wcykge1xuICAgIHZhciBudW1iZXJPZk1vbnRocyA9IHVzZURheVBpY2tlcigpLm51bWJlck9mTW9udGhzO1xuICAgIHZhciBfYSA9IHVzZU5hdmlnYXRpb24oKSwgcHJldmlvdXNNb250aCA9IF9hLnByZXZpb3VzTW9udGgsIG5leHRNb250aCA9IF9hLm5leHRNb250aCwgZ29Ub01vbnRoID0gX2EuZ29Ub01vbnRoLCBkaXNwbGF5TW9udGhzID0gX2EuZGlzcGxheU1vbnRocztcbiAgICB2YXIgZGlzcGxheUluZGV4ID0gZGlzcGxheU1vbnRocy5maW5kSW5kZXgoZnVuY3Rpb24gKG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBpc1NhbWVNb250aChwcm9wcy5kaXNwbGF5TW9udGgsIG1vbnRoKTtcbiAgICB9KTtcbiAgICB2YXIgaXNGaXJzdCA9IGRpc3BsYXlJbmRleCA9PT0gMDtcbiAgICB2YXIgaXNMYXN0ID0gZGlzcGxheUluZGV4ID09PSBkaXNwbGF5TW9udGhzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGhpZGVOZXh0ID0gbnVtYmVyT2ZNb250aHMgPiAxICYmIChpc0ZpcnN0IHx8ICFpc0xhc3QpO1xuICAgIHZhciBoaWRlUHJldmlvdXMgPSBudW1iZXJPZk1vbnRocyA+IDEgJiYgKGlzTGFzdCB8fCAhaXNGaXJzdCk7XG4gICAgdmFyIGhhbmRsZVByZXZpb3VzQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcHJldmlvdXNNb250aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZ29Ub01vbnRoKHByZXZpb3VzTW9udGgpO1xuICAgIH07XG4gICAgdmFyIGhhbmRsZU5leHRDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFuZXh0TW9udGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGdvVG9Nb250aChuZXh0TW9udGgpO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goTmF2aWdhdGlvbiwgeyBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCwgaGlkZU5leHQ6IGhpZGVOZXh0LCBoaWRlUHJldmlvdXM6IGhpZGVQcmV2aW91cywgbmV4dE1vbnRoOiBuZXh0TW9udGgsIHByZXZpb3VzTW9udGg6IHByZXZpb3VzTW9udGgsIG9uUHJldmlvdXNDbGljazogaGFuZGxlUHJldmlvdXNDbGljaywgb25OZXh0Q2xpY2s6IGhhbmRsZU5leHRDbGljayB9KSk7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSBjYXB0aW9uIG9mIGEgbW9udGguIFRoZSBjYXB0aW9uIGhhcyBhIGRpZmZlcmVudCBsYXlvdXQgd2hlblxuICogc2V0dGluZyB0aGUge0BsaW5rIERheVBpY2tlckJhc2UuY2FwdGlvbkxheW91dH0gcHJvcC5cbiAqL1xuZnVuY3Rpb24gQ2FwdGlvbihwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX2IgPSB1c2VEYXlQaWNrZXIoKSwgY2xhc3NOYW1lcyA9IF9iLmNsYXNzTmFtZXMsIGRpc2FibGVOYXZpZ2F0aW9uID0gX2IuZGlzYWJsZU5hdmlnYXRpb24sIHN0eWxlcyA9IF9iLnN0eWxlcywgY2FwdGlvbkxheW91dCA9IF9iLmNhcHRpb25MYXlvdXQsIGNvbXBvbmVudHMgPSBfYi5jb21wb25lbnRzO1xuICAgIHZhciBDYXB0aW9uTGFiZWxDb21wb25lbnQgPSAoX2EgPSBjb21wb25lbnRzID09PSBudWxsIHx8IGNvbXBvbmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudHMuQ2FwdGlvbkxhYmVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDYXB0aW9uTGFiZWw7XG4gICAgdmFyIGNhcHRpb247XG4gICAgaWYgKGRpc2FibGVOYXZpZ2F0aW9uKSB7XG4gICAgICAgIGNhcHRpb24gPSAoanN4UnVudGltZUV4cG9ydHMuanN4KENhcHRpb25MYWJlbENvbXBvbmVudCwgeyBpZDogcHJvcHMuaWQsIGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoIH0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FwdGlvbkxheW91dCA9PT0gJ2Ryb3Bkb3duJykge1xuICAgICAgICBjYXB0aW9uID0gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChDYXB0aW9uRHJvcGRvd25zLCB7IGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoLCBpZDogcHJvcHMuaWQgfSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYXB0aW9uTGF5b3V0ID09PSAnZHJvcGRvd24tYnV0dG9ucycpIHtcbiAgICAgICAgY2FwdGlvbiA9IChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKGpzeFJ1bnRpbWVFeHBvcnRzLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4KENhcHRpb25Ecm9wZG93bnMsIHsgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGgsIGRpc3BsYXlJbmRleDogcHJvcHMuZGlzcGxheUluZGV4LCBpZDogcHJvcHMuaWQgfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChDYXB0aW9uTmF2aWdhdGlvbiwgeyBkaXNwbGF5TW9udGg6IHByb3BzLmRpc3BsYXlNb250aCwgZGlzcGxheUluZGV4OiBwcm9wcy5kaXNwbGF5SW5kZXgsIGlkOiBwcm9wcy5pZCB9KV0gfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdGlvbiA9IChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKGpzeFJ1bnRpbWVFeHBvcnRzLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4KENhcHRpb25MYWJlbENvbXBvbmVudCwgeyBpZDogcHJvcHMuaWQsIGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoLCBkaXNwbGF5SW5kZXg6IHByb3BzLmRpc3BsYXlJbmRleCB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KENhcHRpb25OYXZpZ2F0aW9uLCB7IGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoLCBpZDogcHJvcHMuaWQgfSldIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuY2FwdGlvbiwgc3R5bGU6IHN0eWxlcy5jYXB0aW9uIH0sIHsgY2hpbGRyZW46IGNhcHRpb24gfSkpKTtcbn1cblxuLyoqIFJlbmRlciB0aGUgRm9vdGVyIGNvbXBvbmVudCAoZW1wdHkgYXMgZGVmYXVsdCkuKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmZ1bmN0aW9uIEZvb3Rlcihwcm9wcykge1xuICAgIHZhciBfYSA9IHVzZURheVBpY2tlcigpLCBmb290ZXIgPSBfYS5mb290ZXIsIHN0eWxlcyA9IF9hLnN0eWxlcywgdGZvb3QgPSBfYS5jbGFzc05hbWVzLnRmb290O1xuICAgIGlmICghZm9vdGVyKVxuICAgICAgICByZXR1cm4ganN4UnVudGltZUV4cG9ydHMuanN4KGpzeFJ1bnRpbWVFeHBvcnRzLkZyYWdtZW50LCB7fSk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJ0Zm9vdFwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogdGZvb3QsIHN0eWxlOiBzdHlsZXMudGZvb3QgfSwgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KFwidHJcIiwgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KFwidGRcIiwgX19hc3NpZ24oeyBjb2xTcGFuOiA4IH0sIHsgY2hpbGRyZW46IGZvb3RlciB9KSkgfSkgfSkpKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNlcmllcyBvZiA3IGRheXMsIHN0YXJ0aW5nIGZyb20gdGhlIHdlZWssIHRvIHVzZSBmb3IgZm9ybWF0dGluZ1xuICogdGhlIHdlZWtkYXkgbmFtZXMgKE1vbmRheSwgVHVlc2RheSwgZXRjLikuXG4gKi9cbmZ1bmN0aW9uIGdldFdlZWtkYXlzKGxvY2FsZSwgXG4vKiogVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgLSBTdW5kYXkpLiAqL1xud2Vla1N0YXJ0c09uLCBcbi8qKiBVc2UgSVNPV2VlayBpbnN0ZWFkIG9mIGxvY2FsZS8gKi9cbklTT1dlZWspIHtcbiAgICB2YXIgc3RhcnQgPSBJU09XZWVrXG4gICAgICAgID8gc3RhcnRPZklTT1dlZWsobmV3IERhdGUoKSlcbiAgICAgICAgOiBzdGFydE9mV2VlayhuZXcgRGF0ZSgpLCB7IGxvY2FsZTogbG9jYWxlLCB3ZWVrU3RhcnRzT246IHdlZWtTdGFydHNPbiB9KTtcbiAgICB2YXIgZGF5cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIHZhciBkYXkgPSBhZGREYXlzKHN0YXJ0LCBpKTtcbiAgICAgICAgZGF5cy5wdXNoKGRheSk7XG4gICAgfVxuICAgIHJldHVybiBkYXlzO1xufVxuXG4vKipcbiAqIFJlbmRlciB0aGUgSGVhZFJvdyBjb21wb25lbnQgLSBpLmUuIHRoZSB0YWJsZSBoZWFkIHJvdyB3aXRoIHRoZSB3ZWVrZGF5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBIZWFkUm93KCkge1xuICAgIHZhciBfYSA9IHVzZURheVBpY2tlcigpLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcywgc3R5bGVzID0gX2Euc3R5bGVzLCBzaG93V2Vla051bWJlciA9IF9hLnNob3dXZWVrTnVtYmVyLCBsb2NhbGUgPSBfYS5sb2NhbGUsIHdlZWtTdGFydHNPbiA9IF9hLndlZWtTdGFydHNPbiwgSVNPV2VlayA9IF9hLklTT1dlZWssIGZvcm1hdFdlZWtkYXlOYW1lID0gX2EuZm9ybWF0dGVycy5mb3JtYXRXZWVrZGF5TmFtZSwgbGFiZWxXZWVrZGF5ID0gX2EubGFiZWxzLmxhYmVsV2Vla2RheTtcbiAgICB2YXIgd2Vla2RheXMgPSBnZXRXZWVrZGF5cyhsb2NhbGUsIHdlZWtTdGFydHNPbiwgSVNPV2Vlayk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwidHJcIiwgX19hc3NpZ24oeyBzdHlsZTogc3R5bGVzLmhlYWRfcm93LCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuaGVhZF9yb3cgfSwgeyBjaGlsZHJlbjogW3Nob3dXZWVrTnVtYmVyICYmIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJ0ZFwiLCB7IHN0eWxlOiBzdHlsZXMuaGVhZF9jZWxsLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuaGVhZF9jZWxsIH0pKSwgd2Vla2RheXMubWFwKGZ1bmN0aW9uICh3ZWVrZGF5LCBpKSB7IHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwidGhcIiwgX19hc3NpZ24oeyBzY29wZTogXCJjb2xcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmhlYWRfY2VsbCwgc3R5bGU6IHN0eWxlcy5oZWFkX2NlbGwsIFwiYXJpYS1sYWJlbFwiOiBsYWJlbFdlZWtkYXkod2Vla2RheSwgeyBsb2NhbGU6IGxvY2FsZSB9KSB9LCB7IGNoaWxkcmVuOiBmb3JtYXRXZWVrZGF5TmFtZSh3ZWVrZGF5LCB7IGxvY2FsZTogbG9jYWxlIH0pIH0pLCBpKSk7IH0pXSB9KSkpO1xufVxuXG4vKiogUmVuZGVyIHRoZSB0YWJsZSBoZWFkLiAqL1xuZnVuY3Rpb24gSGVhZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iID0gdXNlRGF5UGlja2VyKCksIGNsYXNzTmFtZXMgPSBfYi5jbGFzc05hbWVzLCBzdHlsZXMgPSBfYi5zdHlsZXMsIGNvbXBvbmVudHMgPSBfYi5jb21wb25lbnRzO1xuICAgIHZhciBIZWFkUm93Q29tcG9uZW50ID0gKF9hID0gY29tcG9uZW50cyA9PT0gbnVsbCB8fCBjb21wb25lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzLkhlYWRSb3cpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEhlYWRSb3c7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJ0aGVhZFwiLCBfX2Fzc2lnbih7IHN0eWxlOiBzdHlsZXMuaGVhZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmhlYWQgfSwgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KEhlYWRSb3dDb21wb25lbnQsIHt9KSB9KSkpO1xufVxuXG4vKiogUmVuZGVyIHRoZSBjb250ZW50IG9mIHRoZSBkYXkgY2VsbC4gKi9cbmZ1bmN0aW9uIERheUNvbnRlbnQocHJvcHMpIHtcbiAgICB2YXIgX2EgPSB1c2VEYXlQaWNrZXIoKSwgbG9jYWxlID0gX2EubG9jYWxlLCBmb3JtYXREYXkgPSBfYS5mb3JtYXR0ZXJzLmZvcm1hdERheTtcbiAgICByZXR1cm4ganN4UnVudGltZUV4cG9ydHMuanN4KGpzeFJ1bnRpbWVFeHBvcnRzLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBmb3JtYXREYXkocHJvcHMuZGF0ZSwgeyBsb2NhbGU6IGxvY2FsZSB9KSB9KTtcbn1cblxuLyoqXG4gKiBUaGUgU2VsZWN0TXVsdGlwbGUgY29udGV4dCBzaGFyZXMgZGV0YWlscyBhYm91dCB0aGUgc2VsZWN0ZWQgZGF5cyB3aGVuIGluXG4gKiBtdWx0aXBsZSBzZWxlY3Rpb24gbW9kZS5cbiAqXG4gKiBBY2Nlc3MgdGhpcyBjb250ZXh0IGZyb20gdGhlIHtAbGluayB1c2VTZWxlY3RNdWx0aXBsZX0gaG9vay5cbiAqL1xudmFyIFNlbGVjdE11bHRpcGxlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKiBQcm92aWRlcyB0aGUgdmFsdWVzIGZvciB0aGUge0BsaW5rIFNlbGVjdE11bHRpcGxlQ29udGV4dH0uICovXG5mdW5jdGlvbiBTZWxlY3RNdWx0aXBsZVByb3ZpZGVyKHByb3BzKSB7XG4gICAgaWYgKCFpc0RheVBpY2tlck11bHRpcGxlKHByb3BzLmluaXRpYWxQcm9wcykpIHtcbiAgICAgICAgdmFyIGVtcHR5Q29udGV4dFZhbHVlID0ge1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChTZWxlY3RNdWx0aXBsZUNvbnRleHQuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IGVtcHR5Q29udGV4dFZhbHVlIH0sIHsgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFNlbGVjdE11bHRpcGxlUHJvdmlkZXJJbnRlcm5hbCwgeyBpbml0aWFsUHJvcHM6IHByb3BzLmluaXRpYWxQcm9wcywgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKTtcbn1cbmZ1bmN0aW9uIFNlbGVjdE11bHRpcGxlUHJvdmlkZXJJbnRlcm5hbChfYSkge1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSBfYS5pbml0aWFsUHJvcHMsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIHNlbGVjdGVkID0gaW5pdGlhbFByb3BzLnNlbGVjdGVkLCBtaW4gPSBpbml0aWFsUHJvcHMubWluLCBtYXggPSBpbml0aWFsUHJvcHMubWF4O1xuICAgIHZhciBvbkRheUNsaWNrID0gZnVuY3Rpb24gKGRheSwgYWN0aXZlTW9kaWZpZXJzLCBlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYSA9IGluaXRpYWxQcm9wcy5vbkRheUNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbml0aWFsUHJvcHMsIGRheSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICAgICAgdmFyIGlzTWluU2VsZWN0ZWQgPSBCb29sZWFuKGFjdGl2ZU1vZGlmaWVycy5zZWxlY3RlZCAmJiBtaW4gJiYgKHNlbGVjdGVkID09PSBudWxsIHx8IHNlbGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZC5sZW5ndGgpID09PSBtaW4pO1xuICAgICAgICBpZiAoaXNNaW5TZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc01heFNlbGVjdGVkID0gQm9vbGVhbighYWN0aXZlTW9kaWZpZXJzLnNlbGVjdGVkICYmIG1heCAmJiAoc2VsZWN0ZWQgPT09IG51bGwgfHwgc2VsZWN0ZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkLmxlbmd0aCkgPT09IG1heCk7XG4gICAgICAgIGlmIChpc01heFNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGVkRGF5cyA9IHNlbGVjdGVkID8gX19zcHJlYWRBcnJheShbXSwgc2VsZWN0ZWQsIHRydWUpIDogW107XG4gICAgICAgIGlmIChhY3RpdmVNb2RpZmllcnMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHNlbGVjdGVkRGF5cy5maW5kSW5kZXgoZnVuY3Rpb24gKHNlbGVjdGVkRGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShkYXksIHNlbGVjdGVkRGF5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWREYXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RlZERheXMucHVzaChkYXkpO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IGluaXRpYWxQcm9wcy5vblNlbGVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoaW5pdGlhbFByb3BzLCBzZWxlY3RlZERheXMsIGRheSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICB9O1xuICAgIHZhciBtb2RpZmllcnMgPSB7XG4gICAgICAgIGRpc2FibGVkOiBbXVxuICAgIH07XG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIG1vZGlmaWVycy5kaXNhYmxlZC5wdXNoKGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgIHZhciBpc01heFNlbGVjdGVkID0gbWF4ICYmIHNlbGVjdGVkLmxlbmd0aCA+IG1heCAtIDE7XG4gICAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IHNlbGVjdGVkLnNvbWUoZnVuY3Rpb24gKHNlbGVjdGVkRGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShzZWxlY3RlZERheSwgZGF5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oaXNNYXhTZWxlY3RlZCAmJiAhaXNTZWxlY3RlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgY29udGV4dFZhbHVlID0ge1xuICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICAgIG9uRGF5Q2xpY2s6IG9uRGF5Q2xpY2ssXG4gICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChTZWxlY3RNdWx0aXBsZUNvbnRleHQuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IGNvbnRleHRWYWx1ZSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xufVxuLyoqXG4gKiBIb29rIHRvIGFjY2VzcyB0aGUge0BsaW5rIFNlbGVjdE11bHRpcGxlQ29udGV4dFZhbHVlfS5cbiAqXG4gKiBUaGlzIGhvb2sgaXMgbWVhbnQgdG8gYmUgdXNlZCBpbnNpZGUgaW50ZXJuYWwgb3IgY3VzdG9tIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHVzZVNlbGVjdE11bHRpcGxlKCkge1xuICAgIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTZWxlY3RNdWx0aXBsZUNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVNlbGVjdE11bHRpcGxlIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBTZWxlY3RNdWx0aXBsZVByb3ZpZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIEFkZCBhIGRheSB0byBhbiBleGlzdGluZyByYW5nZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgcmFuZ2UgdGFrZXMgaW4gYWNjb3VudCB0aGUgYHVuZGVmaW5lZGAgdmFsdWVzIGFuZCBpZiB0aGUgYWRkZWRcbiAqIGRheSBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiBhZGRUb1JhbmdlKGRheSwgcmFuZ2UpIHtcbiAgICB2YXIgX2EgPSByYW5nZSB8fCB7fSwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG87XG4gICAgaWYgKGZyb20gJiYgdG8pIHtcbiAgICAgICAgaWYgKGlzU2FtZURheSh0bywgZGF5KSAmJiBpc1NhbWVEYXkoZnJvbSwgZGF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTYW1lRGF5KHRvLCBkYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiB0bywgdG86IHVuZGVmaW5lZCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NhbWVEYXkoZnJvbSwgZGF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBZnRlcihmcm9tLCBkYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkYXksIHRvOiB0byB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb206IGZyb20sIHRvOiBkYXkgfTtcbiAgICB9XG4gICAgaWYgKHRvKSB7XG4gICAgICAgIGlmIChpc0FmdGVyKGRheSwgdG8pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiB0bywgdG86IGRheSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb206IGRheSwgdG86IHRvIH07XG4gICAgfVxuICAgIGlmIChmcm9tKSB7XG4gICAgICAgIGlmIChpc0JlZm9yZShkYXksIGZyb20pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkYXksIHRvOiBmcm9tIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbSwgdG86IGRheSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBmcm9tOiBkYXksIHRvOiB1bmRlZmluZWQgfTtcbn1cblxuLyoqXG4gKiBUaGUgU2VsZWN0UmFuZ2UgY29udGV4dCBzaGFyZXMgZGV0YWlscyBhYm91dCB0aGUgc2VsZWN0ZWQgZGF5cyB3aGVuIGluXG4gKiByYW5nZSBzZWxlY3Rpb24gbW9kZS5cbiAqXG4gKiBBY2Nlc3MgdGhpcyBjb250ZXh0IGZyb20gdGhlIHtAbGluayB1c2VTZWxlY3RSYW5nZX0gaG9vay5cbiAqL1xudmFyIFNlbGVjdFJhbmdlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKiBQcm92aWRlcyB0aGUgdmFsdWVzIGZvciB0aGUge0BsaW5rIFNlbGVjdFJhbmdlUHJvdmlkZXJ9LiAqL1xuZnVuY3Rpb24gU2VsZWN0UmFuZ2VQcm92aWRlcihwcm9wcykge1xuICAgIGlmICghaXNEYXlQaWNrZXJSYW5nZShwcm9wcy5pbml0aWFsUHJvcHMpKSB7XG4gICAgICAgIHZhciBlbXB0eUNvbnRleHRWYWx1ZSA9IHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICAgICAgICByYW5nZV9zdGFydDogW10sXG4gICAgICAgICAgICAgICAgcmFuZ2VfZW5kOiBbXSxcbiAgICAgICAgICAgICAgICByYW5nZV9taWRkbGU6IFtdLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChTZWxlY3RSYW5nZUNvbnRleHQuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IGVtcHR5Q29udGV4dFZhbHVlIH0sIHsgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFNlbGVjdFJhbmdlUHJvdmlkZXJJbnRlcm5hbCwgeyBpbml0aWFsUHJvcHM6IHByb3BzLmluaXRpYWxQcm9wcywgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKTtcbn1cbmZ1bmN0aW9uIFNlbGVjdFJhbmdlUHJvdmlkZXJJbnRlcm5hbChfYSkge1xuICAgIHZhciBpbml0aWFsUHJvcHMgPSBfYS5pbml0aWFsUHJvcHMsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIHNlbGVjdGVkID0gaW5pdGlhbFByb3BzLnNlbGVjdGVkO1xuICAgIHZhciBfYiA9IHNlbGVjdGVkIHx8IHt9LCBzZWxlY3RlZEZyb20gPSBfYi5mcm9tLCBzZWxlY3RlZFRvID0gX2IudG87XG4gICAgdmFyIG1pbiA9IGluaXRpYWxQcm9wcy5taW47XG4gICAgdmFyIG1heCA9IGluaXRpYWxQcm9wcy5tYXg7XG4gICAgdmFyIG9uRGF5Q2xpY2sgPSBmdW5jdGlvbiAoZGF5LCBhY3RpdmVNb2RpZmllcnMsIGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgKF9hID0gaW5pdGlhbFByb3BzLm9uRGF5Q2xpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGluaXRpYWxQcm9wcywgZGF5LCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgICAgICB2YXIgbmV3UmFuZ2UgPSBhZGRUb1JhbmdlKGRheSwgc2VsZWN0ZWQpO1xuICAgICAgICAoX2IgPSBpbml0aWFsUHJvcHMub25TZWxlY3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGluaXRpYWxQcm9wcywgbmV3UmFuZ2UsIGRheSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICB9O1xuICAgIHZhciBtb2RpZmllcnMgPSB7XG4gICAgICAgIHJhbmdlX3N0YXJ0OiBbXSxcbiAgICAgICAgcmFuZ2VfZW5kOiBbXSxcbiAgICAgICAgcmFuZ2VfbWlkZGxlOiBbXSxcbiAgICAgICAgZGlzYWJsZWQ6IFtdXG4gICAgfTtcbiAgICBpZiAoc2VsZWN0ZWRGcm9tKSB7XG4gICAgICAgIG1vZGlmaWVycy5yYW5nZV9zdGFydCA9IFtzZWxlY3RlZEZyb21dO1xuICAgICAgICBpZiAoIXNlbGVjdGVkVG8pIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5yYW5nZV9lbmQgPSBbc2VsZWN0ZWRGcm9tXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5yYW5nZV9lbmQgPSBbc2VsZWN0ZWRUb107XG4gICAgICAgICAgICBpZiAoIWlzU2FtZURheShzZWxlY3RlZEZyb20sIHNlbGVjdGVkVG8pKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnJhbmdlX21pZGRsZSA9IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IHNlbGVjdGVkRnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZTogc2VsZWN0ZWRUb1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3RlZFRvKSB7XG4gICAgICAgIG1vZGlmaWVycy5yYW5nZV9zdGFydCA9IFtzZWxlY3RlZFRvXTtcbiAgICAgICAgbW9kaWZpZXJzLnJhbmdlX2VuZCA9IFtzZWxlY3RlZFRvXTtcbiAgICB9XG4gICAgaWYgKG1pbikge1xuICAgICAgICBpZiAoc2VsZWN0ZWRGcm9tICYmICFzZWxlY3RlZFRvKSB7XG4gICAgICAgICAgICBtb2RpZmllcnMuZGlzYWJsZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgYWZ0ZXI6IHN1YkRheXMoc2VsZWN0ZWRGcm9tLCBtaW4gLSAxKSxcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGFkZERheXMoc2VsZWN0ZWRGcm9tLCBtaW4gLSAxKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkRnJvbSAmJiBzZWxlY3RlZFRvKSB7XG4gICAgICAgICAgICBtb2RpZmllcnMuZGlzYWJsZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgYWZ0ZXI6IHNlbGVjdGVkRnJvbSxcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGFkZERheXMoc2VsZWN0ZWRGcm9tLCBtaW4gLSAxKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxlY3RlZEZyb20gJiYgc2VsZWN0ZWRUbykge1xuICAgICAgICAgICAgbW9kaWZpZXJzLmRpc2FibGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGFmdGVyOiBzdWJEYXlzKHNlbGVjdGVkVG8sIG1pbiAtIDEpLFxuICAgICAgICAgICAgICAgIGJlZm9yZTogYWRkRGF5cyhzZWxlY3RlZFRvLCBtaW4gLSAxKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1heCkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRGcm9tICYmICFzZWxlY3RlZFRvKSB7XG4gICAgICAgICAgICBtb2RpZmllcnMuZGlzYWJsZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBhZGREYXlzKHNlbGVjdGVkRnJvbSwgLW1heCArIDEpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vZGlmaWVycy5kaXNhYmxlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZnRlcjogYWRkRGF5cyhzZWxlY3RlZEZyb20sIG1heCAtIDEpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0ZWRGcm9tICYmIHNlbGVjdGVkVG8pIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZENvdW50ID0gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKHNlbGVjdGVkVG8sIHNlbGVjdGVkRnJvbSkgKyAxO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG1heCAtIHNlbGVjdGVkQ291bnQ7XG4gICAgICAgICAgICBtb2RpZmllcnMuZGlzYWJsZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBzdWJEYXlzKHNlbGVjdGVkRnJvbSwgb2Zmc2V0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb2RpZmllcnMuZGlzYWJsZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgYWZ0ZXI6IGFkZERheXMoc2VsZWN0ZWRUbywgb2Zmc2V0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxlY3RlZEZyb20gJiYgc2VsZWN0ZWRUbykge1xuICAgICAgICAgICAgbW9kaWZpZXJzLmRpc2FibGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGJlZm9yZTogYWRkRGF5cyhzZWxlY3RlZFRvLCAtbWF4ICsgMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW9kaWZpZXJzLmRpc2FibGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGFmdGVyOiBhZGREYXlzKHNlbGVjdGVkVG8sIG1heCAtIDEpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChTZWxlY3RSYW5nZUNvbnRleHQuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkLCBvbkRheUNsaWNrOiBvbkRheUNsaWNrLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9IH0sIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKSk7XG59XG4vKipcbiAqIEhvb2sgdG8gYWNjZXNzIHRoZSB7QGxpbmsgU2VsZWN0UmFuZ2VDb250ZXh0VmFsdWV9LlxuICpcbiAqIFRoaXMgaG9vayBpcyBtZWFudCB0byBiZSB1c2VkIGluc2lkZSBpbnRlcm5hbCBvciBjdXN0b20gY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gdXNlU2VsZWN0UmFuZ2UoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNlbGVjdFJhbmdlQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlU2VsZWN0UmFuZ2UgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFNlbGVjdFJhbmdlUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKiBOb3JtYWxpemUgdG8gYXJyYXkgYSBtYXRjaGVyIGlucHV0LiAqL1xuZnVuY3Rpb24gbWF0Y2hlclRvQXJyYXkobWF0Y2hlcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGNoZXIpKSB7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFtdLCBtYXRjaGVyLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbbWF0Y2hlcl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG4vKiogQ3JlYXRlIEN1c3RvbU1vZGlmaWVycyBmcm9tIGRheU1vZGlmaWVycyAqL1xuZnVuY3Rpb24gZ2V0Q3VzdG9tTW9kaWZpZXJzKGRheU1vZGlmaWVycykge1xuICAgIHZhciBjdXN0b21Nb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyhkYXlNb2RpZmllcnMpLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBtb2RpZmllciA9IF9hWzBdLCBtYXRjaGVyID0gX2FbMV07XG4gICAgICAgIGN1c3RvbU1vZGlmaWVyc1ttb2RpZmllcl0gPSBtYXRjaGVyVG9BcnJheShtYXRjaGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3VzdG9tTW9kaWZpZXJzO1xufVxuXG4vKiogVGhlIG5hbWUgb2YgdGhlIG1vZGlmaWVycyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgYnkgRGF5UGlja2VyLiAqL1xudmFyIEludGVybmFsTW9kaWZpZXI7XG4oZnVuY3Rpb24gKEludGVybmFsTW9kaWZpZXIpIHtcbiAgICBJbnRlcm5hbE1vZGlmaWVyW1wiT3V0c2lkZVwiXSA9IFwib3V0c2lkZVwiO1xuICAgIC8qKiBOYW1lIG9mIHRoZSBtb2RpZmllciBhcHBsaWVkIHRvIHRoZSBkaXNhYmxlZCBkYXlzLCB1c2luZyB0aGUgYGRpc2FibGVkYCBwcm9wLiAqL1xuICAgIEludGVybmFsTW9kaWZpZXJbXCJEaXNhYmxlZFwiXSA9IFwiZGlzYWJsZWRcIjtcbiAgICAvKiogTmFtZSBvZiB0aGUgbW9kaWZpZXIgYXBwbGllZCB0byB0aGUgc2VsZWN0ZWQgZGF5cyB1c2luZyB0aGUgYHNlbGVjdGVkYCBwcm9wKS4gKi9cbiAgICBJbnRlcm5hbE1vZGlmaWVyW1wiU2VsZWN0ZWRcIl0gPSBcInNlbGVjdGVkXCI7XG4gICAgLyoqIE5hbWUgb2YgdGhlIG1vZGlmaWVyIGFwcGxpZWQgdG8gdGhlIGhpZGRlbiBkYXlzIHVzaW5nIHRoZSBgaGlkZGVuYCBwcm9wKS4gKi9cbiAgICBJbnRlcm5hbE1vZGlmaWVyW1wiSGlkZGVuXCJdID0gXCJoaWRkZW5cIjtcbiAgICAvKiogTmFtZSBvZiB0aGUgbW9kaWZpZXIgYXBwbGllZCB0byB0aGUgZGF5IHNwZWNpZmllZCB1c2luZyB0aGUgYHRvZGF5YCBwcm9wKS4gKi9cbiAgICBJbnRlcm5hbE1vZGlmaWVyW1wiVG9kYXlcIl0gPSBcInRvZGF5XCI7XG4gICAgLyoqIFRoZSBtb2RpZmllciBhcHBsaWVkIHRvIHRoZSBkYXkgc3RhcnRpbmcgYSBzZWxlY3RlZCByYW5nZSwgd2hlbiBpbiByYW5nZSBzZWxlY3Rpb24gbW9kZS4gICovXG4gICAgSW50ZXJuYWxNb2RpZmllcltcIlJhbmdlU3RhcnRcIl0gPSBcInJhbmdlX3N0YXJ0XCI7XG4gICAgLyoqIFRoZSBtb2RpZmllciBhcHBsaWVkIHRvIHRoZSBkYXkgZW5kaW5nIGEgc2VsZWN0ZWQgcmFuZ2UsIHdoZW4gaW4gcmFuZ2Ugc2VsZWN0aW9uIG1vZGUuICAqL1xuICAgIEludGVybmFsTW9kaWZpZXJbXCJSYW5nZUVuZFwiXSA9IFwicmFuZ2VfZW5kXCI7XG4gICAgLyoqIFRoZSBtb2RpZmllciBhcHBsaWVkIHRvIHRoZSBkYXlzIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCB0aGUgZW5kIG9mIGEgc2VsZWN0ZWQgcmFuZ2UsIHdoZW4gaW4gcmFuZ2Ugc2VsZWN0aW9uIG1vZGUuICAqL1xuICAgIEludGVybmFsTW9kaWZpZXJbXCJSYW5nZU1pZGRsZVwiXSA9IFwicmFuZ2VfbWlkZGxlXCI7XG59KShJbnRlcm5hbE1vZGlmaWVyIHx8IChJbnRlcm5hbE1vZGlmaWVyID0ge30pKTtcblxudmFyIFNlbGVjdGVkID0gSW50ZXJuYWxNb2RpZmllci5TZWxlY3RlZCwgRGlzYWJsZWQgPSBJbnRlcm5hbE1vZGlmaWVyLkRpc2FibGVkLCBIaWRkZW4gPSBJbnRlcm5hbE1vZGlmaWVyLkhpZGRlbiwgVG9kYXkgPSBJbnRlcm5hbE1vZGlmaWVyLlRvZGF5LCBSYW5nZUVuZCA9IEludGVybmFsTW9kaWZpZXIuUmFuZ2VFbmQsIFJhbmdlTWlkZGxlID0gSW50ZXJuYWxNb2RpZmllci5SYW5nZU1pZGRsZSwgUmFuZ2VTdGFydCA9IEludGVybmFsTW9kaWZpZXIuUmFuZ2VTdGFydCwgT3V0c2lkZSA9IEludGVybmFsTW9kaWZpZXIuT3V0c2lkZTtcbi8qKiBSZXR1cm4gdGhlIHtAbGluayBJbnRlcm5hbE1vZGlmaWVyc30gZnJvbSB0aGUgRGF5UGlja2VyIGFuZCBzZWxlY3QgY29udGV4dHMuICovXG5mdW5jdGlvbiBnZXRJbnRlcm5hbE1vZGlmaWVycyhkYXlQaWNrZXIsIHNlbGVjdE11bHRpcGxlLCBzZWxlY3RSYW5nZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgaW50ZXJuYWxNb2RpZmllcnMgPSAoX2EgPSB7fSxcbiAgICAgICAgX2FbU2VsZWN0ZWRdID0gbWF0Y2hlclRvQXJyYXkoZGF5UGlja2VyLnNlbGVjdGVkKSxcbiAgICAgICAgX2FbRGlzYWJsZWRdID0gbWF0Y2hlclRvQXJyYXkoZGF5UGlja2VyLmRpc2FibGVkKSxcbiAgICAgICAgX2FbSGlkZGVuXSA9IG1hdGNoZXJUb0FycmF5KGRheVBpY2tlci5oaWRkZW4pLFxuICAgICAgICBfYVtUb2RheV0gPSBbZGF5UGlja2VyLnRvZGF5XSxcbiAgICAgICAgX2FbUmFuZ2VFbmRdID0gW10sXG4gICAgICAgIF9hW1JhbmdlTWlkZGxlXSA9IFtdLFxuICAgICAgICBfYVtSYW5nZVN0YXJ0XSA9IFtdLFxuICAgICAgICBfYVtPdXRzaWRlXSA9IFtdLFxuICAgICAgICBfYSk7XG4gICAgaWYgKGRheVBpY2tlci5mcm9tRGF0ZSkge1xuICAgICAgICBpbnRlcm5hbE1vZGlmaWVyc1tEaXNhYmxlZF0ucHVzaCh7IGJlZm9yZTogZGF5UGlja2VyLmZyb21EYXRlIH0pO1xuICAgIH1cbiAgICBpZiAoZGF5UGlja2VyLnRvRGF0ZSkge1xuICAgICAgICBpbnRlcm5hbE1vZGlmaWVyc1tEaXNhYmxlZF0ucHVzaCh7IGFmdGVyOiBkYXlQaWNrZXIudG9EYXRlIH0pO1xuICAgIH1cbiAgICBpZiAoaXNEYXlQaWNrZXJNdWx0aXBsZShkYXlQaWNrZXIpKSB7XG4gICAgICAgIGludGVybmFsTW9kaWZpZXJzW0Rpc2FibGVkXSA9IGludGVybmFsTW9kaWZpZXJzW0Rpc2FibGVkXS5jb25jYXQoc2VsZWN0TXVsdGlwbGUubW9kaWZpZXJzW0Rpc2FibGVkXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGF5UGlja2VyUmFuZ2UoZGF5UGlja2VyKSkge1xuICAgICAgICBpbnRlcm5hbE1vZGlmaWVyc1tEaXNhYmxlZF0gPSBpbnRlcm5hbE1vZGlmaWVyc1tEaXNhYmxlZF0uY29uY2F0KHNlbGVjdFJhbmdlLm1vZGlmaWVyc1tEaXNhYmxlZF0pO1xuICAgICAgICBpbnRlcm5hbE1vZGlmaWVyc1tSYW5nZVN0YXJ0XSA9IHNlbGVjdFJhbmdlLm1vZGlmaWVyc1tSYW5nZVN0YXJ0XTtcbiAgICAgICAgaW50ZXJuYWxNb2RpZmllcnNbUmFuZ2VNaWRkbGVdID0gc2VsZWN0UmFuZ2UubW9kaWZpZXJzW1JhbmdlTWlkZGxlXTtcbiAgICAgICAgaW50ZXJuYWxNb2RpZmllcnNbUmFuZ2VFbmRdID0gc2VsZWN0UmFuZ2UubW9kaWZpZXJzW1JhbmdlRW5kXTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVybmFsTW9kaWZpZXJzO1xufVxuXG4vKiogVGhlIE1vZGlmaWVycyBjb250ZXh0IHN0b3JlIHRoZSBtb2RpZmllcnMgdXNlZCBpbiBEYXlQaWNrZXIuIFRvIGFjY2VzcyB0aGUgdmFsdWUgb2YgdGhpcyBjb250ZXh0LCB1c2Uge0BsaW5rIHVzZU1vZGlmaWVyc30uICovXG52YXIgTW9kaWZpZXJzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKiBQcm92aWRlIHRoZSB2YWx1ZSBmb3IgdGhlIHtAbGluayBNb2RpZmllcnNDb250ZXh0fS4gKi9cbmZ1bmN0aW9uIE1vZGlmaWVyc1Byb3ZpZGVyKHByb3BzKSB7XG4gICAgdmFyIGRheVBpY2tlciA9IHVzZURheVBpY2tlcigpO1xuICAgIHZhciBzZWxlY3RNdWx0aXBsZSA9IHVzZVNlbGVjdE11bHRpcGxlKCk7XG4gICAgdmFyIHNlbGVjdFJhbmdlID0gdXNlU2VsZWN0UmFuZ2UoKTtcbiAgICB2YXIgaW50ZXJuYWxNb2RpZmllcnMgPSBnZXRJbnRlcm5hbE1vZGlmaWVycyhkYXlQaWNrZXIsIHNlbGVjdE11bHRpcGxlLCBzZWxlY3RSYW5nZSk7XG4gICAgdmFyIGN1c3RvbU1vZGlmaWVycyA9IGdldEN1c3RvbU1vZGlmaWVycyhkYXlQaWNrZXIubW9kaWZpZXJzKTtcbiAgICB2YXIgbW9kaWZpZXJzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGludGVybmFsTW9kaWZpZXJzKSwgY3VzdG9tTW9kaWZpZXJzKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChNb2RpZmllcnNDb250ZXh0LlByb3ZpZGVyLCBfX2Fzc2lnbih7IHZhbHVlOiBtb2RpZmllcnMgfSwgeyBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSkpKTtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBtb2RpZmllcnMgdXNlZCBieSBEYXlQaWNrZXIuXG4gKlxuICogVGhpcyBob29rIGlzIG1lYW50IHRvIGJlIHVzZWQgaW5zaWRlIGludGVybmFsIG9yIGN1c3RvbSBjb21wb25lbnRzLlxuICogUmVxdWlyZXMgdG8gYmUgd3JhcHBlZCBpbnRvIHtAbGluayBNb2RpZmllcnNQcm92aWRlcn0uXG4gKlxuICovXG5mdW5jdGlvbiB1c2VNb2RpZmllcnMoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE1vZGlmaWVyc0NvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZU1vZGlmaWVycyBtdXN0IGJlIHVzZWQgd2l0aGluIGEgTW9kaWZpZXJzUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgYG1hdGNoZXJgIGlzIG9mIHR5cGUge0BsaW5rIERhdGVJbnRlcnZhbH0uICovXG5mdW5jdGlvbiBpc0RhdGVJbnRlcnZhbChtYXRjaGVyKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF0Y2hlciAmJlxuICAgICAgICB0eXBlb2YgbWF0Y2hlciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2JlZm9yZScgaW4gbWF0Y2hlciAmJlxuICAgICAgICAnYWZ0ZXInIGluIG1hdGNoZXIpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEge0BsaW5rIERhdGVSYW5nZX0gdHlwZS4gKi9cbmZ1bmN0aW9uIGlzRGF0ZVJhbmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAnZnJvbScgaW4gdmFsdWUpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG9mIHR5cGUge0BsaW5rIERhdGVBZnRlcn0uICovXG5mdW5jdGlvbiBpc0RhdGVBZnRlclR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICdhZnRlcicgaW4gdmFsdWUpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG9mIHR5cGUge0BsaW5rIERhdGVCZWZvcmV9LiAqL1xuZnVuY3Rpb24gaXNEYXRlQmVmb3JlVHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJ2JlZm9yZScgaW4gdmFsdWUpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEge0BsaW5rIERheU9mV2Vla30gdHlwZS4gKi9cbmZ1bmN0aW9uIGlzRGF5T2ZXZWVrVHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJ2RheU9mV2VlaycgaW4gdmFsdWUpO1xufVxuXG4vKiogUmV0dXJuIGB0cnVlYCB3aGV0aGVyIGBkYXRlYCBpcyBpbnNpZGUgYHJhbmdlYC4gKi9cbmZ1bmN0aW9uIGlzRGF0ZUluUmFuZ2UoZGF0ZSwgcmFuZ2UpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZyb20gPSByYW5nZS5mcm9tLCB0byA9IHJhbmdlLnRvO1xuICAgIGlmIChmcm9tICYmIHRvKSB7XG4gICAgICAgIHZhciBpc1JhbmdlSW52ZXJ0ZWQgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXModG8sIGZyb20pIDwgMDtcbiAgICAgICAgaWYgKGlzUmFuZ2VJbnZlcnRlZCkge1xuICAgICAgICAgICAgX2EgPSBbdG8sIGZyb21dLCBmcm9tID0gX2FbMF0sIHRvID0gX2FbMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzSW5SYW5nZSA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhkYXRlLCBmcm9tKSA+PSAwICYmXG4gICAgICAgICAgICBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXModG8sIGRhdGUpID49IDA7XG4gICAgICAgIHJldHVybiBpc0luUmFuZ2U7XG4gICAgfVxuICAgIGlmICh0bykge1xuICAgICAgICByZXR1cm4gaXNTYW1lRGF5KHRvLCBkYXRlKTtcbiAgICB9XG4gICAgaWYgKGZyb20pIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZURheShmcm9tLCBkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBEYXRlIHR5cGUuICovXG5mdW5jdGlvbiBpc0RhdGVUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRGF0ZSh2YWx1ZSk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgb2YgdmFsaWQgZGF0ZXMuICovXG5mdW5jdGlvbiBpc0FycmF5T2ZEYXRlcyh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0RhdGUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSBkYXkgbWF0Y2hlcyBhZ2FpbnN0IGF0IGxlYXN0IG9uZSBvZiB0aGUgZ2l2ZW4gTWF0Y2hlcnMuXG4gKlxuICogYGBgXG4gKiBjb25zdCBkYXkgPSBuZXcgRGF0ZSgyMDIyLCA1LCAxOSk7XG4gKiBjb25zdCBtYXRjaGVyMTogRGF0ZVJhbmdlID0ge1xuICogICAgZnJvbTogbmV3IERhdGUoMjAyMSwgMTIsIDIxKSxcbiAqICAgIHRvOiBuZXcgRGF0ZSgyMDIxLCAxMiwgMzApXG4gKiB9XG4gKiBjb25zdCBtYXRjaGVyMjogRGF0ZVJhbmdlID0ge1xuICogICAgZnJvbTogbmV3IERhdGUoMjAyMiwgNSwgMSksXG4gKiAgICB0bzogbmV3IERhdGUoMjAyMiwgNSwgMjMpXG4gKiB9XG4gKlxuICogY29uc3QgaXNNYXRjaChkYXksIFttYXRjaGVyMSwgbWF0Y2hlcjJdKTsgLy8gdHJ1ZSwgc2luY2UgZGF5IGlzIGluIHRoZSBtYXRjaGVyMSByYW5nZS5cbiAqIGBgYFxuICogKi9cbmZ1bmN0aW9uIGlzTWF0Y2goZGF5LCBtYXRjaGVycykge1xuICAgIHJldHVybiBtYXRjaGVycy5zb21lKGZ1bmN0aW9uIChtYXRjaGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEYXRlVHlwZShtYXRjaGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShkYXksIG1hdGNoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5T2ZEYXRlcyhtYXRjaGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuaW5jbHVkZXMoZGF5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEYXRlUmFuZ2UobWF0Y2hlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RhdGVJblJhbmdlKGRheSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGF5T2ZXZWVrVHlwZShtYXRjaGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuZGF5T2ZXZWVrLmluY2x1ZGVzKGRheS5nZXREYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGF0ZUludGVydmFsKG1hdGNoZXIpKSB7XG4gICAgICAgICAgICB2YXIgZGlmZkJlZm9yZSA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhtYXRjaGVyLmJlZm9yZSwgZGF5KTtcbiAgICAgICAgICAgIHZhciBkaWZmQWZ0ZXIgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMobWF0Y2hlci5hZnRlciwgZGF5KTtcbiAgICAgICAgICAgIHZhciBpc0RheUJlZm9yZSA9IGRpZmZCZWZvcmUgPiAwO1xuICAgICAgICAgICAgdmFyIGlzRGF5QWZ0ZXIgPSBkaWZmQWZ0ZXIgPCAwO1xuICAgICAgICAgICAgdmFyIGlzQ2xvc2VkSW50ZXJ2YWwgPSBpc0FmdGVyKG1hdGNoZXIuYmVmb3JlLCBtYXRjaGVyLmFmdGVyKTtcbiAgICAgICAgICAgIGlmIChpc0Nsb3NlZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF5QWZ0ZXIgJiYgaXNEYXlCZWZvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEYXlCZWZvcmUgfHwgaXNEYXlBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEYXRlQWZ0ZXJUeXBlKG1hdGNoZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKGRheSwgbWF0Y2hlci5hZnRlcikgPiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RhdGVCZWZvcmVUeXBlKG1hdGNoZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKG1hdGNoZXIuYmVmb3JlLCBkYXkpID4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyKGRheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuXG4vKiogUmV0dXJuIHRoZSBhY3RpdmUgbW9kaWZpZXJzIGZvciB0aGUgZ2l2ZW4gZGF5LiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlTW9kaWZpZXJzKGRheSwgXG4vKiogVGhlIG1vZGlmaWVycyB0byBtYXRjaCBmb3IgdGhlIGdpdmVuIGRhdGUuICovXG5tb2RpZmllcnMsIFxuLyoqIFRoZSBtb250aCB3aGVyZSB0aGUgZGF5IGlzIGRpc3BsYXllZCwgdG8gYWRkIHRoZSBcIm91dHNpZGVcIiBtb2RpZmllcnMuICAqL1xuZGlzcGxheU1vbnRoKSB7XG4gICAgdmFyIG1hdGNoZWRNb2RpZmllcnMgPSBPYmplY3Qua2V5cyhtb2RpZmllcnMpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVyID0gbW9kaWZpZXJzW2tleV07XG4gICAgICAgIGlmIChpc01hdGNoKGRheSwgbW9kaWZpZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICAgIHZhciBhY3RpdmVNb2RpZmllcnMgPSB7fTtcbiAgICBtYXRjaGVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiAoYWN0aXZlTW9kaWZpZXJzW21vZGlmaWVyXSA9IHRydWUpOyB9KTtcbiAgICBpZiAoZGlzcGxheU1vbnRoICYmICFpc1NhbWVNb250aChkYXksIGRpc3BsYXlNb250aCkpIHtcbiAgICAgICAgYWN0aXZlTW9kaWZpZXJzLm91dHNpZGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlTW9kaWZpZXJzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRheSB0aGF0IHNob3VsZCBiZSB0aGUgdGFyZ2V0IG9mIHRoZSBmb2N1cyB3aGVuIERheVBpY2tlciBpc1xuICogcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gKlxuICogVE9ETzogdGhpcyBmdW5jdGlvbiBkb2Vzbid0IGNvbnNpZGVyIGlmIHRoZSBkYXkgaXMgb3V0c2lkZSB0aGUgbW9udGguIFdlXG4gKiBpbXBsZW1lbnRlZCB0aGlzIGNoZWNrIGluIGB1c2VEYXlSZW5kZXJgIGJ1dCBpdCBzaG91bGQgcHJvYmFibHkgZ28gaGVyZS4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3BibC9yZWFjdC1kYXktcGlja2VyL3B1bGwvMTU3NlxuICovXG5mdW5jdGlvbiBnZXRJbml0aWFsRm9jdXNUYXJnZXQoZGlzcGxheU1vbnRocywgbW9kaWZpZXJzKSB7XG4gICAgdmFyIGZpcnN0RGF5SW5Nb250aCA9IHN0YXJ0T2ZNb250aChkaXNwbGF5TW9udGhzWzBdKTtcbiAgICB2YXIgbGFzdERheUluTW9udGggPSBlbmRPZk1vbnRoKGRpc3BsYXlNb250aHNbZGlzcGxheU1vbnRocy5sZW5ndGggLSAxXSk7XG4gICAgLy8gVE9ETzogY2xlYW51cCBjb2RlXG4gICAgdmFyIGZpcnN0Rm9jdXNhYmxlRGF5O1xuICAgIHZhciB0b2RheTtcbiAgICB2YXIgZGF0ZSA9IGZpcnN0RGF5SW5Nb250aDtcbiAgICB3aGlsZSAoZGF0ZSA8PSBsYXN0RGF5SW5Nb250aCkge1xuICAgICAgICB2YXIgYWN0aXZlTW9kaWZpZXJzID0gZ2V0QWN0aXZlTW9kaWZpZXJzKGRhdGUsIG1vZGlmaWVycyk7XG4gICAgICAgIHZhciBpc0ZvY3VzYWJsZSA9ICFhY3RpdmVNb2RpZmllcnMuZGlzYWJsZWQgJiYgIWFjdGl2ZU1vZGlmaWVycy5oaWRkZW47XG4gICAgICAgIGlmICghaXNGb2N1c2FibGUpIHtcbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIDEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZU1vZGlmaWVycy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZU1vZGlmaWVycy50b2RheSAmJiAhdG9kYXkpIHtcbiAgICAgICAgICAgIHRvZGF5ID0gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpcnN0Rm9jdXNhYmxlRGF5KSB7XG4gICAgICAgICAgICBmaXJzdEZvY3VzYWJsZURheSA9IGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XG4gICAgfVxuICAgIGlmICh0b2RheSkge1xuICAgICAgICByZXR1cm4gdG9kYXk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmlyc3RGb2N1c2FibGVEYXk7XG4gICAgfVxufVxuXG52YXIgTUFYX1JFVFJZID0gMzY1O1xuLyoqIFJldHVybiB0aGUgbmV4dCBkYXRlIHRvIGJlIGZvY3VzZWQuICovXG5mdW5jdGlvbiBnZXROZXh0Rm9jdXMoZm9jdXNlZERheSwgb3B0aW9ucykge1xuICAgIHZhciBtb3ZlQnkgPSBvcHRpb25zLm1vdmVCeSwgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24sIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQsIG1vZGlmaWVycyA9IG9wdGlvbnMubW9kaWZpZXJzLCBfYSA9IG9wdGlvbnMucmV0cnksIHJldHJ5ID0gX2EgPT09IHZvaWQgMCA/IHsgY291bnQ6IDAsIGxhc3RGb2N1c2VkOiBmb2N1c2VkRGF5IH0gOiBfYTtcbiAgICB2YXIgd2Vla1N0YXJ0c09uID0gY29udGV4dC53ZWVrU3RhcnRzT24sIGZyb21EYXRlID0gY29udGV4dC5mcm9tRGF0ZSwgdG9EYXRlID0gY29udGV4dC50b0RhdGUsIGxvY2FsZSA9IGNvbnRleHQubG9jYWxlO1xuICAgIHZhciBtb3ZlRm5zID0ge1xuICAgICAgICBkYXk6IGFkZERheXMsXG4gICAgICAgIHdlZWs6IGFkZFdlZWtzLFxuICAgICAgICBtb250aDogYWRkTW9udGhzLFxuICAgICAgICB5ZWFyOiBhZGRZZWFycyxcbiAgICAgICAgc3RhcnRPZldlZWs6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5JU09XZWVrXG4gICAgICAgICAgICAgICAgPyBzdGFydE9mSVNPV2VlayhkYXRlKVxuICAgICAgICAgICAgICAgIDogc3RhcnRPZldlZWsoZGF0ZSwgeyBsb2NhbGU6IGxvY2FsZSwgd2Vla1N0YXJ0c09uOiB3ZWVrU3RhcnRzT24gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVuZE9mV2VlazogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LklTT1dlZWtcbiAgICAgICAgICAgICAgICA/IGVuZE9mSVNPV2VlayhkYXRlKVxuICAgICAgICAgICAgICAgIDogZW5kT2ZXZWVrKGRhdGUsIHsgbG9jYWxlOiBsb2NhbGUsIHdlZWtTdGFydHNPbjogd2Vla1N0YXJ0c09uIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgbmV3Rm9jdXNlZERheSA9IG1vdmVGbnNbbW92ZUJ5XShmb2N1c2VkRGF5LCBkaXJlY3Rpb24gPT09ICdhZnRlcicgPyAxIDogLTEpO1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICdiZWZvcmUnICYmIGZyb21EYXRlKSB7XG4gICAgICAgIG5ld0ZvY3VzZWREYXkgPSBtYXgoW2Zyb21EYXRlLCBuZXdGb2N1c2VkRGF5XSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2FmdGVyJyAmJiB0b0RhdGUpIHtcbiAgICAgICAgbmV3Rm9jdXNlZERheSA9IG1pbihbdG9EYXRlLCBuZXdGb2N1c2VkRGF5XSk7XG4gICAgfVxuICAgIHZhciBpc0ZvY3VzYWJsZSA9IHRydWU7XG4gICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICB2YXIgYWN0aXZlTW9kaWZpZXJzID0gZ2V0QWN0aXZlTW9kaWZpZXJzKG5ld0ZvY3VzZWREYXksIG1vZGlmaWVycyk7XG4gICAgICAgIGlzRm9jdXNhYmxlID0gIWFjdGl2ZU1vZGlmaWVycy5kaXNhYmxlZCAmJiAhYWN0aXZlTW9kaWZpZXJzLmhpZGRlbjtcbiAgICB9XG4gICAgaWYgKGlzRm9jdXNhYmxlKSB7XG4gICAgICAgIHJldHVybiBuZXdGb2N1c2VkRGF5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHJldHJ5LmNvdW50ID4gTUFYX1JFVFJZKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnkubGFzdEZvY3VzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldE5leHRGb2N1cyhuZXdGb2N1c2VkRGF5LCB7XG4gICAgICAgICAgICBtb3ZlQnk6IG1vdmVCeSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgICAgICAgcmV0cnk6IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXRyeSksIHsgY291bnQ6IHJldHJ5LmNvdW50ICsgMSB9KVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIEZvY3VzIGNvbnRleHQgc2hhcmVzIGRldGFpbHMgYWJvdXQgdGhlIGZvY3VzZWQgZGF5IGZvciB0aGUga2V5Ym9hcmRcbiAqXG4gKiBBY2Nlc3MgdGhpcyBjb250ZXh0IGZyb20gdGhlIHtAbGluayB1c2VGb2N1c0NvbnRleHR9IGhvb2suXG4gKi9cbnZhciBGb2N1c0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKiogVGhlIHByb3ZpZGVyIGZvciB0aGUge0BsaW5rIEZvY3VzQ29udGV4dH0uICovXG5mdW5jdGlvbiBGb2N1c1Byb3ZpZGVyKHByb3BzKSB7XG4gICAgdmFyIG5hdmlnYXRpb24gPSB1c2VOYXZpZ2F0aW9uKCk7XG4gICAgdmFyIG1vZGlmaWVycyA9IHVzZU1vZGlmaWVycygpO1xuICAgIHZhciBfYSA9IHVzZVN0YXRlKCksIGZvY3VzZWREYXkgPSBfYVswXSwgc2V0Rm9jdXNlZERheSA9IF9hWzFdO1xuICAgIHZhciBfYiA9IHVzZVN0YXRlKCksIGxhc3RGb2N1c2VkID0gX2JbMF0sIHNldExhc3RGb2N1c2VkID0gX2JbMV07XG4gICAgdmFyIGluaXRpYWxGb2N1c1RhcmdldCA9IGdldEluaXRpYWxGb2N1c1RhcmdldChuYXZpZ2F0aW9uLmRpc3BsYXlNb250aHMsIG1vZGlmaWVycyk7XG4gICAgLy8gVE9ETzogY2xlYW51cCBhbmQgdGVzdCBvYnNjdXJlIGNvZGUgYmVsb3dcbiAgICB2YXIgZm9jdXNUYXJnZXQgPSAoZm9jdXNlZERheSAhPT0gbnVsbCAmJiBmb2N1c2VkRGF5ICE9PSB2b2lkIDAgPyBmb2N1c2VkRGF5IDogKGxhc3RGb2N1c2VkICYmIG5hdmlnYXRpb24uaXNEYXRlRGlzcGxheWVkKGxhc3RGb2N1c2VkKSkpXG4gICAgICAgID8gbGFzdEZvY3VzZWRcbiAgICAgICAgOiBpbml0aWFsRm9jdXNUYXJnZXQ7XG4gICAgdmFyIGJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldExhc3RGb2N1c2VkKGZvY3VzZWREYXkpO1xuICAgICAgICBzZXRGb2N1c2VkRGF5KHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICB2YXIgZm9jdXMgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICBzZXRGb2N1c2VkRGF5KGRhdGUpO1xuICAgIH07XG4gICAgdmFyIGNvbnRleHQgPSB1c2VEYXlQaWNrZXIoKTtcbiAgICB2YXIgbW92ZUZvY3VzID0gZnVuY3Rpb24gKG1vdmVCeSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGlmICghZm9jdXNlZERheSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG5leHRGb2N1c2VkID0gZ2V0TmV4dEZvY3VzKGZvY3VzZWREYXksIHtcbiAgICAgICAgICAgIG1vdmVCeTogbW92ZUJ5LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1NhbWVEYXkoZm9jdXNlZERheSwgbmV4dEZvY3VzZWQpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgbmF2aWdhdGlvbi5nb1RvRGF0ZShuZXh0Rm9jdXNlZCwgZm9jdXNlZERheSk7XG4gICAgICAgIGZvY3VzKG5leHRGb2N1c2VkKTtcbiAgICB9O1xuICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgZm9jdXNlZERheTogZm9jdXNlZERheSxcbiAgICAgICAgZm9jdXNUYXJnZXQ6IGZvY3VzVGFyZ2V0LFxuICAgICAgICBibHVyOiBibHVyLFxuICAgICAgICBmb2N1czogZm9jdXMsXG4gICAgICAgIGZvY3VzRGF5QWZ0ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdmVGb2N1cygnZGF5JywgJ2FmdGVyJyk7IH0sXG4gICAgICAgIGZvY3VzRGF5QmVmb3JlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlRm9jdXMoJ2RheScsICdiZWZvcmUnKTsgfSxcbiAgICAgICAgZm9jdXNXZWVrQWZ0ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdmVGb2N1cygnd2VlaycsICdhZnRlcicpOyB9LFxuICAgICAgICBmb2N1c1dlZWtCZWZvcmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdmVGb2N1cygnd2VlaycsICdiZWZvcmUnKTsgfSxcbiAgICAgICAgZm9jdXNNb250aEJlZm9yZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW92ZUZvY3VzKCdtb250aCcsICdiZWZvcmUnKTsgfSxcbiAgICAgICAgZm9jdXNNb250aEFmdGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlRm9jdXMoJ21vbnRoJywgJ2FmdGVyJyk7IH0sXG4gICAgICAgIGZvY3VzWWVhckJlZm9yZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW92ZUZvY3VzKCd5ZWFyJywgJ2JlZm9yZScpOyB9LFxuICAgICAgICBmb2N1c1llYXJBZnRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW92ZUZvY3VzKCd5ZWFyJywgJ2FmdGVyJyk7IH0sXG4gICAgICAgIGZvY3VzU3RhcnRPZldlZWs6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdmVGb2N1cygnc3RhcnRPZldlZWsnLCAnYmVmb3JlJyk7IH0sXG4gICAgICAgIGZvY3VzRW5kT2ZXZWVrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlRm9jdXMoJ2VuZE9mV2VlaycsICdhZnRlcicpOyB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChGb2N1c0NvbnRleHQuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IHZhbHVlIH0sIHsgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKSk7XG59XG4vKipcbiAqIEhvb2sgdG8gYWNjZXNzIHRoZSB7QGxpbmsgRm9jdXNDb250ZXh0VmFsdWV9LiBVc2UgdGhpcyBob29rIHRvIGhhbmRsZSB0aGVcbiAqIGZvY3VzIHN0YXRlIG9mIHRoZSBlbGVtZW50cy5cbiAqXG4gKiBUaGlzIGhvb2sgaXMgbWVhbnQgdG8gYmUgdXNlZCBpbnNpZGUgaW50ZXJuYWwgb3IgY3VzdG9tIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHVzZUZvY3VzQ29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoRm9jdXNDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VGb2N1c0NvbnRleHQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEZvY3VzUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhY3RpdmUgbW9kaWZpZXJzIGZvciB0aGUgc3BlY2lmaWVkIGRheS5cbiAqXG4gKiBUaGlzIGhvb2sgaXMgbWVhbnQgdG8gYmUgdXNlZCBpbnNpZGUgaW50ZXJuYWwgb3IgY3VzdG9tIGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIGRheVxuICogQHBhcmFtIGRpc3BsYXlNb250aFxuICovXG5mdW5jdGlvbiB1c2VBY3RpdmVNb2RpZmllcnMoZGF5LCBcbi8qKlxuICogVGhlIG1vbnRoIHdoZXJlIHRoZSBkYXRlIGlzIGRpc3BsYXllZC4gSWYgbm90IHRoZSBzYW1lIGFzIGBkYXRlYCwgdGhlIGRheVxuICogaXMgYW4gXCJvdXRzaWRlIGRheVwiLlxuICovXG5kaXNwbGF5TW9udGgpIHtcbiAgICB2YXIgbW9kaWZpZXJzID0gdXNlTW9kaWZpZXJzKCk7XG4gICAgdmFyIGFjdGl2ZU1vZGlmaWVycyA9IGdldEFjdGl2ZU1vZGlmaWVycyhkYXksIG1vZGlmaWVycywgZGlzcGxheU1vbnRoKTtcbiAgICByZXR1cm4gYWN0aXZlTW9kaWZpZXJzO1xufVxuXG4vKipcbiAqIFRoZSBTZWxlY3RTaW5nbGUgY29udGV4dCBzaGFyZXMgZGV0YWlscyBhYm91dCB0aGUgc2VsZWN0ZWQgZGF5cyB3aGVuIGluXG4gKiBzaW5nbGUgc2VsZWN0aW9uIG1vZGUuXG4gKlxuICogQWNjZXNzIHRoaXMgY29udGV4dCBmcm9tIHRoZSB7QGxpbmsgdXNlU2VsZWN0U2luZ2xlfSBob29rLlxuICovXG52YXIgU2VsZWN0U2luZ2xlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKiBQcm92aWRlcyB0aGUgdmFsdWVzIGZvciB0aGUge0BsaW5rIFNlbGVjdFNpbmdsZVByb3ZpZGVyfS4gKi9cbmZ1bmN0aW9uIFNlbGVjdFNpbmdsZVByb3ZpZGVyKHByb3BzKSB7XG4gICAgaWYgKCFpc0RheVBpY2tlclNpbmdsZShwcm9wcy5pbml0aWFsUHJvcHMpKSB7XG4gICAgICAgIHZhciBlbXB0eUNvbnRleHRWYWx1ZSA9IHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goU2VsZWN0U2luZ2xlQ29udGV4dC5Qcm92aWRlciwgX19hc3NpZ24oeyB2YWx1ZTogZW1wdHlDb250ZXh0VmFsdWUgfSwgeyBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goU2VsZWN0U2luZ2xlUHJvdmlkZXJJbnRlcm5hbCwgeyBpbml0aWFsUHJvcHM6IHByb3BzLmluaXRpYWxQcm9wcywgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pKTtcbn1cbmZ1bmN0aW9uIFNlbGVjdFNpbmdsZVByb3ZpZGVySW50ZXJuYWwoX2EpIHtcbiAgICB2YXIgaW5pdGlhbFByb3BzID0gX2EuaW5pdGlhbFByb3BzLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgIHZhciBvbkRheUNsaWNrID0gZnVuY3Rpb24gKGRheSwgYWN0aXZlTW9kaWZpZXJzLCBlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAoX2EgPSBpbml0aWFsUHJvcHMub25EYXlDbGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW5pdGlhbFByb3BzLCBkYXksIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgICAgIGlmIChhY3RpdmVNb2RpZmllcnMuc2VsZWN0ZWQgJiYgIWluaXRpYWxQcm9wcy5yZXF1aXJlZCkge1xuICAgICAgICAgICAgKF9iID0gaW5pdGlhbFByb3BzLm9uU2VsZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChpbml0aWFsUHJvcHMsIHVuZGVmaW5lZCwgZGF5LCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIChfYyA9IGluaXRpYWxQcm9wcy5vblNlbGVjdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoaW5pdGlhbFByb3BzLCBkYXksIGRheSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICB9O1xuICAgIHZhciBjb250ZXh0VmFsdWUgPSB7XG4gICAgICAgIHNlbGVjdGVkOiBpbml0aWFsUHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgIG9uRGF5Q2xpY2s6IG9uRGF5Q2xpY2tcbiAgICB9O1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFNlbGVjdFNpbmdsZUNvbnRleHQuUHJvdmlkZXIsIF9fYXNzaWduKHsgdmFsdWU6IGNvbnRleHRWYWx1ZSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xufVxuLyoqXG4gKiBIb29rIHRvIGFjY2VzcyB0aGUge0BsaW5rIFNlbGVjdFNpbmdsZUNvbnRleHRWYWx1ZX0uXG4gKlxuICogVGhpcyBob29rIGlzIG1lYW50IHRvIGJlIHVzZWQgaW5zaWRlIGludGVybmFsIG9yIGN1c3RvbSBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiB1c2VTZWxlY3RTaW5nbGUoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNlbGVjdFNpbmdsZUNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVNlbGVjdFNpbmdsZSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgU2VsZWN0U2luZ2xlUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgZGV0YWlscyBhYm91dCB0aGUgY29udGVudCB0byByZW5kZXIgaW4gdGhlIGRheSBjZWxsLlxuICpcbiAqXG4gKiBXaGVuIGEgZGF5IGNlbGwgaXMgcmVuZGVyZWQgaW4gdGhlIHRhYmxlLCBEYXlQaWNrZXIgY2FuIGVpdGhlcjpcbiAqXG4gKiAtIHJlbmRlciBub3RoaW5nOiB3aGVuIHRoZSBkYXkgaXMgb3V0c2lkZSB0aGUgbW9udGggb3IgaGFzIG1hdGNoZWQgdGhlXG4gKiAgIFwiaGlkZGVuXCIgbW9kaWZpZXIuXG4gKiAtIHJlbmRlciBhIGJ1dHRvbiB3aGVuIGBvbkRheUNsaWNrYCBvciBhIHNlbGVjdGlvbiBtb2RlIGlzIHNldC5cbiAqIC0gcmVuZGVyIGEgbm9uLWludGVyYWN0aXZlIGVsZW1lbnQ6IHdoZW4gbm8gc2VsZWN0aW9uIG1vZGUgaXMgc2V0LCB0aGUgZGF5XG4gKiAgIGNlbGwgc2hvdWxkbuKAmXQgcmVzcG9uZCB0byBhbnkgaW50ZXJhY3Rpb24uIERheVBpY2tlciBzaG91bGQgcmVuZGVyIGEgYGRpdmBcbiAqICAgb3IgYSBgc3BhbmAuXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogVXNlIHRoaXMgaG9vayB0byBjdXN0b21pemUgdGhlIGJlaGF2aW9yIG9mIHRoZSB7QGxpbmsgRGF5fSBjb21wb25lbnQuIENyZWF0ZSBhXG4gKiBuZXcgYERheWAgY29tcG9uZW50IHVzaW5nIHRoaXMgaG9vayBhbmQgcGFzcyBpdCB0byB0aGUgYGNvbXBvbmVudHNgIHByb3AuXG4gKiBUaGUgc291cmNlIG9mIHtAbGluayBEYXl9IGNhbiBiZSBhIGdvb2Qgc3RhcnRpbmcgcG9pbnQuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VEYXlFdmVudEhhbmRsZXJzKGRhdGUsIGFjdGl2ZU1vZGlmaWVycykge1xuICAgIHZhciBkYXlQaWNrZXIgPSB1c2VEYXlQaWNrZXIoKTtcbiAgICB2YXIgc2luZ2xlID0gdXNlU2VsZWN0U2luZ2xlKCk7XG4gICAgdmFyIG11bHRpcGxlID0gdXNlU2VsZWN0TXVsdGlwbGUoKTtcbiAgICB2YXIgcmFuZ2UgPSB1c2VTZWxlY3RSYW5nZSgpO1xuICAgIHZhciBfYSA9IHVzZUZvY3VzQ29udGV4dCgpLCBmb2N1c0RheUFmdGVyID0gX2EuZm9jdXNEYXlBZnRlciwgZm9jdXNEYXlCZWZvcmUgPSBfYS5mb2N1c0RheUJlZm9yZSwgZm9jdXNXZWVrQWZ0ZXIgPSBfYS5mb2N1c1dlZWtBZnRlciwgZm9jdXNXZWVrQmVmb3JlID0gX2EuZm9jdXNXZWVrQmVmb3JlLCBibHVyID0gX2EuYmx1ciwgZm9jdXMgPSBfYS5mb2N1cywgZm9jdXNNb250aEJlZm9yZSA9IF9hLmZvY3VzTW9udGhCZWZvcmUsIGZvY3VzTW9udGhBZnRlciA9IF9hLmZvY3VzTW9udGhBZnRlciwgZm9jdXNZZWFyQmVmb3JlID0gX2EuZm9jdXNZZWFyQmVmb3JlLCBmb2N1c1llYXJBZnRlciA9IF9hLmZvY3VzWWVhckFmdGVyLCBmb2N1c1N0YXJ0T2ZXZWVrID0gX2EuZm9jdXNTdGFydE9mV2VlaywgZm9jdXNFbmRPZldlZWsgPSBfYS5mb2N1c0VuZE9mV2VlaztcbiAgICB2YXIgb25DbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKGlzRGF5UGlja2VyU2luZ2xlKGRheVBpY2tlcikpIHtcbiAgICAgICAgICAgIChfYSA9IHNpbmdsZS5vbkRheUNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzaW5nbGUsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXlQaWNrZXJNdWx0aXBsZShkYXlQaWNrZXIpKSB7XG4gICAgICAgICAgICAoX2IgPSBtdWx0aXBsZS5vbkRheUNsaWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChtdWx0aXBsZSwgZGF0ZSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RheVBpY2tlclJhbmdlKGRheVBpY2tlcikpIHtcbiAgICAgICAgICAgIChfYyA9IHJhbmdlLm9uRGF5Q2xpY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHJhbmdlLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKF9kID0gZGF5UGlja2VyLm9uRGF5Q2xpY2spID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKGRheVBpY2tlciwgZGF0ZSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uRm9jdXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGZvY3VzKGRhdGUpO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlGb2N1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uQmx1ciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYmx1cigpO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlCbHVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkYXlQaWNrZXIsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgb25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlNb3VzZUVudGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkYXlQaWNrZXIsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgb25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlNb3VzZUxlYXZlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkYXlQaWNrZXIsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgb25Qb2ludGVyRW50ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGRheVBpY2tlci5vbkRheVBvaW50ZXJFbnRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uUG9pbnRlckxlYXZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlQb2ludGVyTGVhdmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRheVBpY2tlciwgZGF0ZSwgYWN0aXZlTW9kaWZpZXJzLCBlKTtcbiAgICB9O1xuICAgIHZhciBvblRvdWNoQ2FuY2VsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlUb3VjaENhbmNlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uVG91Y2hFbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGRheVBpY2tlci5vbkRheVRvdWNoRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkYXlQaWNrZXIsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgb25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGRheVBpY2tlci5vbkRheVRvdWNoTW92ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gZGF5UGlja2VyLm9uRGF5VG91Y2hTdGFydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZGF5UGlja2VyLCBkYXRlLCBhY3RpdmVNb2RpZmllcnMsIGUpO1xuICAgIH07XG4gICAgdmFyIG9uS2V5VXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGRheVBpY2tlci5vbkRheUtleVVwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkYXlQaWNrZXIsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgb25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGRheVBpY2tlci5kaXIgPT09ICdydGwnID8gZm9jdXNEYXlBZnRlcigpIDogZm9jdXNEYXlCZWZvcmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGRheVBpY2tlci5kaXIgPT09ICdydGwnID8gZm9jdXNEYXlCZWZvcmUoKSA6IGZvY3VzRGF5QWZ0ZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZm9jdXNXZWVrQWZ0ZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGZvY3VzV2Vla0JlZm9yZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnNoaWZ0S2V5ID8gZm9jdXNZZWFyQmVmb3JlKCkgOiBmb2N1c01vbnRoQmVmb3JlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5zaGlmdEtleSA/IGZvY3VzWWVhckFmdGVyKCkgOiBmb2N1c01vbnRoQWZ0ZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0hvbWUnOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGZvY3VzU3RhcnRPZldlZWsoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VuZCc6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZm9jdXNFbmRPZldlZWsoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSBkYXlQaWNrZXIub25EYXlLZXlEb3duKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkYXlQaWNrZXIsIGRhdGUsIGFjdGl2ZU1vZGlmaWVycywgZSk7XG4gICAgfTtcbiAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHtcbiAgICAgICAgb25DbGljazogb25DbGljayxcbiAgICAgICAgb25Gb2N1czogb25Gb2N1cyxcbiAgICAgICAgb25CbHVyOiBvbkJsdXIsXG4gICAgICAgIG9uS2V5RG93bjogb25LZXlEb3duLFxuICAgICAgICBvbktleVVwOiBvbktleVVwLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmUsXG4gICAgICAgIG9uUG9pbnRlckVudGVyOiBvblBvaW50ZXJFbnRlcixcbiAgICAgICAgb25Qb2ludGVyTGVhdmU6IG9uUG9pbnRlckxlYXZlLFxuICAgICAgICBvblRvdWNoQ2FuY2VsOiBvblRvdWNoQ2FuY2VsLFxuICAgICAgICBvblRvdWNoRW5kOiBvblRvdWNoRW5kLFxuICAgICAgICBvblRvdWNoTW92ZTogb25Ub3VjaE1vdmUsXG4gICAgICAgIG9uVG91Y2hTdGFydDogb25Ub3VjaFN0YXJ0XG4gICAgfTtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVycztcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGN1cnJlbnQgc2VsZWN0ZWQgZGF5cyB3aGVuIERheVBpY2tlciBpcyBpbiBzZWxlY3Rpb24gbW9kZS4gRGF5c1xuICogc2VsZWN0ZWQgYnkgdGhlIGN1c3RvbSBzZWxlY3Rpb24gbW9kZSBhcmUgbm90IHJldHVybmVkLlxuICpcbiAqIFRoaXMgaG9vayBpcyBtZWFudCB0byBiZSB1c2VkIGluc2lkZSBpbnRlcm5hbCBvciBjdXN0b20gY29tcG9uZW50cy5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZVNlbGVjdGVkRGF5cygpIHtcbiAgICB2YXIgZGF5UGlja2VyID0gdXNlRGF5UGlja2VyKCk7XG4gICAgdmFyIHNpbmdsZSA9IHVzZVNlbGVjdFNpbmdsZSgpO1xuICAgIHZhciBtdWx0aXBsZSA9IHVzZVNlbGVjdE11bHRpcGxlKCk7XG4gICAgdmFyIHJhbmdlID0gdXNlU2VsZWN0UmFuZ2UoKTtcbiAgICB2YXIgc2VsZWN0ZWREYXlzID0gaXNEYXlQaWNrZXJTaW5nbGUoZGF5UGlja2VyKVxuICAgICAgICA/IHNpbmdsZS5zZWxlY3RlZFxuICAgICAgICA6IGlzRGF5UGlja2VyTXVsdGlwbGUoZGF5UGlja2VyKVxuICAgICAgICAgICAgPyBtdWx0aXBsZS5zZWxlY3RlZFxuICAgICAgICAgICAgOiBpc0RheVBpY2tlclJhbmdlKGRheVBpY2tlcilcbiAgICAgICAgICAgICAgICA/IHJhbmdlLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHNlbGVjdGVkRGF5cztcbn1cblxuZnVuY3Rpb24gaXNJbnRlcm5hbE1vZGlmaWVyKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoSW50ZXJuYWxNb2RpZmllcikuaW5jbHVkZXMobW9kaWZpZXIpO1xufVxuLyoqXG4gKiBSZXR1cm4gdGhlIGNsYXNzIG5hbWVzIGZvciB0aGUgRGF5IGVsZW1lbnQsIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYWN0aXZlXG4gKiBtb2RpZmllcnMuXG4gKlxuICogQ3VzdG9tIGNsYXNzIG5hbWVzIGFyZSBzZXQgdmlhIGBtb2RpZmllcnNDbGFzc05hbWVzYCBvciBgY2xhc3NOYW1lc2AsXG4gKiB3aGVyZSB0aGUgZmlyc3QgaGF2ZSB0aGUgcHJlY2VkZW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGF5Q2xhc3NOYW1lcyhkYXlQaWNrZXIsIGFjdGl2ZU1vZGlmaWVycykge1xuICAgIHZhciBjbGFzc05hbWVzID0gW2RheVBpY2tlci5jbGFzc05hbWVzLmRheV07XG4gICAgT2JqZWN0LmtleXMoYWN0aXZlTW9kaWZpZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICB2YXIgY3VzdG9tQ2xhc3NOYW1lID0gZGF5UGlja2VyLm1vZGlmaWVyc0NsYXNzTmFtZXNbbW9kaWZpZXJdO1xuICAgICAgICBpZiAoY3VzdG9tQ2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goY3VzdG9tQ2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0ludGVybmFsTW9kaWZpZXIobW9kaWZpZXIpKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJuYWxDbGFzc05hbWUgPSBkYXlQaWNrZXIuY2xhc3NOYW1lc1tcImRheV9cIi5jb25jYXQobW9kaWZpZXIpXTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbENsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaChpbnRlcm5hbENsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cblxuLyoqIFJldHVybiB0aGUgc3R5bGUgZm9yIHRoZSBEYXkgZWxlbWVudCwgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBhY3RpdmUgbW9kaWZpZXJzLiAqL1xuZnVuY3Rpb24gZ2V0RGF5U3R5bGUoZGF5UGlja2VyLCBhY3RpdmVNb2RpZmllcnMpIHtcbiAgICB2YXIgc3R5bGUgPSBfX2Fzc2lnbih7fSwgZGF5UGlja2VyLnN0eWxlcy5kYXkpO1xuICAgIE9iamVjdC5rZXlzKGFjdGl2ZU1vZGlmaWVycykuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdHlsZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZSksIChfYSA9IGRheVBpY2tlci5tb2RpZmllcnNTdHlsZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVttb2RpZmllcl0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gcHJvcHMgYW5kIGRhdGEgdXNlZCB0byByZW5kZXIgdGhlIHtAbGluayBEYXl9IGNvbXBvbmVudC5cbiAqXG4gKiBVc2UgdGhpcyBob29rIHdoZW4gY3JlYXRpbmcgYSBjb21wb25lbnQgdG8gcmVwbGFjZSB0aGUgYnVpbHQtaW4gYERheWBcbiAqIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gdXNlRGF5UmVuZGVyKFxuLyoqIFRoZSBkYXRlIHRvIHJlbmRlci4gKi9cbmRheSwgXG4vKiogVGhlIG1vbnRoIHdoZXJlIHRoZSBkYXRlIGlzIGRpc3BsYXllZCAoaWYgbm90IHRoZSBzYW1lIGFzIGBkYXRlYCwgaXQgbWVhbnMgaXQgaXMgYW4gXCJvdXRzaWRlXCIgZGF5KS4gKi9cbmRpc3BsYXlNb250aCwgXG4vKiogQSByZWYgdG8gdGhlIGJ1dHRvbiBlbGVtZW50IHRoYXQgd2lsbCBiZSB0YXJnZXQgb2YgZm9jdXMgd2hlbiByZW5kZXJlZCAoaWYgcmVxdWlyZWQpLiAqL1xuYnV0dG9uUmVmKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYiwgX2M7XG4gICAgdmFyIGRheVBpY2tlciA9IHVzZURheVBpY2tlcigpO1xuICAgIHZhciBmb2N1c0NvbnRleHQgPSB1c2VGb2N1c0NvbnRleHQoKTtcbiAgICB2YXIgYWN0aXZlTW9kaWZpZXJzID0gdXNlQWN0aXZlTW9kaWZpZXJzKGRheSwgZGlzcGxheU1vbnRoKTtcbiAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHVzZURheUV2ZW50SGFuZGxlcnMoZGF5LCBhY3RpdmVNb2RpZmllcnMpO1xuICAgIHZhciBzZWxlY3RlZERheXMgPSB1c2VTZWxlY3RlZERheXMoKTtcbiAgICB2YXIgaXNCdXR0b24gPSBCb29sZWFuKGRheVBpY2tlci5vbkRheUNsaWNrIHx8IGRheVBpY2tlci5tb2RlICE9PSAnZGVmYXVsdCcpO1xuICAgIC8vIEZvY3VzIHRoZSBidXR0b24gaWYgdGhlIGRheSBpcyBmb2N1c2VkIGFjY29yZGluZyB0byB0aGUgZm9jdXMgY29udGV4dFxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGFjdGl2ZU1vZGlmaWVycy5vdXRzaWRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWZvY3VzQ29udGV4dC5mb2N1c2VkRGF5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWlzQnV0dG9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXNTYW1lRGF5KGZvY3VzQ29udGV4dC5mb2N1c2VkRGF5LCBkYXkpKSB7XG4gICAgICAgICAgICAoX2EgPSBidXR0b25SZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGZvY3VzQ29udGV4dC5mb2N1c2VkRGF5LFxuICAgICAgICBkYXksXG4gICAgICAgIGJ1dHRvblJlZixcbiAgICAgICAgaXNCdXR0b24sXG4gICAgICAgIGFjdGl2ZU1vZGlmaWVycy5vdXRzaWRlXG4gICAgXSk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGdldERheUNsYXNzTmFtZXMoZGF5UGlja2VyLCBhY3RpdmVNb2RpZmllcnMpLmpvaW4oJyAnKTtcbiAgICB2YXIgc3R5bGUgPSBnZXREYXlTdHlsZShkYXlQaWNrZXIsIGFjdGl2ZU1vZGlmaWVycyk7XG4gICAgdmFyIGlzSGlkZGVuID0gQm9vbGVhbigoYWN0aXZlTW9kaWZpZXJzLm91dHNpZGUgJiYgIWRheVBpY2tlci5zaG93T3V0c2lkZURheXMpIHx8XG4gICAgICAgIGFjdGl2ZU1vZGlmaWVycy5oaWRkZW4pO1xuICAgIHZhciBEYXlDb250ZW50Q29tcG9uZW50ID0gKF9jID0gKF9iID0gZGF5UGlja2VyLmNvbXBvbmVudHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5EYXlDb250ZW50KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBEYXlDb250ZW50O1xuICAgIHZhciBjaGlsZHJlbiA9IChqc3hSdW50aW1lRXhwb3J0cy5qc3goRGF5Q29udGVudENvbXBvbmVudCwgeyBkYXRlOiBkYXksIGRpc3BsYXlNb250aDogZGlzcGxheU1vbnRoLCBhY3RpdmVNb2RpZmllcnM6IGFjdGl2ZU1vZGlmaWVycyB9KSk7XG4gICAgdmFyIGRpdlByb3BzID0ge1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIHJvbGU6ICdncmlkY2VsbCdcbiAgICB9O1xuICAgIHZhciBpc0ZvY3VzVGFyZ2V0ID0gZm9jdXNDb250ZXh0LmZvY3VzVGFyZ2V0ICYmXG4gICAgICAgIGlzU2FtZURheShmb2N1c0NvbnRleHQuZm9jdXNUYXJnZXQsIGRheSkgJiZcbiAgICAgICAgIWFjdGl2ZU1vZGlmaWVycy5vdXRzaWRlO1xuICAgIHZhciBpc0ZvY3VzZWQgPSBmb2N1c0NvbnRleHQuZm9jdXNlZERheSAmJiBpc1NhbWVEYXkoZm9jdXNDb250ZXh0LmZvY3VzZWREYXksIGRheSk7XG4gICAgdmFyIGJ1dHRvblByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGRpdlByb3BzKSwgKF9hID0geyBkaXNhYmxlZDogYWN0aXZlTW9kaWZpZXJzLmRpc2FibGVkLCByb2xlOiAnZ3JpZGNlbGwnIH0sIF9hWydhcmlhLXNlbGVjdGVkJ10gPSBhY3RpdmVNb2RpZmllcnMuc2VsZWN0ZWQsIF9hLnRhYkluZGV4ID0gaXNGb2N1c2VkIHx8IGlzRm9jdXNUYXJnZXQgPyAwIDogLTEsIF9hKSksIGV2ZW50SGFuZGxlcnMpO1xuICAgIHZhciBkYXlSZW5kZXIgPSB7XG4gICAgICAgIGlzQnV0dG9uOiBpc0J1dHRvbixcbiAgICAgICAgaXNIaWRkZW46IGlzSGlkZGVuLFxuICAgICAgICBhY3RpdmVNb2RpZmllcnM6IGFjdGl2ZU1vZGlmaWVycyxcbiAgICAgICAgc2VsZWN0ZWREYXlzOiBzZWxlY3RlZERheXMsXG4gICAgICAgIGJ1dHRvblByb3BzOiBidXR0b25Qcm9wcyxcbiAgICAgICAgZGl2UHJvcHM6IGRpdlByb3BzXG4gICAgfTtcbiAgICByZXR1cm4gZGF5UmVuZGVyO1xufVxuXG4vKipcbiAqIFRoZSBjb250ZW50IG9mIGEgZGF5IGNlbGwg4oCTIGFzIGEgYnV0dG9uIG9yIHNwYW4gZWxlbWVudCBhY2NvcmRpbmcgdG8gaXRzXG4gKiBtb2RpZmllcnMuXG4gKi9cbmZ1bmN0aW9uIERheShwcm9wcykge1xuICAgIHZhciBidXR0b25SZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdmFyIGRheVJlbmRlciA9IHVzZURheVJlbmRlcihwcm9wcy5kYXRlLCBwcm9wcy5kaXNwbGF5TW9udGgsIGJ1dHRvblJlZik7XG4gICAgaWYgKGRheVJlbmRlci5pc0hpZGRlbikge1xuICAgICAgICByZXR1cm4ganN4UnVudGltZUV4cG9ydHMuanN4KFwiZGl2XCIsIHsgcm9sZTogXCJncmlkY2VsbFwiIH0pO1xuICAgIH1cbiAgICBpZiAoIWRheVJlbmRlci5pc0J1dHRvbikge1xuICAgICAgICByZXR1cm4ganN4UnVudGltZUV4cG9ydHMuanN4KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBkYXlSZW5kZXIuZGl2UHJvcHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChCdXR0b24sIF9fYXNzaWduKHsgbmFtZTogXCJkYXlcIiwgcmVmOiBidXR0b25SZWYgfSwgZGF5UmVuZGVyLmJ1dHRvblByb3BzKSk7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSB3ZWVrIG51bWJlciBlbGVtZW50LiBJZiBgb25XZWVrTnVtYmVyQ2xpY2tgIGlzIHBhc3NlZCB0byBEYXlQaWNrZXIsIGl0XG4gKiByZW5kZXJzIGEgYnV0dG9uLCBvdGhlcndpc2UgYSBzcGFuIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIFdlZWtOdW1iZXIocHJvcHMpIHtcbiAgICB2YXIgd2Vla051bWJlciA9IHByb3BzLm51bWJlciwgZGF0ZXMgPSBwcm9wcy5kYXRlcztcbiAgICB2YXIgX2EgPSB1c2VEYXlQaWNrZXIoKSwgb25XZWVrTnVtYmVyQ2xpY2sgPSBfYS5vbldlZWtOdW1iZXJDbGljaywgc3R5bGVzID0gX2Euc3R5bGVzLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcywgbG9jYWxlID0gX2EubG9jYWxlLCBsYWJlbFdlZWtOdW1iZXIgPSBfYS5sYWJlbHMubGFiZWxXZWVrTnVtYmVyLCBmb3JtYXRXZWVrTnVtYmVyID0gX2EuZm9ybWF0dGVycy5mb3JtYXRXZWVrTnVtYmVyO1xuICAgIHZhciBjb250ZW50ID0gZm9ybWF0V2Vla051bWJlcihOdW1iZXIod2Vla051bWJlciksIHsgbG9jYWxlOiBsb2NhbGUgfSk7XG4gICAgaWYgKCFvbldlZWtOdW1iZXJDbGljaykge1xuICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInNwYW5cIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMud2Vla251bWJlciwgc3R5bGU6IHN0eWxlcy53ZWVrbnVtYmVyIH0sIHsgY2hpbGRyZW46IGNvbnRlbnQgfSkpKTtcbiAgICB9XG4gICAgdmFyIGxhYmVsID0gbGFiZWxXZWVrTnVtYmVyKE51bWJlcih3ZWVrTnVtYmVyKSwgeyBsb2NhbGU6IGxvY2FsZSB9KTtcbiAgICB2YXIgaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBvbldlZWtOdW1iZXJDbGljayh3ZWVrTnVtYmVyLCBkYXRlcywgZSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChCdXR0b24sIF9fYXNzaWduKHsgbmFtZTogXCJ3ZWVrLW51bWJlclwiLCBcImFyaWEtbGFiZWxcIjogbGFiZWwsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy53ZWVrbnVtYmVyLCBzdHlsZTogc3R5bGVzLndlZWtudW1iZXIsIG9uQ2xpY2s6IGhhbmRsZUNsaWNrIH0sIHsgY2hpbGRyZW46IGNvbnRlbnQgfSkpKTtcbn1cblxuLyoqIFJlbmRlciBhIHJvdyBpbiB0aGUgY2FsZW5kYXIsIHdpdGggdGhlIGRheXMgYW5kIHRoZSB3ZWVrIG51bWJlci4gKi9cbmZ1bmN0aW9uIFJvdyhwcm9wcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIF9jID0gdXNlRGF5UGlja2VyKCksIHN0eWxlcyA9IF9jLnN0eWxlcywgY2xhc3NOYW1lcyA9IF9jLmNsYXNzTmFtZXMsIHNob3dXZWVrTnVtYmVyID0gX2Muc2hvd1dlZWtOdW1iZXIsIGNvbXBvbmVudHMgPSBfYy5jb21wb25lbnRzO1xuICAgIHZhciBEYXlDb21wb25lbnQgPSAoX2EgPSBjb21wb25lbnRzID09PSBudWxsIHx8IGNvbXBvbmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudHMuRGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBEYXk7XG4gICAgdmFyIFdlZWtudW1iZXJDb21wb25lbnQgPSAoX2IgPSBjb21wb25lbnRzID09PSBudWxsIHx8IGNvbXBvbmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudHMuV2Vla051bWJlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogV2Vla051bWJlcjtcbiAgICB2YXIgd2Vla051bWJlckNlbGw7XG4gICAgaWYgKHNob3dXZWVrTnVtYmVyKSB7XG4gICAgICAgIHdlZWtOdW1iZXJDZWxsID0gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInRkXCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNlbGwsIHN0eWxlOiBzdHlsZXMuY2VsbCB9LCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goV2Vla251bWJlckNvbXBvbmVudCwgeyBudW1iZXI6IHByb3BzLndlZWtOdW1iZXIsIGRhdGVzOiBwcm9wcy5kYXRlcyB9KSB9KSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeHMoXCJ0clwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5yb3csIHN0eWxlOiBzdHlsZXMucm93IH0sIHsgY2hpbGRyZW46IFt3ZWVrTnVtYmVyQ2VsbCwgcHJvcHMuZGF0ZXMubWFwKGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwidGRcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuY2VsbCwgc3R5bGU6IHN0eWxlcy5jZWxsLCByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChEYXlDb21wb25lbnQsIHsgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGgsIGRhdGU6IGRhdGUgfSkgfSksIGdldFVuaXhUaW1lKGRhdGUpKSk7IH0pXSB9KSkpO1xufVxuXG4vKiogUmV0dXJuIHRoZSB3ZWVrcyBiZXR3ZWVuIHR3byBkYXRlcy4gICovXG5mdW5jdGlvbiBkYXlzVG9Nb250aFdlZWtzKGZyb21EYXRlLCB0b0RhdGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgdG9XZWVrID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5JU09XZWVrKVxuICAgICAgICA/IGVuZE9mSVNPV2Vlayh0b0RhdGUpXG4gICAgICAgIDogZW5kT2ZXZWVrKHRvRGF0ZSwgb3B0aW9ucyk7XG4gICAgdmFyIGZyb21XZWVrID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5JU09XZWVrKVxuICAgICAgICA/IHN0YXJ0T2ZJU09XZWVrKGZyb21EYXRlKVxuICAgICAgICA6IHN0YXJ0T2ZXZWVrKGZyb21EYXRlLCBvcHRpb25zKTtcbiAgICB2YXIgbk9mRGF5cyA9IGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyh0b1dlZWssIGZyb21XZWVrKTtcbiAgICB2YXIgZGF5cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG5PZkRheXM7IGkrKykge1xuICAgICAgICBkYXlzLnB1c2goYWRkRGF5cyhmcm9tV2VlaywgaSkpO1xuICAgIH1cbiAgICB2YXIgd2Vla3NJbk1vbnRoID0gZGF5cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZGF0ZSkge1xuICAgICAgICB2YXIgd2Vla051bWJlciA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuSVNPV2VlaylcbiAgICAgICAgICAgID8gZ2V0SVNPV2VlayhkYXRlKVxuICAgICAgICAgICAgOiBnZXRXZWVrKGRhdGUsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgZXhpc3RpbmdXZWVrID0gcmVzdWx0LmZpbmQoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS53ZWVrTnVtYmVyID09PSB3ZWVrTnVtYmVyOyB9KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nV2Vlaykge1xuICAgICAgICAgICAgZXhpc3RpbmdXZWVrLmRhdGVzLnB1c2goZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHdlZWtOdW1iZXI6IHdlZWtOdW1iZXIsXG4gICAgICAgICAgICBkYXRlczogW2RhdGVdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gd2Vla3NJbk1vbnRoO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgd2Vla3MgYmVsb25naW5nIHRvIHRoZSBnaXZlbiBtb250aCwgYWRkaW5nIHRoZSBcIm91dHNpZGUgZGF5c1wiIHRvXG4gKiB0aGUgZmlyc3QgYW5kIGxhc3Qgd2Vlay5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9udGhXZWVrcyhtb250aCwgb3B0aW9ucykge1xuICAgIHZhciB3ZWVrc0luTW9udGggPSBkYXlzVG9Nb250aFdlZWtzKHN0YXJ0T2ZNb250aChtb250aCksIGVuZE9mTW9udGgobW9udGgpLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVzZUZpeGVkV2Vla3MpIHtcbiAgICAgICAgLy8gQWRkIGV4dHJhIHdlZWtzIHRvIHRoZSBtb250aCwgdXAgdG8gNiB3ZWVrc1xuICAgICAgICB2YXIgbnJPZk1vbnRoV2Vla3MgPSBnZXRXZWVrc0luTW9udGgobW9udGgsIG9wdGlvbnMpO1xuICAgICAgICBpZiAobnJPZk1vbnRoV2Vla3MgPCA2KSB7XG4gICAgICAgICAgICB2YXIgbGFzdFdlZWsgPSB3ZWVrc0luTW9udGhbd2Vla3NJbk1vbnRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIGxhc3REYXRlID0gbGFzdFdlZWsuZGF0ZXNbbGFzdFdlZWsuZGF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgdG9EYXRlID0gYWRkV2Vla3MobGFzdERhdGUsIDYgLSBuck9mTW9udGhXZWVrcyk7XG4gICAgICAgICAgICB2YXIgZXh0cmFXZWVrcyA9IGRheXNUb01vbnRoV2Vla3MoYWRkV2Vla3MobGFzdERhdGUsIDEpLCB0b0RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgd2Vla3NJbk1vbnRoLnB1c2guYXBwbHkod2Vla3NJbk1vbnRoLCBleHRyYVdlZWtzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd2Vla3NJbk1vbnRoO1xufVxuXG4vKiogUmVuZGVyIHRoZSB0YWJsZSB3aXRoIHRoZSBjYWxlbmRhci4gKi9cbmZ1bmN0aW9uIFRhYmxlKHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgdmFyIF9kID0gdXNlRGF5UGlja2VyKCksIGxvY2FsZSA9IF9kLmxvY2FsZSwgY2xhc3NOYW1lcyA9IF9kLmNsYXNzTmFtZXMsIHN0eWxlcyA9IF9kLnN0eWxlcywgaGlkZUhlYWQgPSBfZC5oaWRlSGVhZCwgZml4ZWRXZWVrcyA9IF9kLmZpeGVkV2Vla3MsIGNvbXBvbmVudHMgPSBfZC5jb21wb25lbnRzLCB3ZWVrU3RhcnRzT24gPSBfZC53ZWVrU3RhcnRzT24sIGZpcnN0V2Vla0NvbnRhaW5zRGF0ZSA9IF9kLmZpcnN0V2Vla0NvbnRhaW5zRGF0ZSwgSVNPV2VlayA9IF9kLklTT1dlZWs7XG4gICAgdmFyIHdlZWtzID0gZ2V0TW9udGhXZWVrcyhwcm9wcy5kaXNwbGF5TW9udGgsIHtcbiAgICAgICAgdXNlRml4ZWRXZWVrczogQm9vbGVhbihmaXhlZFdlZWtzKSxcbiAgICAgICAgSVNPV2VlazogSVNPV2VlayxcbiAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgIHdlZWtTdGFydHNPbjogd2Vla1N0YXJ0c09uLFxuICAgICAgICBmaXJzdFdlZWtDb250YWluc0RhdGU6IGZpcnN0V2Vla0NvbnRhaW5zRGF0ZVxuICAgIH0pO1xuICAgIHZhciBIZWFkQ29tcG9uZW50ID0gKF9hID0gY29tcG9uZW50cyA9PT0gbnVsbCB8fCBjb21wb25lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzLkhlYWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEhlYWQ7XG4gICAgdmFyIFJvd0NvbXBvbmVudCA9IChfYiA9IGNvbXBvbmVudHMgPT09IG51bGwgfHwgY29tcG9uZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50cy5Sb3cpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFJvdztcbiAgICB2YXIgRm9vdGVyQ29tcG9uZW50ID0gKF9jID0gY29tcG9uZW50cyA9PT0gbnVsbCB8fCBjb21wb25lbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzLkZvb3RlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogRm9vdGVyO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4cyhcInRhYmxlXCIsIF9fYXNzaWduKHsgaWQ6IHByb3BzLmlkLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMudGFibGUsIHN0eWxlOiBzdHlsZXMudGFibGUsIHJvbGU6IFwiZ3JpZFwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBwcm9wc1snYXJpYS1sYWJlbGxlZGJ5J10gfSwgeyBjaGlsZHJlbjogWyFoaWRlSGVhZCAmJiBqc3hSdW50aW1lRXhwb3J0cy5qc3goSGVhZENvbXBvbmVudCwge30pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJ0Ym9keVwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy50Ym9keSwgc3R5bGU6IHN0eWxlcy50Ym9keSB9LCB7IGNoaWxkcmVuOiB3ZWVrcy5tYXAoZnVuY3Rpb24gKHdlZWspIHsgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goUm93Q29tcG9uZW50LCB7IGRpc3BsYXlNb250aDogcHJvcHMuZGlzcGxheU1vbnRoLCBkYXRlczogd2Vlay5kYXRlcywgd2Vla051bWJlcjogd2Vlay53ZWVrTnVtYmVyIH0sIHdlZWsud2Vla051bWJlcikpOyB9KSB9KSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChGb290ZXJDb21wb25lbnQsIHsgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGggfSldIH0pKSk7XG59XG5cbi8qXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSAyMDE4LXByZXNlbnQsIFJlYWN0IFRyYWluaW5nIExMQ1xuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbi8qXG4gKiBXZWxjb21lIHRvIEByZWFjaC9hdXRvLWlkIVxuICogTGV0J3Mgc2VlIGlmIHdlIGNhbiBtYWtlIHNlbnNlIG9mIHdoeSB0aGlzIGhvb2sgZXhpc3RzIGFuZCBpdHNcbiAqIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFNvbWUgYmFja2dyb3VuZDpcbiAqICAgMS4gQWNjZXNzaWJpbGl0eSBBUElzIHJlbHkgaGVhdmlseSBvbiBlbGVtZW50IElEc1xuICogICAyLiBSZXF1aXJpbmcgZGV2ZWxvcGVycyB0byBwdXQgSURzIG9uIGV2ZXJ5IGVsZW1lbnQgaW4gUmVhY2ggVUkgaXMgYm90aFxuICogICAgICBjdW1iZXJzb21lIGFuZCBlcnJvci1wcm9uZVxuICogICAzLiBXaXRoIGEgY29tcG9uZW50IG1vZGVsLCB3ZSBjYW4gZ2VuZXJhdGUgSURzIGZvciB0aGVtIVxuICpcbiAqIFNvbHV0aW9uIDE6IEdlbmVyYXRlIHJhbmRvbSBJRHMuXG4gKlxuICogVGhpcyB3b3JrcyBncmVhdCBhcyBsb25nIGFzIHlvdSBkb24ndCBzZXJ2ZXIgcmVuZGVyIHlvdXIgYXBwLiBXaGVuIFJlYWN0IChpblxuICogdGhlIGNsaWVudCkgdHJpZXMgdG8gcmV1c2UgdGhlIG1hcmt1cCBmcm9tIHRoZSBzZXJ2ZXIsIHRoZSBJRHMgd29uJ3QgbWF0Y2hcbiAqIGFuZCBSZWFjdCB3aWxsIHRoZW4gcmVjcmVhdGUgdGhlIGVudGlyZSBET00gdHJlZS5cbiAqXG4gKiBTb2x1dGlvbiAyOiBJbmNyZW1lbnQgYW4gaW50ZWdlclxuICpcbiAqIFRoaXMgc291bmRzIGdyZWF0LiBTaW5jZSB3ZSdyZSByZW5kZXJpbmcgdGhlIGV4YWN0IHNhbWUgdHJlZSBvbiB0aGUgc2VydmVyXG4gKiBhbmQgY2xpZW50LCB3ZSBjYW4gaW5jcmVtZW50IGEgY291bnRlciBhbmQgZ2V0IGEgZGV0ZXJtaW5pc3RpYyByZXN1bHQgYmV0d2VlblxuICogY2xpZW50IGFuZCBzZXJ2ZXIuIEFsc28sIEpTIGludGVnZXJzIGNhbiBnbyB1cCB0byBuaW5lLXF1YWRyaWxsaW9uLiBJJ21cbiAqIHByZXR0eSBzdXJlIHRoZSB0YWIgd2lsbCBiZSBjbG9zZWQgYmVmb3JlIGFuIGFwcCBuZXZlciBuZWVkc1xuICogMTAgcXVhZHJpbGxpb24gSURzIVxuICpcbiAqIFByb2JsZW0gc29sdmVkLCByaWdodD9cbiAqXG4gKiBBaCwgYnV0IHRoZXJlJ3MgYSBjYXRjaCEgUmVhY3QncyBjb25jdXJyZW50IHJlbmRlcmluZyBtYWtlcyB0aGlzIGFwcHJvYWNoXG4gKiBub24tZGV0ZXJtaW5pc3RpYy4gV2hpbGUgdGhlIGNsaWVudCBhbmQgc2VydmVyIHdpbGwgZW5kIHVwIHdpdGggdGhlIHNhbWVcbiAqIGVsZW1lbnRzIGluIHRoZSBlbmQsIGRlcGVuZGluZyBvbiBzdXNwZW5zZSBib3VuZGFyaWVzIChhbmQgcG9zc2libHkgc29tZSB1c2VyXG4gKiBpbnB1dCBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyKSB0aGUgaW5jcmVtZW50aW5nIGludGVnZXJzIHdvbid0IGFsd2F5cyBtYXRjaFxuICogdXAuXG4gKlxuICogU29sdXRpb24gMzogRG9uJ3QgdXNlIElEcyBhdCBhbGwgb24gdGhlIHNlcnZlcjsgcGF0Y2ggYWZ0ZXIgZmlyc3QgcmVuZGVyLlxuICpcbiAqIFdoYXQgd2UndmUgZG9uZSBoZXJlIGlzIHNvbHV0aW9uIDIgd2l0aCBzb21lIHRyaWNrcy4gV2l0aCB0aGlzIGFwcHJvYWNoLCB0aGVcbiAqIElEIHJldHVybmVkIGlzIGFuIGVtcHR5IHN0cmluZyBvbiB0aGUgZmlyc3QgcmVuZGVyLiBUaGlzIHdheSB0aGUgc2VydmVyIGFuZFxuICogY2xpZW50IGhhdmUgdGhlIHNhbWUgbWFya3VwIG5vIG1hdHRlciBob3cgd2lsZCB0aGUgY29uY3VycmVudCByZW5kZXJpbmcgbWF5XG4gKiBoYXZlIGdvdHRlbi5cbiAqXG4gKiBBZnRlciB0aGUgcmVuZGVyLCB3ZSBwYXRjaCB1cCB0aGUgY29tcG9uZW50cyB3aXRoIGFuIGluY3JlbWVudGVkIElELiBUaGlzXG4gKiBjYXVzZXMgYSBkb3VibGUgcmVuZGVyIG9uIGFueSBjb21wb25lbnRzIHdpdGggYHVzZUlkYC4gU2hvdWxkbid0IGJlIGEgcHJvYmxlbVxuICogc2luY2UgdGhlIGNvbXBvbmVudHMgdXNpbmcgdGhpcyBob29rIHNob3VsZCBiZSBzbWFsbCwgYW5kIHdlJ3JlIG9ubHkgdXBkYXRpbmdcbiAqIHRoZSBJRCBhdHRyaWJ1dGUgb24gdGhlIERPTSwgbm90aGluZyBiaWcgaXMgaGFwcGVuaW5nLlxuICpcbiAqIEl0IGRvZXNuJ3QgaGF2ZSB0byBiZSBhbiBpbmNyZW1lbnRlZCBudW1iZXIsIHRob3VnaC0td2UgY291bGQgZG8gZ2VuZXJhdGVcbiAqIHJhbmRvbSBzdHJpbmdzIGluc3RlYWQsIGJ1dCBpbmNyZW1lbnRpbmcgYSBudW1iZXIgaXMgcHJvYmFibHkgdGhlIGNoZWFwZXN0XG4gKiB0aGluZyB3ZSBjYW4gZG8uXG4gKlxuICogQWRkaXRpb25hbGx5LCB3ZSBvbmx5IGRvIHRoaXMgcGF0Y2h1cCBvbiB0aGUgdmVyeSBmaXJzdCBjbGllbnQgcmVuZGVyIGV2ZXIuXG4gKiBBbnkgY2FsbHMgdG8gYHVzZUlkYCB0aGF0IGhhcHBlbiBkeW5hbWljYWxseSBpbiB0aGUgY2xpZW50IHdpbGwgYmVcbiAqIHBvcHVsYXRlZCBpbW1lZGlhdGVseSB3aXRoIGEgdmFsdWUuIFNvLCB3ZSBvbmx5IGdldCB0aGUgZG91YmxlIHJlbmRlciBhZnRlclxuICogc2VydmVyIGh5ZHJhdGlvbiBhbmQgbmV2ZXIgYWdhaW4sIFNPIEJBQ0sgT0ZGIEFMUklHSFQ/XG4gKi9cbmZ1bmN0aW9uIGNhblVzZURPTSgpIHtcbiAgICByZXR1cm4gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LmRvY3VtZW50ICYmXG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbn1cbi8qKlxuICogUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci4gVG9cbiAqIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXG4gKiB1c2VMYXlvdXRFZmZlY3QgaW4gdGhlIGJyb3dzZXIuIFdlIG9jY2FzaW9uYWxseSBuZWVkIHVzZUxheW91dEVmZmVjdCB0b1xuICogZW5zdXJlIHdlIGRvbid0IGdldCBhIHJlbmRlciBmbGFzaCBmb3IgY2VydGFpbiBvcGVyYXRpb25zLCBidXQgd2UgbWF5IGFsc29cbiAqIG5lZWQgYWZmZWN0ZWQgY29tcG9uZW50cyB0byByZW5kZXIgb24gdGhlIHNlcnZlci4gT25lIGV4YW1wbGUgaXMgd2hlbiBzZXR0aW5nXG4gKiBhIGNvbXBvbmVudCdzIGRlc2NlbmRhbnRzIHRvIHJldHJpZXZlIHRoZWlyIGluZGV4IHZhbHVlcy5cbiAqXG4gKiBJbXBvcnRhbnQgdG8gbm90ZSB0aGF0IHVzaW5nIHRoaXMgaG9vayBhcyBhbiBlc2NhcGUgaGF0Y2ggd2lsbCBicmVhayB0aGVcbiAqIGVzbGludCBkZXBlbmRlbmN5IHdhcm5pbmdzIHVubGVzcyB5b3UgcmVuYW1lIHRoZSBpbXBvcnQgdG8gYHVzZUxheW91dEVmZmVjdGAuXG4gKiBVc2Ugc3BhcmluZ2x5IG9ubHkgd2hlbiB0aGUgZWZmZWN0IHdvbid0IGVmZmVjdCB0aGUgcmVuZGVyZWQgSFRNTCB0byBhdm9pZFxuICogYW55IHNlcnZlci9jbGllbnQgbWlzbWF0Y2guXG4gKlxuICogSWYgYSB1c2VMYXlvdXRFZmZlY3QgaXMgbmVlZGVkIGFuZCB0aGUgcmVzdWx0IHdvdWxkIGNyZWF0ZSBhIG1pc21hdGNoLCBpdCdzXG4gKiBsaWtlbHkgdGhhdCB0aGUgY29tcG9uZW50IGluIHF1ZXN0aW9uIHNob3VsZG4ndCBiZSByZW5kZXJlZCBvbiB0aGUgc2VydmVyIGF0XG4gKiBhbGwsIHNvIGEgYmV0dGVyIGFwcHJvYWNoIHdvdWxkIGJlIHRvIGxhemlseSByZW5kZXIgdGhvc2UgaW4gYSBwYXJlbnRcbiAqIGNvbXBvbmVudCBhZnRlciBjbGllbnQtc2lkZSBoeWRyYXRpb24uXG4gKlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2FlYXJvbi9lN2Q5N2NkZjM4YTI5MDc5MjRlYTEyZTRlYmRmM2M4NVxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVhY3QtcmVkdXgvYmxvYi9tYXN0ZXIvc3JjL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QuanNcbiAqXG4gKiBAcGFyYW0gZWZmZWN0XG4gKiBAcGFyYW0gZGVwc1xuICovXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGNhblVzZURPTSgpID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xudmFyIHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9IGZhbHNlO1xudmFyIGlkID0gMDtcbmZ1bmN0aW9uIGdlbklkKCkge1xuICAgIHJldHVybiBcInJlYWN0LWRheS1waWNrZXItXCIuY29uY2F0KCsraWQpO1xufVxuZnVuY3Rpb24gdXNlSWQocHJvdmlkZWRJZCkge1xuICAgIC8vIFRPRE86IFJlbW92ZSBlcnJvciBmbGFnIHdoZW4gdXBkYXRpbmcgaW50ZXJuYWwgZGVwcyB0byBSZWFjdCAxOC4gTm9uZSBvZlxuICAgIC8vIG91ciB0cmlja3Mgd2lsbCBwbGF5IHdlbGwgd2l0aCBjb25jdXJyZW50IHJlbmRlcmluZyBhbnl3YXkuXG4gICAgdmFyIF9hO1xuICAgIC8vIElmIHRoaXMgaW5zdGFuY2UgaXNuJ3QgcGFydCBvZiB0aGUgaW5pdGlhbCByZW5kZXIsIHdlIGRvbid0IGhhdmUgdG8gZG8gdGhlXG4gICAgLy8gZG91YmxlIHJlbmRlci9wYXRjaC11cCBkYW5jZS4gV2UgY2FuIGp1c3QgZ2VuZXJhdGUgdGhlIElEIGFuZCByZXR1cm4gaXQuXG4gICAgdmFyIGluaXRpYWxJZCA9IHByb3ZpZGVkSWQgIT09IG51bGwgJiYgcHJvdmlkZWRJZCAhPT0gdm9pZCAwID8gcHJvdmlkZWRJZCA6IChzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPyBnZW5JZCgpIDogbnVsbCk7XG4gICAgdmFyIF9iID0gdXNlU3RhdGUoaW5pdGlhbElkKSwgaWQgPSBfYlswXSwgc2V0SWQgPSBfYlsxXTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBQYXRjaCB0aGUgSUQgYWZ0ZXIgcmVuZGVyLiBXZSBkbyB0aGlzIGluIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGF2b2lkIGFueVxuICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGZsaWNrZXIsIHRob3VnaCBpdCdsbCBtYWtlIHRoZSBmaXJzdCByZW5kZXIgc2xvd2VyICh1bmxpa2VseVxuICAgICAgICAgICAgLy8gdG8gbWF0dGVyLCBidXQgeW91J3JlIHdlbGNvbWUgdG8gbWVhc3VyZSB5b3VyIGFwcCBhbmQgbGV0IHVzIGtub3cgaWZcbiAgICAgICAgICAgIC8vIGl0J3MgYSBwcm9ibGVtKS5cbiAgICAgICAgICAgIHNldElkKGdlbklkKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIEZsYWcgYWxsIGZ1dHVyZSB1c2VzIG9mIGB1c2VJZGAgdG8gc2tpcCB0aGUgdXBkYXRlIGRhbmNlLiBUaGlzIGlzIGluXG4gICAgICAgICAgICAvLyBgdXNlRWZmZWN0YCBiZWNhdXNlIGl0IGdvZXMgYWZ0ZXIgYHVzZUxheW91dEVmZmVjdGAsIGVuc3VyaW5nIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgYmFpbCBvdXQgb2YgdGhlIHBhdGNoLXVwIGRhbmNlIHByZW1hdHVyZWx5LlxuICAgICAgICAgICAgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKF9hID0gcHJvdmlkZWRJZCAhPT0gbnVsbCAmJiBwcm92aWRlZElkICE9PSB2b2lkIDAgPyBwcm92aWRlZElkIDogaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqIFJlbmRlciBhIG1vbnRoLiAqL1xuZnVuY3Rpb24gTW9udGgocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIHZhciBkYXlQaWNrZXIgPSB1c2VEYXlQaWNrZXIoKTtcbiAgICB2YXIgZGlyID0gZGF5UGlja2VyLmRpciwgY2xhc3NOYW1lcyA9IGRheVBpY2tlci5jbGFzc05hbWVzLCBzdHlsZXMgPSBkYXlQaWNrZXIuc3R5bGVzLCBjb21wb25lbnRzID0gZGF5UGlja2VyLmNvbXBvbmVudHM7XG4gICAgdmFyIGRpc3BsYXlNb250aHMgPSB1c2VOYXZpZ2F0aW9uKCkuZGlzcGxheU1vbnRocztcbiAgICB2YXIgY2FwdGlvbklkID0gdXNlSWQoZGF5UGlja2VyLmlkID8gXCJcIi5jb25jYXQoZGF5UGlja2VyLmlkLCBcIi1cIikuY29uY2F0KHByb3BzLmRpc3BsYXlJbmRleCkgOiB1bmRlZmluZWQpO1xuICAgIHZhciB0YWJsZUlkID0gZGF5UGlja2VyLmlkXG4gICAgICAgID8gXCJcIi5jb25jYXQoZGF5UGlja2VyLmlkLCBcIi1ncmlkLVwiKS5jb25jYXQocHJvcHMuZGlzcGxheUluZGV4KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY2xhc3NOYW1lID0gW2NsYXNzTmFtZXMubW9udGhdO1xuICAgIHZhciBzdHlsZSA9IHN0eWxlcy5tb250aDtcbiAgICB2YXIgaXNTdGFydCA9IHByb3BzLmRpc3BsYXlJbmRleCA9PT0gMDtcbiAgICB2YXIgaXNFbmQgPSBwcm9wcy5kaXNwbGF5SW5kZXggPT09IGRpc3BsYXlNb250aHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgaXNDZW50ZXIgPSAhaXNTdGFydCAmJiAhaXNFbmQ7XG4gICAgaWYgKGRpciA9PT0gJ3J0bCcpIHtcbiAgICAgICAgX2EgPSBbaXNTdGFydCwgaXNFbmRdLCBpc0VuZCA9IF9hWzBdLCBpc1N0YXJ0ID0gX2FbMV07XG4gICAgfVxuICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAgIGNsYXNzTmFtZS5wdXNoKGNsYXNzTmFtZXMuY2FwdGlvbl9zdGFydCk7XG4gICAgICAgIHN0eWxlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlKSwgc3R5bGVzLmNhcHRpb25fc3RhcnQpO1xuICAgIH1cbiAgICBpZiAoaXNFbmQpIHtcbiAgICAgICAgY2xhc3NOYW1lLnB1c2goY2xhc3NOYW1lcy5jYXB0aW9uX2VuZCk7XG4gICAgICAgIHN0eWxlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlKSwgc3R5bGVzLmNhcHRpb25fZW5kKTtcbiAgICB9XG4gICAgaWYgKGlzQ2VudGVyKSB7XG4gICAgICAgIGNsYXNzTmFtZS5wdXNoKGNsYXNzTmFtZXMuY2FwdGlvbl9iZXR3ZWVuKTtcbiAgICAgICAgc3R5bGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3R5bGUpLCBzdHlsZXMuY2FwdGlvbl9iZXR3ZWVuKTtcbiAgICB9XG4gICAgdmFyIENhcHRpb25Db21wb25lbnQgPSAoX2IgPSBjb21wb25lbnRzID09PSBudWxsIHx8IGNvbXBvbmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudHMuQ2FwdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogQ2FwdGlvbjtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeHMoXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZS5qb2luKCcgJyksIHN0eWxlOiBzdHlsZSB9LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4KENhcHRpb25Db21wb25lbnQsIHsgaWQ6IGNhcHRpb25JZCwgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGgsIGRpc3BsYXlJbmRleDogcHJvcHMuZGlzcGxheUluZGV4IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goVGFibGUsIHsgaWQ6IHRhYmxlSWQsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGNhcHRpb25JZCwgZGlzcGxheU1vbnRoOiBwcm9wcy5kaXNwbGF5TW9udGggfSldIH0pLCBwcm9wcy5kaXNwbGF5SW5kZXgpKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIHdyYXBwZXIgZm9yIHRoZSBtb250aCBncmlkcy5cbiAqL1xuZnVuY3Rpb24gTW9udGhzKHByb3BzKSB7XG4gICAgdmFyIF9hID0gdXNlRGF5UGlja2VyKCksIGNsYXNzTmFtZXMgPSBfYS5jbGFzc05hbWVzLCBzdHlsZXMgPSBfYS5zdHlsZXM7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMubW9udGhzLCBzdHlsZTogc3R5bGVzLm1vbnRocyB9LCB7IGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSkpO1xufVxuXG4vKiogUmVuZGVyIHRoZSBjb250YWluZXIgd2l0aCB0aGUgbW9udGhzIGFjY29yZGluZyB0byB0aGUgbnVtYmVyIG9mIG1vbnRocyB0byBkaXNwbGF5LiAqL1xuZnVuY3Rpb24gUm9vdChfYSkge1xuICAgIHZhciBfYiwgX2M7XG4gICAgdmFyIGluaXRpYWxQcm9wcyA9IF9hLmluaXRpYWxQcm9wcztcbiAgICB2YXIgZGF5UGlja2VyID0gdXNlRGF5UGlja2VyKCk7XG4gICAgdmFyIGZvY3VzQ29udGV4dCA9IHVzZUZvY3VzQ29udGV4dCgpO1xuICAgIHZhciBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuICAgIHZhciBfZCA9IHVzZVN0YXRlKGZhbHNlKSwgaGFzSW5pdGlhbEZvY3VzID0gX2RbMF0sIHNldEhhc0luaXRpYWxGb2N1cyA9IF9kWzFdO1xuICAgIC8vIEZvY3VzIHRoZSBmb2N1cyB0YXJnZXQgd2hlbiBpbml0aWFsRm9jdXMgaXMgcGFzc2VkIGluXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkYXlQaWNrZXIuaW5pdGlhbEZvY3VzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWZvY3VzQ29udGV4dC5mb2N1c1RhcmdldClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGhhc0luaXRpYWxGb2N1cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9jdXNDb250ZXh0LmZvY3VzKGZvY3VzQ29udGV4dC5mb2N1c1RhcmdldCk7XG4gICAgICAgIHNldEhhc0luaXRpYWxGb2N1cyh0cnVlKTtcbiAgICB9LCBbXG4gICAgICAgIGRheVBpY2tlci5pbml0aWFsRm9jdXMsXG4gICAgICAgIGhhc0luaXRpYWxGb2N1cyxcbiAgICAgICAgZm9jdXNDb250ZXh0LmZvY3VzLFxuICAgICAgICBmb2N1c0NvbnRleHQuZm9jdXNUYXJnZXQsXG4gICAgICAgIGZvY3VzQ29udGV4dFxuICAgIF0pO1xuICAgIC8vIEFwcGx5IGNsYXNzbmFtZXMgYWNjb3JkaW5nIHRvIHByb3BzXG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbZGF5UGlja2VyLmNsYXNzTmFtZXMucm9vdCwgZGF5UGlja2VyLmNsYXNzTmFtZV07XG4gICAgaWYgKGRheVBpY2tlci5udW1iZXJPZk1vbnRocyA+IDEpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKGRheVBpY2tlci5jbGFzc05hbWVzLm11bHRpcGxlX21vbnRocyk7XG4gICAgfVxuICAgIGlmIChkYXlQaWNrZXIuc2hvd1dlZWtOdW1iZXIpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKGRheVBpY2tlci5jbGFzc05hbWVzLndpdGhfd2Vla251bWJlcik7XG4gICAgfVxuICAgIHZhciBzdHlsZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXlQaWNrZXIuc3R5bGVzLnJvb3QpLCBkYXlQaWNrZXIuc3R5bGUpO1xuICAgIHZhciBkYXRhQXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGluaXRpYWxQcm9wcylcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkuc3RhcnRzV2l0aCgnZGF0YS0nKTsgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYXR0cnMsIGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYXR0cnMpLCAoX2EgPSB7fSwgX2Fba2V5XSA9IGluaXRpYWxQcm9wc1trZXldLCBfYSkpO1xuICAgIH0sIHt9KTtcbiAgICB2YXIgTW9udGhzQ29tcG9uZW50ID0gKF9jID0gKF9iID0gaW5pdGlhbFByb3BzLmNvbXBvbmVudHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5Nb250aHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IE1vbnRocztcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcImRpdlwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiBzdHlsZSwgZGlyOiBkYXlQaWNrZXIuZGlyLCBpZDogZGF5UGlja2VyLmlkLCBub25jZTogaW5pdGlhbFByb3BzLm5vbmNlLCB0aXRsZTogaW5pdGlhbFByb3BzLnRpdGxlLCBsYW5nOiBpbml0aWFsUHJvcHMubGFuZyB9LCBkYXRhQXR0cmlidXRlcywgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KE1vbnRoc0NvbXBvbmVudCwgeyBjaGlsZHJlbjogbmF2aWdhdGlvbi5kaXNwbGF5TW9udGhzLm1hcChmdW5jdGlvbiAobW9udGgsIGkpIHsgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goTW9udGgsIHsgZGlzcGxheUluZGV4OiBpLCBkaXNwbGF5TW9udGg6IG1vbnRoIH0sIGkpKTsgfSkgfSkgfSkpKTtcbn1cblxuLyoqIFByb3ZpZGUgdGhlIHZhbHVlIGZvciBhbGwgdGhlIGNvbnRleHQgcHJvdmlkZXJzLiAqL1xuZnVuY3Rpb24gUm9vdFByb3ZpZGVyKHByb3BzKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sIGluaXRpYWxQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wiY2hpbGRyZW5cIl0pO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KERheVBpY2tlclByb3ZpZGVyLCBfX2Fzc2lnbih7IGluaXRpYWxQcm9wczogaW5pdGlhbFByb3BzIH0sIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChOYXZpZ2F0aW9uUHJvdmlkZXIsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChTZWxlY3RTaW5nbGVQcm92aWRlciwgX19hc3NpZ24oeyBpbml0aWFsUHJvcHM6IGluaXRpYWxQcm9wcyB9LCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goU2VsZWN0TXVsdGlwbGVQcm92aWRlciwgX19hc3NpZ24oeyBpbml0aWFsUHJvcHM6IGluaXRpYWxQcm9wcyB9LCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goU2VsZWN0UmFuZ2VQcm92aWRlciwgX19hc3NpZ24oeyBpbml0aWFsUHJvcHM6IGluaXRpYWxQcm9wcyB9LCB7IGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goTW9kaWZpZXJzUHJvdmlkZXIsIHsgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChGb2N1c1Byb3ZpZGVyLCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSB9KSkgfSkpIH0pKSB9KSB9KSkpO1xufVxuXG4vKipcbiAqIERheVBpY2tlciByZW5kZXIgYSBkYXRlIHBpY2tlciBjb21wb25lbnQgdG8gbGV0IHVzZXJzIHBpY2sgZGF0ZXMgZnJvbSBhXG4gKiBjYWxlbmRhci4gU2VlIGh0dHA6Ly9yZWFjdC1kYXktcGlja2VyLmpzLm9yZyBmb3IgdXBkYXRlZCBkb2N1bWVudGF0aW9uIGFuZFxuICogZXhhbXBsZXMuXG4gKlxuICogIyMjIEN1c3RvbWl6YXRpb25cbiAqXG4gKiBEYXlQaWNrZXIgb2ZmZXJzIGRpZmZlcmVudCBjdXN0b21pemF0aW9uIHByb3BzLiBGb3IgZXhhbXBsZSxcbiAqXG4gKiAtIHNob3cgbXVsdGlwbGUgbW9udGhzIHVzaW5nIGBudW1iZXJPZk1vbnRoc2BcbiAqIC0gZGlzcGxheSBhIGRyb3Bkb3duIHRvIG5hdmlnYXRlIHRoZSBtb250aHMgdmlhIGBjYXB0aW9uTGF5b3V0YFxuICogLSBkaXNwbGF5IHRoZSB3ZWVrIG51bWJlcnMgd2l0aCBgc2hvd1dlZWtOdW1iZXJzYFxuICogLSBkaXNhYmxlIG9yIGhpZGUgZGF5cyB3aXRoIGBkaXNhYmxlZGAgb3IgYGhpZGRlbmBcbiAqXG4gKiAjIyMgQ29udHJvbGxpbmcgdGhlIG1vbnRoc1xuICpcbiAqIENoYW5nZSB0aGUgaW5pdGlhbGx5IGRpc3BsYXllZCBtb250aCB1c2luZyB0aGUgYGRlZmF1bHRNb250aGAgcHJvcC4gVGhlXG4gKiBkaXNwbGF5ZWQgbW9udGhzIGFyZSBjb250cm9sbGVkIGJ5IERheVBpY2tlciBhbmQgc3RvcmVkIGluIGl0cyBpbnRlcm5hbFxuICogc3RhdGUuIFRvIGNvbnRyb2wgdGhlIG1vbnRocyB5b3Vyc2VsZiwgdXNlIGBtb250aGAgaW5zdGVhZCBvZiBgZGVmYXVsdE1vbnRoYFxuICogYW5kIHVzZSB0aGUgYG9uTW9udGhDaGFuZ2VgIGV2ZW50IHRvIHNldCBpdC5cbiAqXG4gKiBUbyBsaW1pdCB0aGUgbW9udGhzIHRoZSB1c2VyIGNhbiBuYXZpZ2F0ZSB0bywgdXNlXG4gKiBgZnJvbURhdGVgL2Bmcm9tTW9udGhgL2Bmcm9tWWVhcmAgb3IgYHRvRGF0ZWAvYHRvTW9udGhgL2B0b1llYXJgLlxuICpcbiAqICMjIyBTZWxlY3Rpb24gbW9kZXNcbiAqXG4gKiBEYXlQaWNrZXIgc3VwcG9ydHMgZGlmZmVyZW50IHNlbGVjdGlvbiBtb2RlIHRoYXQgY2FuIGJlIHRvZ2dsZWQgdXNpbmcgdGhlXG4gKiBgbW9kZWAgcHJvcDpcbiAqXG4gKiAtIGBtb2RlPVwic2luZ2xlXCJgOiBvbmx5IG9uZSBkYXkgY2FuIGJlIHNlbGVjdGVkLiBVc2UgYHJlcXVpcmVkYCB0byBtYWtlIHRoZVxuICogICBzZWxlY3Rpb24gcmVxdWlyZWQuIFVzZSB0aGUgYG9uU2VsZWN0YCBldmVudCBoYW5kbGVyIHRvIGdldCB0aGUgc2VsZWN0ZWRcbiAqICAgZGF5cy5cbiAqIC0gYG1vZGU9XCJtdWx0aXBsZVwiYDogdXNlcnMgY2FuIHNlbGVjdCBvbmUgb3IgbW9yZSBkYXlzLiBMaW1pdCB0aGUgYW1vdW50IG9mXG4gKiAgIGRheXMgdGhhdCBjYW4gYmUgc2VsZWN0ZWQgd2l0aCB0aGUgYG1pbmAgb3IgdGhlIGBtYXhgIHByb3BzLlxuICogLSBgbW9kZT1cInJhbmdlXCJgOiB1c2VycyBjYW4gc2VsZWN0IGEgcmFuZ2Ugb2YgZGF5cy4gTGltaXQgdGhlIGFtb3VudCBvZiBkYXlzXG4gKiAgIGluIHRoZSByYW5nZSB3aXRoIHRoZSBgbWluYCBvciB0aGUgYG1heGAgcHJvcHMuXG4gKiAtIGBtb2RlPVwiZGVmYXVsdFwiYCAoZGVmYXVsdCk6IHRoZSBidWlsdC1pbiBzZWxlY3Rpb25zIGFyZSBkaXNhYmxlZC4gSW1wbGVtZW50XG4gKiAgIHlvdXIgb3duIHNlbGVjdGlvbiBtb2RlIHdpdGggYG9uRGF5Q2xpY2tgLlxuICpcbiAqIFRoZSBzZWxlY3Rpb24gbW9kZXMgc2hvdWxkIGNvdmVyIHRoZSBtb3N0IGNvbW1vbiB1c2UgY2FzZXMuIEluIGNhc2UgeW91XG4gKiBuZWVkIGEgbW9yZSByZWZpbmVkIHdheSBvZiBzZWxlY3RpbmcgZGF5cywgdXNlIGBtb2RlPVwiZGVmYXVsdFwiYC4gVXNlIHRoZVxuICogYHNlbGVjdGVkYCBwcm9wcyBhbmQgYWRkIHRoZSBkYXkgZXZlbnQgaGFuZGxlcnMgdG8gYWRkL3JlbW92ZSBkYXlzIGZyb20gdGhlXG4gKiBzZWxlY3Rpb24uXG4gKlxuICogIyMjIE1vZGlmaWVyc1xuICpcbiAqIEEgX21vZGlmaWVyXyByZXByZXNlbnRzIGRpZmZlcmVudCBzdHlsZXMgb3Igc3RhdGVzIGZvciB0aGUgZGF5cyBkaXNwbGF5ZWQgaW5cbiAqIHRoZSBjYWxlbmRhciAobGlrZSBcInNlbGVjdGVkXCIgb3IgXCJkaXNhYmxlZFwiKS4gRGVmaW5lIGN1c3RvbSBtb2RpZmllcnMgdXNpbmdcbiAqIHRoZSBgbW9kaWZpZXJzYCBwcm9wLlxuICpcbiAqICMjIyBGb3JtYXR0ZXJzIGFuZCBjdXN0b20gY29tcG9uZW50XG4gKlxuICogWW91IGNhbiBjdXN0b21pemUgaG93IHRoZSBjb250ZW50IGlzIGRpc3BsYXllZCBpbiB0aGUgZGF0ZSBwaWNrZXIgYnkgdXNpbmdcbiAqIGVpdGhlciB0aGUgZm9ybWF0dGVycyBvciByZXBsYWNpbmcgdGhlIGludGVybmFsIGNvbXBvbmVudHMuXG4gKlxuICogRm9yIHRoZSBtb3N0IGNvbW1vbiBjYXNlcyB5b3Ugd2FudCB0byB1c2UgdGhlIGBmb3JtYXR0ZXJzYCBwcm9wIHRvIGNoYW5nZSBob3dcbiAqIHRoZSBjb250ZW50IGlzIGZvcm1hdHRlZCBpbiB0aGUgY2FsZW5kYXIuIFVzZSB0aGUgYGNvbXBvbmVudHNgIHByb3AgdG9cbiAqIHJlcGxhY2UgdGhlIGludGVybmFsIGNvbXBvbmVudHMsIGxpa2UgdGhlIG5hdmlnYXRpb24gaWNvbnMuXG4gKlxuICogIyMjIFN0eWxpbmdcbiAqXG4gKiBEYXlQaWNrZXIgY29tZXMgd2l0aCBhIGRlZmF1bHQsIGJhc2ljIHN0eWxlIGluIGByZWFjdC1kYXktcGlja2VyL3N0eWxlYCDigJMgdXNlXG4gKiBpdCBhcyB0ZW1wbGF0ZSBmb3IgeW91ciBvd24gc3R5bGUuXG4gKlxuICogSWYgeW91IGFyZSB1c2luZyBDU1MgbW9kdWxlcywgcGFzcyB0aGUgaW1wb3J0ZWQgc3R5bGVzIG9iamVjdCB0aGVcbiAqIGBjbGFzc05hbWVzYCBwcm9wcy5cbiAqXG4gKiBZb3UgY2FuIGFsc28gc3R5bGUgdGhlIGVsZW1lbnRzIHZpYSBpbmxpbmUgc3R5bGVzIHVzaW5nIHRoZSBgc3R5bGVzYCBwcm9wLlxuICpcbiAqICMjIyBGb3JtIGZpZWxkc1xuICpcbiAqIElmIHlvdSBuZWVkIHRvIGJpbmQgdGhlIGRhdGUgcGlja2VyIHRvIGEgZm9ybSBmaWVsZCwgeW91IGNhbiB1c2UgdGhlXG4gKiBgdXNlSW5wdXRgIGhvb2tzIGZvciBhIGJhc2ljIGJlaGF2aW9yLiBTZWUgdGhlIGB1c2VJbnB1dGAgc291cmNlIGFzIGFuXG4gKiBleGFtcGxlIHRvIGJpbmQgdGhlIGRhdGUgcGlja2VyIHdpdGggZm9ybSBmaWVsZHMuXG4gKlxuICogIyMjIExvY2FsaXphdGlvblxuICpcbiAqIFRvIGxvY2FsaXplIERheVBpY2tlciwgaW1wb3J0IHRoZSBsb2NhbGUgZnJvbSBgZGF0ZS1mbnNgIHBhY2thZ2UgYW5kIHVzZSB0aGVcbiAqIGBsb2NhbGVgIHByb3AuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRvIHVzZSBTcGFuaXNoIGxvY2FsZTpcbiAqXG4gKiBgYGBcbiAqIGltcG9ydCB7IGVzIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlJztcbiAqIDxEYXlQaWNrZXIgbG9jYWxlPXtlc30gLz5cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBEYXlQaWNrZXIocHJvcHMpIHtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChSb290UHJvdmlkZXIsIF9fYXNzaWduKHt9LCBwcm9wcywgeyBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KFJvb3QsIHsgaW5pdGlhbFByb3BzOiBwcm9wcyB9KSB9KSkpO1xufVxuXG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGlzVmFsaWREYXRlKGRheSkge1xuICAgIHJldHVybiAhaXNOYU4oZGF5LmdldFRpbWUoKSk7XG59XG5cbi8qKiBSZXR1cm4gcHJvcHMgYW5kIHNldHRlcnMgZm9yIGJpbmRpbmcgYW4gaW5wdXQgZmllbGQgdG8gRGF5UGlja2VyLiAqL1xuZnVuY3Rpb24gdXNlSW5wdXQob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5sb2NhbGUsIGxvY2FsZSA9IF9hID09PSB2b2lkIDAgPyBlblVTIDogX2EsIHJlcXVpcmVkID0gb3B0aW9ucy5yZXF1aXJlZCwgX2IgPSBvcHRpb25zLmZvcm1hdCwgZm9ybWF0JDEgPSBfYiA9PT0gdm9pZCAwID8gJ1BQJyA6IF9iLCBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zLmRlZmF1bHRTZWxlY3RlZCwgX2MgPSBvcHRpb25zLnRvZGF5LCB0b2RheSA9IF9jID09PSB2b2lkIDAgPyBuZXcgRGF0ZSgpIDogX2M7XG4gICAgdmFyIF9kID0gcGFyc2VGcm9tVG9Qcm9wcyhvcHRpb25zKSwgZnJvbURhdGUgPSBfZC5mcm9tRGF0ZSwgdG9EYXRlID0gX2QudG9EYXRlO1xuICAgIC8vIFNob3J0Y3V0IHRvIHRoZSBEYXRlRm5zIGZ1bmN0aW9uc1xuICAgIHZhciBwYXJzZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBwYXJzZSh2YWx1ZSwgZm9ybWF0JDEsIHRvZGF5LCB7IGxvY2FsZTogbG9jYWxlIH0pOyB9O1xuICAgIC8vIEluaXRpYWxpemUgc3RhdGVzXG4gICAgdmFyIF9lID0gdXNlU3RhdGUoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsICYmIGRlZmF1bHRTZWxlY3RlZCAhPT0gdm9pZCAwID8gZGVmYXVsdFNlbGVjdGVkIDogdG9kYXkpLCBtb250aCA9IF9lWzBdLCBzZXRNb250aCA9IF9lWzFdO1xuICAgIHZhciBfZiA9IHVzZVN0YXRlKGRlZmF1bHRTZWxlY3RlZCksIHNlbGVjdGVkRGF5ID0gX2ZbMF0sIHNldFNlbGVjdGVkRGF5ID0gX2ZbMV07XG4gICAgdmFyIGRlZmF1bHRJbnB1dFZhbHVlID0gZGVmYXVsdFNlbGVjdGVkXG4gICAgICAgID8gZm9ybWF0KGRlZmF1bHRTZWxlY3RlZCwgZm9ybWF0JDEsIHsgbG9jYWxlOiBsb2NhbGUgfSlcbiAgICAgICAgOiAnJztcbiAgICB2YXIgX2cgPSB1c2VTdGF0ZShkZWZhdWx0SW5wdXRWYWx1ZSksIGlucHV0VmFsdWUgPSBfZ1swXSwgc2V0SW5wdXRWYWx1ZSA9IF9nWzFdO1xuICAgIHZhciByZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWREYXkoZGVmYXVsdFNlbGVjdGVkKTtcbiAgICAgICAgc2V0TW9udGgoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsICYmIGRlZmF1bHRTZWxlY3RlZCAhPT0gdm9pZCAwID8gZGVmYXVsdFNlbGVjdGVkIDogdG9kYXkpO1xuICAgICAgICBzZXRJbnB1dFZhbHVlKGRlZmF1bHRJbnB1dFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRJbnB1dFZhbHVlICE9PSB2b2lkIDAgPyBkZWZhdWx0SW5wdXRWYWx1ZSA6ICcnKTtcbiAgICB9O1xuICAgIHZhciBzZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHNldFNlbGVjdGVkRGF5KGRhdGUpO1xuICAgICAgICBzZXRNb250aChkYXRlICE9PSBudWxsICYmIGRhdGUgIT09IHZvaWQgMCA/IGRhdGUgOiB0b2RheSk7XG4gICAgICAgIHNldElucHV0VmFsdWUoZGF0ZSA/IGZvcm1hdChkYXRlLCBmb3JtYXQkMSwgeyBsb2NhbGU6IGxvY2FsZSB9KSA6ICcnKTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVEYXlDbGljayA9IGZ1bmN0aW9uIChkYXksIF9hKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IF9hLnNlbGVjdGVkO1xuICAgICAgICBpZiAoIXJlcXVpcmVkICYmIHNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZERheSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgc2V0SW5wdXRWYWx1ZSgnJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VsZWN0ZWREYXkoZGF5KTtcbiAgICAgICAgc2V0SW5wdXRWYWx1ZShkYXkgPyBmb3JtYXQoZGF5LCBmb3JtYXQkMSwgeyBsb2NhbGU6IGxvY2FsZSB9KSA6ICcnKTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVNb250aENoYW5nZSA9IGZ1bmN0aW9uIChtb250aCkge1xuICAgICAgICBzZXRNb250aChtb250aCk7XG4gICAgfTtcbiAgICAvLyBXaGVuIGNoYW5naW5nIHRoZSBpbnB1dCBmaWVsZCwgc2F2ZSBpdHMgdmFsdWUgaW4gc3RhdGUgYW5kIGNoZWNrIGlmIHRoZVxuICAgIC8vIHN0cmluZyBpcyBhIHZhbGlkIGRhdGUuIElmIGl0IGlzIGEgdmFsaWQgZGF5LCBzZXQgaXQgYXMgc2VsZWN0ZWQgYW5kIHVwZGF0ZVxuICAgIC8vIHRoZSBjYWxlbmRhcuKAmXMgbW9udGguXG4gICAgdmFyIGhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNldElucHV0VmFsdWUoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICB2YXIgZGF5ID0gcGFyc2VWYWx1ZShlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgIHZhciBpc0JlZm9yZSA9IGZyb21EYXRlICYmIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhmcm9tRGF0ZSwgZGF5KSA+IDA7XG4gICAgICAgIHZhciBpc0FmdGVyID0gdG9EYXRlICYmIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhkYXksIHRvRGF0ZSkgPiAwO1xuICAgICAgICBpZiAoIWlzVmFsaWREYXRlKGRheSkgfHwgaXNCZWZvcmUgfHwgaXNBZnRlcikge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXkodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3RlZERheShkYXkpO1xuICAgICAgICBzZXRNb250aChkYXkpO1xuICAgIH07XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBfcmVxdWlyZWRfIGZpZWxkczogb24gYmx1ciwgaWYgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBpcyBub3RcbiAgICAvLyBhIHZhbGlkIGRhdGUsIHJlc2V0IHRoZSBjYWxlbmRhciBhbmQgdGhlIGlucHV0IHZhbHVlLlxuICAgIHZhciBoYW5kbGVCbHVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGRheSA9IHBhcnNlVmFsdWUoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICBpZiAoIWlzVmFsaWREYXRlKGRheSkpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFdoZW4gZm9jdXNpbmcsIG1ha2Ugc3VyZSBEYXlQaWNrZXIgdmlzdWFsaXplcyB0aGUgbW9udGggb2YgdGhlIGRhdGUgaW4gdGhlXG4gICAgLy8gaW5wdXQgZmllbGQuXG4gICAgdmFyIGhhbmRsZUZvY3VzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlLnRhcmdldC52YWx1ZSkge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gcGFyc2VWYWx1ZShlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgIGlmIChpc1ZhbGlkRGF0ZShkYXkpKSB7XG4gICAgICAgICAgICBzZXRNb250aChkYXkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZGF5UGlja2VyUHJvcHMgPSB7XG4gICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgb25EYXlDbGljazogaGFuZGxlRGF5Q2xpY2ssXG4gICAgICAgIG9uTW9udGhDaGFuZ2U6IGhhbmRsZU1vbnRoQ2hhbmdlLFxuICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWREYXksXG4gICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICBmcm9tRGF0ZTogZnJvbURhdGUsXG4gICAgICAgIHRvRGF0ZTogdG9EYXRlLFxuICAgICAgICB0b2RheTogdG9kYXlcbiAgICB9O1xuICAgIHZhciBpbnB1dFByb3BzID0ge1xuICAgICAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsXG4gICAgICAgIG9uRm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IGZvcm1hdChuZXcgRGF0ZSgpLCBmb3JtYXQkMSwgeyBsb2NhbGU6IGxvY2FsZSB9KVxuICAgIH07XG4gICAgcmV0dXJuIHsgZGF5UGlja2VyUHJvcHM6IGRheVBpY2tlclByb3BzLCBpbnB1dFByb3BzOiBpbnB1dFByb3BzLCByZXNldDogcmVzZXQsIHNldFNlbGVjdGVkOiBzZXRTZWxlY3RlZCB9O1xufVxuXG4vKiogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHByb3BzIGFyZSBvZiB0eXBlIHtAbGluayBEYXlQaWNrZXJEZWZhdWx0UHJvcHN9LiAqL1xuZnVuY3Rpb24gaXNEYXlQaWNrZXJEZWZhdWx0KHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLm1vZGUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy5tb2RlID09PSAnZGVmYXVsdCc7XG59XG5cbmV4cG9ydCB7IEJ1dHRvbiwgQ2FwdGlvbiwgQ2FwdGlvbkRyb3Bkb3ducywgQ2FwdGlvbkxhYmVsLCBDYXB0aW9uTmF2aWdhdGlvbiwgRGF5LCBEYXlDb250ZW50LCBEYXlQaWNrZXIsIERheVBpY2tlckNvbnRleHQsIERheVBpY2tlclByb3ZpZGVyLCBEcm9wZG93biwgRm9jdXNDb250ZXh0LCBGb2N1c1Byb3ZpZGVyLCBGb290ZXIsIEhlYWQsIEhlYWRSb3csIEljb25Ecm9wZG93biwgSWNvbkxlZnQsIEljb25SaWdodCwgSW50ZXJuYWxNb2RpZmllciwgTW9udGhzLCBOYXZpZ2F0aW9uQ29udGV4dCwgTmF2aWdhdGlvblByb3ZpZGVyLCBSb290UHJvdmlkZXIsIFJvdywgU2VsZWN0TXVsdGlwbGVDb250ZXh0LCBTZWxlY3RNdWx0aXBsZVByb3ZpZGVyLCBTZWxlY3RNdWx0aXBsZVByb3ZpZGVySW50ZXJuYWwsIFNlbGVjdFJhbmdlQ29udGV4dCwgU2VsZWN0UmFuZ2VQcm92aWRlciwgU2VsZWN0UmFuZ2VQcm92aWRlckludGVybmFsLCBTZWxlY3RTaW5nbGVDb250ZXh0LCBTZWxlY3RTaW5nbGVQcm92aWRlciwgU2VsZWN0U2luZ2xlUHJvdmlkZXJJbnRlcm5hbCwgV2Vla051bWJlciwgYWRkVG9SYW5nZSwgaXNEYXRlQWZ0ZXJUeXBlLCBpc0RhdGVCZWZvcmVUeXBlLCBpc0RhdGVJbnRlcnZhbCwgaXNEYXRlUmFuZ2UsIGlzRGF5T2ZXZWVrVHlwZSwgaXNEYXlQaWNrZXJEZWZhdWx0LCBpc0RheVBpY2tlck11bHRpcGxlLCBpc0RheVBpY2tlclJhbmdlLCBpc0RheVBpY2tlclNpbmdsZSwgaXNNYXRjaCwgdXNlQWN0aXZlTW9kaWZpZXJzLCB1c2VEYXlQaWNrZXIsIHVzZURheVJlbmRlciwgdXNlRm9jdXNDb250ZXh0LCB1c2VJbnB1dCwgdXNlTmF2aWdhdGlvbiwgdXNlU2VsZWN0TXVsdGlwbGUsIHVzZVNlbGVjdFJhbmdlLCB1c2VTZWxlY3RTaW5nbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJyZXF1aXJlJCQwIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsImZvcndhcmRSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VMYXlvdXRFZmZlY3QiLCJmb3JtYXQiLCJzdGFydE9mTW9udGgiLCJlbmRPZk1vbnRoIiwic3RhcnRPZkRheSIsImlzU2FtZVllYXIiLCJzZXRNb250aCIsInNldFllYXIiLCJzdGFydE9mWWVhciIsImRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzIiwiYWRkTW9udGhzIiwiaXNTYW1lTW9udGgiLCJpc0JlZm9yZSIsInN0YXJ0T2ZJU09XZWVrIiwic3RhcnRPZldlZWsiLCJhZGREYXlzIiwiaXNTYW1lRGF5IiwiaXNBZnRlciIsInN1YkRheXMiLCJkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMiLCJpc0RhdGUiLCJtYXgiLCJtaW4iLCJhZGRXZWVrcyIsImFkZFllYXJzIiwiZW5kT2ZJU09XZWVrIiwiZW5kT2ZXZWVrIiwiZ2V0VW5peFRpbWUiLCJnZXRJU09XZWVrIiwiZ2V0V2VlayIsImdldFdlZWtzSW5Nb250aCIsInBhcnNlIiwiZW5VUyIsIl9fYXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX3NwcmVhZEFycmF5IiwidG8iLCJmcm9tIiwicGFjayIsImwiLCJhciIsIkFycmF5Iiwic2xpY2UiLCJjb25jYXQiLCJTdXBwcmVzc2VkRXJyb3IiLCJlcnJvciIsInN1cHByZXNzZWQiLCJtZXNzYWdlIiwiRXJyb3IiLCJuYW1lIiwianN4UnVudGltZSIsImV4cG9ydHMiLCJyZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4iLCJoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbiIsInJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4iLCJmIiwiayIsIlN5bWJvbCIsImZvciIsIm0iLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwia2V5IiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJxIiwiYyIsImEiLCJnIiwiYiIsImQiLCJoIiwiZGVmYXVsdFByb3BzIiwiJCR0eXBlb2YiLCJ0eXBlIiwicHJvcHMiLCJfb3duZXIiLCJjdXJyZW50IiwiRnJhZ21lbnQiLCJqc3giLCJqc3hzIiwicmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50IiwiaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQiLCJyZXF1aXJlUmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50IiwicHJvY2VzcyIsIlJlYWN0IiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9sZW4yIiwiYXJncyIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0TW9kdWxlSWQiLCJ1bmRlZmluZWQiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJnZXRDb250ZXh0TmFtZSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwidmFsdWUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIiwicHJlZml4IiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJzb3VyY2UiLCJvd25lckZuIiwibWF0Y2giLCJ0cmltIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwiZnJhbWUiLCJnZXQiLCJjb250cm9sIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiRmFrZSIsImRlZmluZVByb3BlcnR5Iiwic2V0IiwiUmVmbGVjdCIsInNhbXBsZSIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwiaW5jbHVkZXMiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCIsIkNvbXBvbmVudCIsImlzUmVhY3RDb21wb25lbnQiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsImVsZW1lbnQiLCJvd25lciIsIl9zb3VyY2UiLCJzZXRFeHRyYVN0YWNrRnJhbWUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImxvY2F0aW9uIiwiY29tcG9uZW50TmFtZSIsImhhcyIsImJpbmQiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJ0eXBlTmFtZSIsImhhc1RvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJjb25zdHJ1Y3RvciIsIndpbGxDb2VyY2lvblRocm93IiwidGVzdFN0cmluZ0NvZXJjaW9uIiwiY2hlY2tLZXlTdHJpbmdDb2VyY2lvbiIsIlJFU0VSVkVEX1BST1BTIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImRpZFdhcm5BYm91dFN0cmluZ1JlZnMiLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJ3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQiLCJzZWxmIiwic3RhdGVOb2RlIiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsIl9zdG9yZSIsImZyZWV6ZSIsImpzeERFViIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJSZWFjdEN1cnJlbnRPd25lciQxIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMSIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiaXNWYWxpZEVsZW1lbnQiLCJvYmplY3QiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsImNoaWxkIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJzdGVwIiwibmV4dCIsImRvbmUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImtleXMiLCJqc3hXaXRoVmFsaWRhdGlvbiIsImlzU3RhdGljQ2hpbGRyZW4iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImNoaWxkcmVuIiwianN4V2l0aFZhbGlkYXRpb25TdGF0aWMiLCJqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMiLCJqc3hSdW50aW1lRXhwb3J0cyIsImlzRGF5UGlja2VyTXVsdGlwbGUiLCJtb2RlIiwiaXNEYXlQaWNrZXJSYW5nZSIsImlzRGF5UGlja2VyU2luZ2xlIiwiZGVmYXVsdENsYXNzTmFtZXMiLCJyb290IiwibXVsdGlwbGVfbW9udGhzIiwid2l0aF93ZWVrbnVtYmVyIiwidmhpZGRlbiIsImJ1dHRvbl9yZXNldCIsImJ1dHRvbiIsImNhcHRpb24iLCJjYXB0aW9uX3N0YXJ0IiwiY2FwdGlvbl9lbmQiLCJjYXB0aW9uX2JldHdlZW4iLCJjYXB0aW9uX2xhYmVsIiwiY2FwdGlvbl9kcm9wZG93bnMiLCJkcm9wZG93biIsImRyb3Bkb3duX21vbnRoIiwiZHJvcGRvd25feWVhciIsImRyb3Bkb3duX2ljb24iLCJtb250aHMiLCJtb250aCIsInRhYmxlIiwidGJvZHkiLCJ0Zm9vdCIsImhlYWQiLCJoZWFkX3JvdyIsImhlYWRfY2VsbCIsIm5hdiIsIm5hdl9idXR0b24iLCJuYXZfYnV0dG9uX3ByZXZpb3VzIiwibmF2X2J1dHRvbl9uZXh0IiwibmF2X2ljb24iLCJyb3ciLCJ3ZWVrbnVtYmVyIiwiY2VsbCIsImRheSIsImRheV90b2RheSIsImRheV9vdXRzaWRlIiwiZGF5X3NlbGVjdGVkIiwiZGF5X2Rpc2FibGVkIiwiZGF5X2hpZGRlbiIsImRheV9yYW5nZV9zdGFydCIsImRheV9yYW5nZV9lbmQiLCJkYXlfcmFuZ2VfbWlkZGxlIiwiZm9ybWF0Q2FwdGlvbiIsIm9wdGlvbnMiLCJmb3JtYXREYXkiLCJmb3JtYXRNb250aENhcHRpb24iLCJmb3JtYXRXZWVrTnVtYmVyIiwid2Vla051bWJlciIsImZvcm1hdFdlZWtkYXlOYW1lIiwid2Vla2RheSIsImZvcm1hdFllYXJDYXB0aW9uIiwieWVhciIsImZvcm1hdHRlcnMiLCJfX3Byb3RvX18iLCJsYWJlbERheSIsImFjdGl2ZU1vZGlmaWVycyIsImxhYmVsTW9udGhEcm9wZG93biIsImxhYmVsTmV4dCIsImxhYmVsUHJldmlvdXMiLCJsYWJlbFdlZWtkYXkiLCJsYWJlbFdlZWtOdW1iZXIiLCJsYWJlbFllYXJEcm9wZG93biIsImxhYmVscyIsImdldERlZmF1bHRDb250ZXh0VmFsdWVzIiwiY2FwdGlvbkxheW91dCIsImNsYXNzTmFtZXMiLCJsb2NhbGUiLCJtb2RpZmllcnNDbGFzc05hbWVzIiwibW9kaWZpZXJzIiwibnVtYmVyT2ZNb250aHMiLCJzdHlsZXMiLCJ0b2RheSIsIkRhdGUiLCJwYXJzZUZyb21Ub1Byb3BzIiwiZnJvbVllYXIiLCJ0b1llYXIiLCJmcm9tTW9udGgiLCJ0b01vbnRoIiwiZnJvbURhdGUiLCJ0b0RhdGUiLCJEYXlQaWNrZXJDb250ZXh0IiwiRGF5UGlja2VyUHJvdmlkZXIiLCJfYSIsImluaXRpYWxQcm9wcyIsImRlZmF1bHRDb250ZXh0VmFsdWVzIiwiX2IiLCJvblNlbGVjdCIsImNvbXBvbmVudHMiLCJQcm92aWRlciIsInVzZURheVBpY2tlciIsIkNhcHRpb25MYWJlbCIsImNsYXNzTmFtZSIsInN0eWxlIiwicm9sZSIsImlkIiwiZGlzcGxheU1vbnRoIiwiSWNvbkRyb3Bkb3duIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3Qm94IiwiZmlsbCIsImZpbGxSdWxlIiwiRHJvcGRvd24iLCJvbkNoYW5nZSIsImRheVBpY2tlciIsIkljb25Ecm9wZG93bkNvbXBvbmVudCIsIk1vbnRoc0Ryb3Bkb3duIiwiZHJvcGRvd25Nb250aHMiLCJkYXRlIiwiZ2V0TW9udGgiLCJwdXNoIiwiaGFuZGxlQ2hhbmdlIiwic2VsZWN0ZWRNb250aCIsIk51bWJlciIsInRhcmdldCIsIm5ld01vbnRoIiwiRHJvcGRvd25Db21wb25lbnQiLCJZZWFyc0Ryb3Bkb3duIiwieWVhcnMiLCJnZXRGdWxsWWVhciIsInVzZUNvbnRyb2xsZWRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsImNvbnRyb2xsZWRWYWx1ZSIsInVuY29udHJvbGxlZFZhbHVlIiwic2V0VmFsdWUiLCJnZXRJbml0aWFsTW9udGgiLCJkZWZhdWx0TW9udGgiLCJpbml0aWFsTW9udGgiLCJvZmZzZXQiLCJ1c2VOYXZpZ2F0aW9uU3RhdGUiLCJnb1RvTW9udGgiLCJkaXNhYmxlTmF2aWdhdGlvbiIsIm9uTW9udGhDaGFuZ2UiLCJnZXREaXNwbGF5TW9udGhzIiwicmV2ZXJzZU1vbnRocyIsInN0YXJ0IiwiZW5kIiwibW9udGhzRGlmZiIsIm5leHRNb250aCIsInJldmVyc2UiLCJnZXROZXh0TW9udGgiLCJzdGFydGluZ01vbnRoIiwicGFnZWROYXZpZ2F0aW9uIiwiZ2V0UHJldmlvdXNNb250aCIsIk5hdmlnYXRpb25Db250ZXh0IiwiTmF2aWdhdGlvblByb3ZpZGVyIiwiY3VycmVudE1vbnRoIiwiZGlzcGxheU1vbnRocyIsInByZXZpb3VzTW9udGgiLCJpc0RhdGVEaXNwbGF5ZWQiLCJzb21lIiwiZ29Ub0RhdGUiLCJyZWZEYXRlIiwidXNlTmF2aWdhdGlvbiIsIkNhcHRpb25Ecm9wZG93bnMiLCJoYW5kbGVNb250aENoYW5nZSIsImRpc3BsYXlJbmRleCIsIkNhcHRpb25MYWJlbENvbXBvbmVudCIsImNhcHRpb25MYWJlbCIsIkljb25MZWZ0IiwiSWNvblJpZ2h0IiwiQnV0dG9uIiwiY2xhc3NOYW1lc0FyciIsImpvaW4iLCJOYXZpZ2F0aW9uIiwiX2MiLCJkaXIiLCJfZCIsInByZXZpb3VzTGFiZWwiLCJwcmV2aW91c0NsYXNzTmFtZSIsIm5leHRMYWJlbCIsIm5leHRDbGFzc05hbWUiLCJJY29uUmlnaHRDb21wb25lbnQiLCJJY29uTGVmdENvbXBvbmVudCIsImhpZGVQcmV2aW91cyIsImRpc2FibGVkIiwib25DbGljayIsIm9uUHJldmlvdXNDbGljayIsImhpZGVOZXh0Iiwib25OZXh0Q2xpY2siLCJDYXB0aW9uTmF2aWdhdGlvbiIsImZpbmRJbmRleCIsImlzRmlyc3QiLCJpc0xhc3QiLCJoYW5kbGVQcmV2aW91c0NsaWNrIiwiaGFuZGxlTmV4dENsaWNrIiwiQ2FwdGlvbiIsIkZvb3RlciIsImZvb3RlciIsImNvbFNwYW4iLCJnZXRXZWVrZGF5cyIsIndlZWtTdGFydHNPbiIsIklTT1dlZWsiLCJkYXlzIiwiSGVhZFJvdyIsInNob3dXZWVrTnVtYmVyIiwid2Vla2RheXMiLCJzY29wZSIsIkhlYWQiLCJIZWFkUm93Q29tcG9uZW50IiwiRGF5Q29udGVudCIsIlNlbGVjdE11bHRpcGxlQ29udGV4dCIsIlNlbGVjdE11bHRpcGxlUHJvdmlkZXIiLCJlbXB0eUNvbnRleHRWYWx1ZSIsInNlbGVjdGVkIiwiU2VsZWN0TXVsdGlwbGVQcm92aWRlckludGVybmFsIiwib25EYXlDbGljayIsImlzTWluU2VsZWN0ZWQiLCJCb29sZWFuIiwiaXNNYXhTZWxlY3RlZCIsInNlbGVjdGVkRGF5cyIsImluZGV4Iiwic2VsZWN0ZWREYXkiLCJzcGxpY2UiLCJpc1NlbGVjdGVkIiwiY29udGV4dFZhbHVlIiwidXNlU2VsZWN0TXVsdGlwbGUiLCJhZGRUb1JhbmdlIiwicmFuZ2UiLCJTZWxlY3RSYW5nZUNvbnRleHQiLCJTZWxlY3RSYW5nZVByb3ZpZGVyIiwicmFuZ2Vfc3RhcnQiLCJyYW5nZV9lbmQiLCJyYW5nZV9taWRkbGUiLCJTZWxlY3RSYW5nZVByb3ZpZGVySW50ZXJuYWwiLCJzZWxlY3RlZEZyb20iLCJzZWxlY3RlZFRvIiwibmV3UmFuZ2UiLCJhZnRlciIsImJlZm9yZSIsInNlbGVjdGVkQ291bnQiLCJ1c2VTZWxlY3RSYW5nZSIsIm1hdGNoZXJUb0FycmF5IiwibWF0Y2hlciIsImdldEN1c3RvbU1vZGlmaWVycyIsImRheU1vZGlmaWVycyIsImN1c3RvbU1vZGlmaWVycyIsImZvckVhY2giLCJtb2RpZmllciIsIkludGVybmFsTW9kaWZpZXIiLCJTZWxlY3RlZCIsIkRpc2FibGVkIiwiSGlkZGVuIiwiVG9kYXkiLCJSYW5nZUVuZCIsIlJhbmdlTWlkZGxlIiwiUmFuZ2VTdGFydCIsIk91dHNpZGUiLCJnZXRJbnRlcm5hbE1vZGlmaWVycyIsInNlbGVjdE11bHRpcGxlIiwic2VsZWN0UmFuZ2UiLCJpbnRlcm5hbE1vZGlmaWVycyIsImhpZGRlbiIsIk1vZGlmaWVyc0NvbnRleHQiLCJNb2RpZmllcnNQcm92aWRlciIsInVzZU1vZGlmaWVycyIsImlzRGF0ZUludGVydmFsIiwiaXNEYXRlUmFuZ2UiLCJpc0RhdGVBZnRlclR5cGUiLCJpc0RhdGVCZWZvcmVUeXBlIiwiaXNEYXlPZldlZWtUeXBlIiwiaXNEYXRlSW5SYW5nZSIsImlzUmFuZ2VJbnZlcnRlZCIsImlzSW5SYW5nZSIsImlzRGF0ZVR5cGUiLCJpc0FycmF5T2ZEYXRlcyIsImV2ZXJ5IiwiaXNNYXRjaCIsIm1hdGNoZXJzIiwiZGF5T2ZXZWVrIiwiZ2V0RGF5IiwiZGlmZkJlZm9yZSIsImRpZmZBZnRlciIsImlzRGF5QmVmb3JlIiwiaXNEYXlBZnRlciIsImlzQ2xvc2VkSW50ZXJ2YWwiLCJnZXRBY3RpdmVNb2RpZmllcnMiLCJtYXRjaGVkTW9kaWZpZXJzIiwicmVkdWNlIiwicmVzdWx0Iiwib3V0c2lkZSIsImdldEluaXRpYWxGb2N1c1RhcmdldCIsImZpcnN0RGF5SW5Nb250aCIsImxhc3REYXlJbk1vbnRoIiwiZmlyc3RGb2N1c2FibGVEYXkiLCJpc0ZvY3VzYWJsZSIsIk1BWF9SRVRSWSIsImdldE5leHRGb2N1cyIsImZvY3VzZWREYXkiLCJtb3ZlQnkiLCJkaXJlY3Rpb24iLCJyZXRyeSIsImNvdW50IiwibGFzdEZvY3VzZWQiLCJtb3ZlRm5zIiwid2VlayIsIm5ld0ZvY3VzZWREYXkiLCJGb2N1c0NvbnRleHQiLCJGb2N1c1Byb3ZpZGVyIiwibmF2aWdhdGlvbiIsInNldEZvY3VzZWREYXkiLCJzZXRMYXN0Rm9jdXNlZCIsImluaXRpYWxGb2N1c1RhcmdldCIsImZvY3VzVGFyZ2V0IiwiYmx1ciIsImZvY3VzIiwibW92ZUZvY3VzIiwibmV4dEZvY3VzZWQiLCJmb2N1c0RheUFmdGVyIiwiZm9jdXNEYXlCZWZvcmUiLCJmb2N1c1dlZWtBZnRlciIsImZvY3VzV2Vla0JlZm9yZSIsImZvY3VzTW9udGhCZWZvcmUiLCJmb2N1c01vbnRoQWZ0ZXIiLCJmb2N1c1llYXJCZWZvcmUiLCJmb2N1c1llYXJBZnRlciIsImZvY3VzU3RhcnRPZldlZWsiLCJmb2N1c0VuZE9mV2VlayIsInVzZUZvY3VzQ29udGV4dCIsInVzZUFjdGl2ZU1vZGlmaWVycyIsIlNlbGVjdFNpbmdsZUNvbnRleHQiLCJTZWxlY3RTaW5nbGVQcm92aWRlciIsIlNlbGVjdFNpbmdsZVByb3ZpZGVySW50ZXJuYWwiLCJyZXF1aXJlZCIsInVzZVNlbGVjdFNpbmdsZSIsInVzZURheUV2ZW50SGFuZGxlcnMiLCJzaW5nbGUiLCJtdWx0aXBsZSIsIm9uRm9jdXMiLCJvbkRheUZvY3VzIiwib25CbHVyIiwib25EYXlCbHVyIiwib25Nb3VzZUVudGVyIiwib25EYXlNb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25EYXlNb3VzZUxlYXZlIiwib25Qb2ludGVyRW50ZXIiLCJvbkRheVBvaW50ZXJFbnRlciIsIm9uUG9pbnRlckxlYXZlIiwib25EYXlQb2ludGVyTGVhdmUiLCJvblRvdWNoQ2FuY2VsIiwib25EYXlUb3VjaENhbmNlbCIsIm9uVG91Y2hFbmQiLCJvbkRheVRvdWNoRW5kIiwib25Ub3VjaE1vdmUiLCJvbkRheVRvdWNoTW92ZSIsIm9uVG91Y2hTdGFydCIsIm9uRGF5VG91Y2hTdGFydCIsIm9uS2V5VXAiLCJvbkRheUtleVVwIiwib25LZXlEb3duIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJzaGlmdEtleSIsIm9uRGF5S2V5RG93biIsImV2ZW50SGFuZGxlcnMiLCJ1c2VTZWxlY3RlZERheXMiLCJpc0ludGVybmFsTW9kaWZpZXIiLCJnZXREYXlDbGFzc05hbWVzIiwiY3VzdG9tQ2xhc3NOYW1lIiwiaW50ZXJuYWxDbGFzc05hbWUiLCJnZXREYXlTdHlsZSIsIm1vZGlmaWVyc1N0eWxlcyIsInVzZURheVJlbmRlciIsImJ1dHRvblJlZiIsImZvY3VzQ29udGV4dCIsImlzQnV0dG9uIiwiaXNIaWRkZW4iLCJzaG93T3V0c2lkZURheXMiLCJEYXlDb250ZW50Q29tcG9uZW50IiwiZGl2UHJvcHMiLCJpc0ZvY3VzVGFyZ2V0IiwiaXNGb2N1c2VkIiwiYnV0dG9uUHJvcHMiLCJ0YWJJbmRleCIsImRheVJlbmRlciIsIkRheSIsIldlZWtOdW1iZXIiLCJudW1iZXIiLCJkYXRlcyIsIm9uV2Vla051bWJlckNsaWNrIiwiY29udGVudCIsImxhYmVsIiwiaGFuZGxlQ2xpY2siLCJSb3ciLCJEYXlDb21wb25lbnQiLCJXZWVrbnVtYmVyQ29tcG9uZW50Iiwid2Vla051bWJlckNlbGwiLCJkYXlzVG9Nb250aFdlZWtzIiwidG9XZWVrIiwiZnJvbVdlZWsiLCJuT2ZEYXlzIiwid2Vla3NJbk1vbnRoIiwiZXhpc3RpbmdXZWVrIiwiZmluZCIsImdldE1vbnRoV2Vla3MiLCJ1c2VGaXhlZFdlZWtzIiwibnJPZk1vbnRoV2Vla3MiLCJsYXN0V2VlayIsImxhc3REYXRlIiwiZXh0cmFXZWVrcyIsIlRhYmxlIiwiaGlkZUhlYWQiLCJmaXhlZFdlZWtzIiwiZmlyc3RXZWVrQ29udGFpbnNEYXRlIiwid2Vla3MiLCJIZWFkQ29tcG9uZW50IiwiUm93Q29tcG9uZW50IiwiRm9vdGVyQ29tcG9uZW50IiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInNlcnZlckhhbmRvZmZDb21wbGV0ZSIsImdlbklkIiwidXNlSWQiLCJwcm92aWRlZElkIiwiaW5pdGlhbElkIiwic2V0SWQiLCJNb250aCIsImNhcHRpb25JZCIsInRhYmxlSWQiLCJpc1N0YXJ0IiwiaXNFbmQiLCJpc0NlbnRlciIsIkNhcHRpb25Db21wb25lbnQiLCJNb250aHMiLCJSb290IiwiaGFzSW5pdGlhbEZvY3VzIiwic2V0SGFzSW5pdGlhbEZvY3VzIiwiaW5pdGlhbEZvY3VzIiwiZGF0YUF0dHJpYnV0ZXMiLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiYXR0cnMiLCJNb250aHNDb21wb25lbnQiLCJub25jZSIsInRpdGxlIiwibGFuZyIsIlJvb3RQcm92aWRlciIsIkRheVBpY2tlciIsImlzVmFsaWREYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwidXNlSW5wdXQiLCJmb3JtYXQkMSIsImRlZmF1bHRTZWxlY3RlZCIsInBhcnNlVmFsdWUiLCJfZSIsIl9mIiwic2V0U2VsZWN0ZWREYXkiLCJkZWZhdWx0SW5wdXRWYWx1ZSIsIl9nIiwiaW5wdXRWYWx1ZSIsInNldElucHV0VmFsdWUiLCJyZXNldCIsInNldFNlbGVjdGVkIiwiaGFuZGxlRGF5Q2xpY2siLCJoYW5kbGVCbHVyIiwiaGFuZGxlRm9jdXMiLCJkYXlQaWNrZXJQcm9wcyIsImlucHV0UHJvcHMiLCJwbGFjZWhvbGRlciIsImlzRGF5UGlja2VyRGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-day-picker/dist/index.esm.js\n");

/***/ })

};
;